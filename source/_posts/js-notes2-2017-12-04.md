---
title: javascript笔记(二)
date: 2017-12-04 09:34:52
tags: js
categories: js
---

### 变量作用域
1. 局部作用域
var 声明局部变量,生命周期在函数内部. 而JavaScript的变量作用域实际上是函数内部，以及变量提升的作用,
我们在for循环等语句块中是无法定义具有局部作用域的变量的：
为了解决块级作用域，(如for循环), ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：


2. 全局作用域
不在任何函数内定义的变量就具有全局作用域。
JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的course属性.
以变量方式`var foo = function () {}`定义的函数实际上也是一个全局变量，
因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象.
JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。

### 命名空间
局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。
减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个自定义的全局变量中.
```javascript
// 唯一的全局变量MYAPP:
var MYAPP = {};
// 其他变量:
MYAPP.name = 'myapp';
MYAPP.version = 1.0;
// 其他函数:
MYAPP.foo = function () {
    return 'foo';
};
```
把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。


### 常量
要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示这是一个常量，不要修改它的值：
ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域

### 解构赋值
ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。
解构赋值在很多时候可以大大简化代码. 但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行
**注意:**
1. 对数组元素进行解构赋值时，多个变量要用[]括起来。
2. 如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致
3. 如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性
4. 对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的
5. 使用解构赋值对对象属性进行赋值时，如果要使用的变量名和属性名不一致，可以用下面的语法获取
6. 解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题
7. 如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误, 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：
```JavaScript
var [x, y, z] = ['hello', 'JavaScript', 'ES6'];
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];
var {name, age, passport} = person;
var {name, address: {city, zip}} = person;
// 把passport属性赋值给变量id:
let {name, passport:id} = person;
// 如果person对象没有single属性，默认赋值为true:
var {name, single=true} = person;
var x, y;
// 解构赋值:
{x, y} = { name: '小明', x: 100, y: 200}; // 语法错误: Uncaught SyntaxError: Unexpected token =
({x, y} = { name: '小明', x: 100, y: 200}); //正确
```

### 方法
绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个this怎么理解？
在一个方法内部，this是一个特殊变量，它始终指向当前的调用对象.
JavaScript的函数内部如果调用了this，那么这个this到底指向谁？
答案是，视情况而定,根据当前调用者来确定. 且必须保证this指向正确，必须用obj.xxx()的形式调用！
```javascript
var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN

'use strict';
var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```

这是一个设计错误，ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误.
这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。
修复的办法:用一个that变量首先捕获this,用`var that = this;`，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。

另一个解决办法:apply
指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数:
第一个参数就是需要绑定的this变量，
第二个参数是Array，表示函数本身的参数。
```javascript
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

另一个与apply()类似的方法是call()，唯一区别是：
apply()把参数打包成Array再传入；
call()把参数按顺序传入。
```javascript
Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
```

对普通函数调用，我们通常把this绑定为null。

