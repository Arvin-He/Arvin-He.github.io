---
title: Python代码结构
date: 2017-08-11 17:00:33
tags: python
categories: python
---

###  构造项目层次结构文件夹的最佳方式是什么？
理想的特性是易于维护，IDE-friendliness，源代码管理分支/合并的适用性，以及易于生成的软件包。
特别是：
1. 在哪里放置源代码？
2. 在哪里放置应用程序启动脚本？
3. 将IDE项目放在哪里？
4. 在哪里放置单元/验收测试？
5. 在哪里放置non-Python数据如配置文件？
6. 在哪里放置non-Python源(如 C++) 用于 pyd/二进制扩展模块？

### 文件系统 python 项目的结构

执行：
* 命名与你的项目相关的目录。 例如如果你的项目名为"Twisted"，则为它的源文件命名为`top-level`目录 Twisted 。 当你发布时，应该包含版本号后缀： `Twisted-2.5` 。

* 创建一个目录 `Twisted/bin` 并将你的可执行文件放在那里，如果你有任何不给他们一个 .py 扩展，即使它们是 python 源文件。 不要将任何代码放入其中，除非导入和调用在你的项目中定义的主函数。 ( 轻微皱纹：在 Windows 上，解释器是由文件扩展名选择的，你的Windows 用户实际上想要`. py`扩展。 因此，当你为 Windows 打包时，你可能想要添加它。 不幸的是，我不知道如何让这个过程自动化。 考虑到在POSIX上，`. py` 扩展是一个惟一的缺点，而在 Windows 上，缺少的是一个实际的Bug，如果你的userbase包含 Windows 用户，那么你可能想要选择`. py` 扩展。)

* 如果你的项目是作为单个 python expressable源文件,然后把它放到目录和名称与你的项目相关的东西。 例如 Twisted/twisted.py 。如果你需要多个源文件，请创建一个软件包，并将源文件放入其中。 例如 Twisted/twisted/internet.py 。

* 把你的单元测试的sub-package ( 注意:这意味着单一 python 源文件选项上面是一个技巧——你总是需要至少一个其他文件为你的单元测试) 你的包。 例如 Twisted/twisted/test/ 。当然，让它成为一个带有 `Twisted/twisted/test/__init__.p`y的包。 将测试放在文件中 `Twisted/twisted/test/test_internet.py`
* 添加 Twisted/README 和 Twisted/setup.py 来解释并安装你的软件，如果你觉得不错的话。

不要：
* 将你的源放在一个名为 src 或者 lib的目录中。 这使得没有安装就很难运行。
* 将测试放在 python 软件包之外。 这使得对已经安装版本运行测试变得困难。
* 创建一个包,只有 `__init__.py` 然后把所有代码放进 `__init__.py` 。 只是做一个模块而不是一个包，它更简单。
* 试图让 python 能够导入你的模块或者包，而不让用户将包含它的目录添加到导入路径( 或者通过PYTHONPATH或者其他的机制) 。 你不将正确处理所有情况下,用户会生气你当你的软件并不在他们的环境中工作。

### 一个项目目录组织方式
```
Project/
|-- bin/
|   |-- project
|
|-- project/
|   |-- test/
|   |   |-- __init__.py
|   |   |-- test_main.py
|   |   
|   |-- __init__.py
|   |-- main.py
|
|-- setup.py
|-- README
```

### 另一个项目目录组织方式
当设置一个项目时，( 或者目录结构)的布局是很重要的。 合理的布局意味着潜在的贡献者不必花费大量的时间去寻找一段代码；文件位置是直观的。 因为我们正在处理一个现有项目，这意味着你可能需要移动一些东西。
让我们从头开始。 大多数项目有许多top-level文件( 像 setup.py, README.md，requirements.txt, 等) 。 然后，每个项目都应该有三个目录：
包含项目文档的文档目录
名为项目名称的目录，它存储实际的python 包
在两个位置中的一个测试目录
在包含测试代码和资源的软件包目录下
作为一个独立的顶级目录，可以更好地了解你的文件如何组织，下面是一个对我的项目的布局的简化快照，sandman:
```
$ pwd
~/code/sandman
$ tree
.
|- LICENSE
|- README.md
|- TODO.md
|- docs
| |-- conf.py
| |-- generated
| |-- index.rst
| |-- installation.rst
| |-- modules.rst
| |-- quickstart.rst
| |-- sandman.rst
|- requirements.txt
|- sandman
| |-- __init__.py
| |-- exception.py
| |-- model.py
| |-- sandman.py
| |-- test
| |-- models.py
| |-- test_sandman.py
|- setup.py
```

你可以看到，有一些顶级文件，一个文档目录( 生成的是一个空目录，sphinx将在其中放置生成的文档)，一个sandman目录和一个在sandman下的测试目录。

### 再一个项目目录组织方式
假设你的项目名为foo, 我比较建议的最方便快捷目录结构这样就足够了:
```
Foo/
|-- bin/
|   |-- foo
|
|-- foo/
|   |-- tests/
|   |   |-- __init__.py
|   |   |-- test_main.py
|   |
|   |-- __init__.py
|   |-- main.py
|
|-- docs/
|   |-- conf.py
|   |-- abc.rst
|
|-- setup.py
|-- requirements.txt
|-- README
``` 

简要解释一下:

bin/: 存放项目的一些可执行文件，当然你可以起名script/之类的也行。
foo/: 存放项目的所有源代码。(1) 源代码中的所有模块、包都应该放在此目录。不要置于顶层目录。(2) 其子目录tests/存放单元测试代码； (3) 程序的入口最好命名为main.py。
docs/: 存放一些文档。
setup.py: 安装、部署、打包的脚本。
requirements.txt: 存放软件依赖的外部Python包列表。
README: 项目说明文件。
除此之外，有一些方案给出了更加多的内容。比如LICENSE.txt,ChangeLog.txt文件等，我没有列在这里，因为这些东西主要是项目开源的时候需要用到。如果你想写一个开源软件，目录该如何组织，可以参考[这篇文章](https://jeffknupp.com/blog/2013/08/16/open-sourcing-a-python-project-the-right-way/)。

下面，再简单讲一下我对这些目录的理解和个人要求吧。

### 关于README的内容
这个我觉得是每个项目都应该有的一个文件，目的是能简要描述该项目的信息，让读者快速了解这个项目。
它需要说明以下几个事项:

* 软件定位，软件的基本功能。
* 运行代码的方法: 安装环境、启动命令等。
* 简要的使用说明。
* 代码目录结构说明，更详细点可以说明软件的基本原理。
* 常见问题说明。

我觉得有以上几点是比较好的一个README。在软件开发初期，由于开发过程中以上内容可能不明确或者发生变化，并不是一定要在一开始就将所有信息都补全。但是在项目完结的时候，是需要撰写这样的一个文档的。
可以参考Redis源码中[Readme](https://github.com/antirez/redis#what-is-redis)的写法，这里面简洁但是清晰的描述了Redis功能和源码结构。

### 关于requirements.txt和setup.py
#### setup.py

一般来说，用setup.py来管理代码的打包、安装、部署问题。业界标准的写法是用Python流行的打包工具setuptools来管理这些事情。这种方式普遍应用于开源项目中。不过这里的核心思想不是用标准化的工具来解决这些问题，而是说，**一个项目一定要有一个安装部署工具**，能快速便捷的在一台新机器上将环境装好、代码部署好和将程序运行起来。

这个我是踩过坑的。

我刚开始接触Python写项目的时候，安装环境、部署代码、运行程序这个过程全是手动完成，遇到过以下问题:

1. 安装环境时经常忘了最近又添加了一个新的Python包，结果一到线上运行，程序就出错了。
2. Python包的版本依赖问题，有时候我们程序中使用的是一个版本的Python包，但是官方的已经是最新的包了，通过手动安装就可能装错了。
3. 如果依赖的包很多的话，一个一个安装这些依赖是很费时的事情。
4. 新同学开始写项目的时候，将程序跑起来非常麻烦，因为可能经常忘了要怎么安装各种依赖。

setup.py可以将这些事情自动化起来，提高效率、减少出错的概率。"复杂的东西自动化，能自动化的东西一定要自动化。"是一个非常好的习惯。

setuptools的文档比较庞大，刚接触的话，可能不太好找到切入点。学习技术的方式就是看他人是怎么用的，可以参考一下Python的一个Web框架，flask是如何写的: [setup.py](https://github.com/pallets/flask/blob/master/setup.py)

当然，简单点自己写个安装脚本（deploy.sh）替代setup.py也未尝不可。

#### requirements.txt
这个文件存在的目的是:
1. 方便开发者维护软件的包依赖。将开发过程中新增的包添加进这个列表中，避免在setup.py安装依赖时漏掉软件包。
2. 方便读者明确项目使用了哪些Python包。
这个文件的格式是每一行包含一个包依赖的说明，通常是flask>=0.10这种格式，要求是这个格式能被pip识别，这样就可以简单的通过 `pip install -r requirements.txt`来把所有Python包依赖都装好了。具体格式说明： [点这里](https://pip.readthedocs.io/en/1.1/requirements.html)。

### 关于配置文件的使用方法
注意，在上面的目录结构中，没有将conf.py放在源码目录下，而是放在docs/目录下。

很多项目对配置文件的使用做法是:
1. 配置文件写在一个或多个python文件中，比如此处的conf.py。
2. 项目中哪个模块用到这个配置文件就直接通过import conf这种形式来在代码中使用配置。

这种做法我不太赞同:
1. 这让单元测试变得困难（因为模块内部依赖了外部配置）
2. 另一方面配置文件作为用户控制程序的接口，应当可以由用户自由指定该文件的路径。
3. 程序组件可复用性太差，因为这种贯穿所有模块的代码硬编码方式，使得大部分模块都依赖conf.py这个文件。

所以，我认为配置的使用，更好的方式是，
模块的配置都是可以灵活配置的，不受外部配置文件的影响。
程序的配置也是可以灵活控制的。
能够佐证这个思想的是，用过nginx和mysql的同学都知道，nginx、mysql这些程序都可以自由的指定用户配置。

所以，不应当在代码中直接import conf来使用配置文件。上面目录结构中的conf.py，是给出的一个配置样例，不是在写死在程序中直接引用的配置文件。可以通过给main.py启动参数指定配置路径的方式来让程序读取配置内容。当然，这里的conf.py你可以换个类似的名字，比如settings.py。或者你也可以使用其他格式的内容来编写配置文件，比如settings.yaml之类的。

对于文档的态度
目录结构中有设docs/这个目录，用于存放代码文档。实际过程中，据我观察，80%以上的程序员都没有单独写文档的习惯。一般文档写得比较好的，都是一些开源项目。

在普通的项目中，确实没必要写非常详细的文档，我更赞同的是现在的一种流行的风格: "在代码中写文档"。即在写代码的时候，在代码文件里把软件/模块的简要用法写明。简单有用。

### 参考
* [如何设计结构清晰的目录结构](http://monklof.com/post/19/)