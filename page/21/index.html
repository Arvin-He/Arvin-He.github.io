<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Simple & Freedom" type="application/atom+xml" />






<meta name="description" content="Learn and live.">
<meta property="og:type" content="website">
<meta property="og:title" content="Simple &amp; Freedom">
<meta property="og:url" content="http://arvin-he.github.io/page/21/index.html">
<meta property="og:site_name" content="Simple &amp; Freedom">
<meta property="og:description" content="Learn and live.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple &amp; Freedom">
<meta name="twitter:description" content="Learn and live.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://arvin-he.github.io/page/21/"/>





  <title>Simple & Freedom</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Simple & Freedom</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Learn and live.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/05/07/python-logging-2017-05-07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/07/python-logging-2017-05-07/" itemprop="url">Python之logging模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-07T15:46:55+08:00">
                2017-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="日志设定"><a href="#日志设定" class="headerlink" title="日志设定"></a>日志设定</h3><p>在软件开发过程中,需要将日志信息输出到控制台,写入到日志文件中.但是如何做呢?<br>在你的应用程序创建一个模块,如logger.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># logger.py</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> logging  </div><div class="line"><span class="comment"># 创建一个logger  </span></div><div class="line">logger = logging.getLogger(__file__)  </div><div class="line">logger.setLevel(logging.DEBUG)  </div><div class="line"><span class="comment"># 创建一个handler，用于写入日志文件  </span></div><div class="line">fh = logging.FileHandler(<span class="string">'mylog.log'</span>)  </div><div class="line">fh.setLevel(logging.DEBUG)  </div><div class="line"><span class="comment"># 再创建一个handler，用于输出到控制台  </span></div><div class="line">ch = logging.StreamHandler()  </div><div class="line">ch.setLevel(logging.DEBUG)  </div><div class="line"><span class="comment"># 定义handler的输出格式  </span></div><div class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(name)s - %(levelname)s - %(message)s'</span>)  </div><div class="line">fh.setFormatter(formatter)  </div><div class="line">ch.setFormatter(formatter)  </div><div class="line"><span class="comment"># 给logger添加handler  </span></div><div class="line">logger.addHandler(fh)  </div><div class="line">logger.addHandler(ch)  </div><div class="line"><span class="comment"># 记录一条日志  </span></div><div class="line">logger.info(<span class="string">'this is first log.'</span>)</div></pre></td></tr></table></figure>
<h3 id="logging模块的API"><a href="#logging模块的API" class="headerlink" title="logging模块的API"></a>logging模块的API</h3><p><code>logging.getLogger([name])</code><br>返回一个logger实例，如果没有指定name，返回root logger。只要name相同，返回的logger实例都是同一个而且只有一个，即name和logger实例是一一对应的。这意味着，无需把logger实例在各个模块中传递。只要知道name，就能得到同一个logger实例.</p>
<p><code>Logger.setLevel(lvl)</code><br>设置logger的level， level有以下几个级别：NOTSET &lt; DEBUG &lt; INFO &lt; WARNING &lt; ERROR &lt; CRITICAL</p>
<p><code>Logger.addHandler(hdlr)</code><br>logger可以雇佣handler来帮它处理日志， handler主要有以下几种：StreamHandler: 输出到控制台FileHandler:   输出到文件handler还可以设置自己的level以及输出格式。</p>
<p><code>logging.basicConfig([**kwargs])</code><br>这个函数用来配置root logger， 为root logger创建一个StreamHandler，设置默认的格式。<br>这些函数： logging.debug()、logging.info()、logging.warning()、   logging.error()、logging.critical() 如果调用的时候发现root logger没有任何   handler， 会自动调用basicConfig添加一个handler* 如果root logger已有handler， 这个函数不做任何事情<br>使用basicConfig来配置root logger的输出格式和level：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> logging  </div><div class="line">logging.basicConfig(format=<span class="string">'%(levelname)s:%(message)s'</span>, level=logging.DEBUG)  </div><div class="line">logging.debug(<span class="string">'This message should appear on the console'</span>)</div></pre></td></tr></table></figure>
<h3 id="关于root-logger以及logger的父子关系"><a href="#关于root-logger以及logger的父子关系" class="headerlink" title="关于root logger以及logger的父子关系"></a>关于root logger以及logger的父子关系</h3><p>关于root logger， 实际上logger实例之间还有父子关系， root logger就是处于最顶层的logger， 它是所有logger的祖先。如下图:</p>
<p><img src="/2017/05/07/python-logging-2017-05-07/1.png" alt="logger实例之间关系"></p>
<p>root logger是默认的logger<br>如果不创建logger实例， 直接调用logging.debug()、logging.info()logging.warning()、logging.error()、logging.critical()这些函数，那么使用的logger就是 root logger， 它可以自动创建，也是单实例的。</p>
<p>如何得到root logger<br>通过logging.getLogger()或者logging.getLogger(“”)得到root logger实例。</p>
<p>默认的levelroot<br>logger默认的level是logging.WARNING</p>
<p>如何表示父子关系<br>logger的name的命名方式可以表示logger之间的父子关系. 比如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">parent_logger = logging.getLogger(<span class="string">'foo'</span>)</div><div class="line">child_logger = logging.getLogger(<span class="string">'foo.bar'</span>)</div></pre></td></tr></table></figure></p>
<p>什么是effective level<br>logger有一个概念，叫effective level。 如果一个logger没有显示地设置level，那么它就用父亲的level。如果父亲也没有显示地设置level， 就用父亲的父亲的level，以此推….最后到达root logger，一定设置过level。默认为logging.WARNING<br>child loggers得到消息后，既把消息分发给它的handler处理，也会传递给所有祖先logger处理，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> logging  </div><div class="line">   </div><div class="line"><span class="comment"># 设置root logger  </span></div><div class="line">r = logging.getLogger()  </div><div class="line">ch = logging.StreamHandler()  </div><div class="line">ch.setLevel(logging.DEBUG)  </div><div class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(levelname)s - %(message)s'</span>)  </div><div class="line">ch.setFormatter(formatter)  </div><div class="line">r.addHandler(ch)  </div><div class="line">   </div><div class="line"><span class="comment"># 创建一个logger作为父亲  </span></div><div class="line">p = logging.getLogger(<span class="string">'foo'</span>)  </div><div class="line">p.setLevel(logging.DEBUG)  </div><div class="line">ch = logging.StreamHandler()  </div><div class="line">ch.setLevel(logging.DEBUG)  </div><div class="line">formatter = logging.Formatter(<span class="string">'%(asctime)s - %(message)s'</span>)  </div><div class="line">ch.setFormatter(formatter)  </div><div class="line">p.addHandler(ch)  </div><div class="line">   </div><div class="line"><span class="comment"># 创建一个孩子logger  </span></div><div class="line">c = logging.getLogger(<span class="string">'foo.bar'</span>)  </div><div class="line">c.debug(<span class="string">'foo'</span>)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2017-05-07 16:04:29,893 - foo  </div><div class="line">2011-05-07 16:04:29,893 - DEBUG - foo</div></pre></td></tr></table></figure>
<p>可见， 子logger没有任何handler，所以对消息不做处理。但是它把消息转发给了它的父亲以及root logger。最后输出两条日志。</p>
<h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><p>当你的应用程序用到了日志模块,并同时输出日志到控制台和文件中,打包发布并安装你的应用程序后,运行你的程序后有日志输出,当关闭应用程序会弹出一个弹框,让你去日志文件检查错误信息,并且会自动生成一个和应用程序同名的日志文件.这个弹框及和应用程序同名日志文件是怎么产生的呢?<br>原因是:控制台窗口的句柄导致的,不要将日志文件输出到控制台窗口即可.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://kenby.iteye.com/blog/1162698" target="_blank" rel="external">使用python的logging模块</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/05/05/cpp-pointer1-2017-05-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/05/cpp-pointer1-2017-05-05/" itemprop="url">C++之指针初识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-05T14:36:18+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="指针基本知识和定义"><a href="#指针基本知识和定义" class="headerlink" title="指针基本知识和定义"></a>指针基本知识和定义</h3><p>硬盘保存数据是基于物理的磁性，访问靠机械运动，所以速度比较慢.内存保存数据是基于电信号，速度比较快，但是所有数据不能长久保存，掉电即失.<br>指针的介绍都是以内存和地址开始的,内存的基本单位是字节（byte），每一个字节都有一个独一无二的地址.<br>为了保存内存中的一个地址值，C 语言需要一种特殊的变量类型，这种变量类型就是指针变量类型。整型变量保存一个整数，字符变量保存一个字符，指针变量保存一个地址.</p>
<h3 id="指针声明"><a href="#指针声明" class="headerlink" title="指针声明"></a>指针声明</h3><p>指针的定义通常有两种风格,建议采用风格1,char是一个基本类型,*p说明是一个指针, char*连在一起就显得比较怪异.当连续定义两个指针,容易出错,如下面的第三行代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span> *p;  <span class="comment">// 风格 1</span></div><div class="line"><span class="keyword">char</span>* p;  <span class="comment">// 风格 2</span></div><div class="line"><span class="keyword">char</span>* p1, p2; <span class="comment">// 错误</span></div><div class="line"><span class="keyword">char</span> *p1, *p2; <span class="comment">// 正确</span></div></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">*p = ＆a; <span class="comment">/* p = ＆a is right */</span></div><div class="line">i**p; <span class="comment">/*- what is this?*/</span></div><div class="line">*p**p; <span class="comment">/*- and then? */</span></div><div class="line">*p<span class="comment">/*p; /*-My God!*/</span></div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/05/05/cpp-typecasting-2017-05-05/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/05/cpp-typecasting-2017-05-05/" itemprop="url">C++之类型转换(Type Casting)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-05T09:21:54+08:00">
                2017-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="类型转换分类"><a href="#类型转换分类" class="headerlink" title="类型转换分类"></a>类型转换分类</h3><p>类型转换是将给定类型的表达式转换为另一种类型。C++中的转型可分为两种：隐式类型转换和显式类型转换。下面将详细介绍这两种转型操作，以及各自的适用场景，潜在问题，最终将总结使用类型转换操作应牢记的原则。</p>
<p>C风格的强制类型转换(Type Cast)很简单，不管什么类型的转换统统是：<code>TYPE b = (TYPE)a</code><br>C++风格的类型转换提供了4种类型转换操作符来应对不同场合的应用。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const_cast</span>，字面上理解就是去<span class="keyword">const</span>属性。</div><div class="line"><span class="keyword">static_cast</span>，命名上理解是静态类型转换。如<span class="keyword">int</span>转换成<span class="keyword">char</span>。</div><div class="line"><span class="keyword">dynamic_cast</span>，命名上理解是动态类型转换。如子类和父类之间的多态类型转换。</div><div class="line"><span class="keyword">reinterpret_cast</span>，仅仅重新解释类型，但没有进行二进制的转换。</div></pre></td></tr></table></figure></p>
<p>4种类型转换的格式，如：TYPE B = static_cast(TYPE)(a)。</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>隐式类型转换是C中的遗留物，在C++中并不推荐使用（C++有专门的转型操作符，见下文的显式转型）。将某种类型的对象拷贝到另一种不同类型的对象中时就会发生隐式转型。比如异型赋值，返回值（函数声明的返回值与代码块实际返回值不同的情况下），按值传递异型参数等情况均会发生隐式类型转换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">short</span> a = <span class="number">128</span>;</div><div class="line"><span class="keyword">int</span> b;</div><div class="line">b = a;</div></pre></td></tr></table></figure></p>
<p>如上所示，short 类型的对象被赋值给 int 型的对象，这是C++语言内建支持的标准转换。<br>情形一：标准转换支持<strong>数值类型</strong>，<strong>bool</strong>以及<strong>某些指针</strong>之间相互转换。注意：某些转换可能会导致精度丢失，比如从 long 转换到 int。<br>情形二：可被单参调用（只有一个参数或多个参数但至少从第二个参数起均带有缺省值）的构造函数或隐式类型转换操作符也会引起隐式类型转换。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;; </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">public</span>: B (A a) &#123;&#125;</div><div class="line">    <span class="keyword">public</span>: B (<span class="keyword">int</span> c, <span class="keyword">int</span> d = <span class="number">0</span>);</div><div class="line">    <span class="keyword">public</span>: <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>; </div><div class="line">&#125;;</div><div class="line"></div><div class="line">A a;</div><div class="line">B b1 = a;</div><div class="line">B b2 = <span class="number">10</span>;</div><div class="line">B b3;</div><div class="line"><span class="keyword">double</span> d;</div><div class="line">d = <span class="number">10</span> + b3;</div></pre></td></tr></table></figure></p>
<p>上面的代码里就存在只带有一个参数的构造函数，多个参数但至少从第二个参数起均带有缺省值以及用户自定义类型转换操作符这三种情况。<br>隐式类型转换是件麻烦事，它们很可能导致错误或非预期的函数被调用；此外 C++ 也不能在一个转换过程中连续进行多于一次的用户自定义转换操作（即情形二中的转换），如下所示：接上面的代码，A （类型的对象，后略）可被隐式转换为 B，B 可被隐式转换为 C，但 A 却非常不合逻辑地不可被隐式转换为 C。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">public</span>: C(B b) &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">A a;</div><div class="line">C c;</div><div class="line">c = a; <span class="comment">// 错误！</span></div></pre></td></tr></table></figure></p>
<p>因此应该尽量避免隐式类型转换，为此 C++ 提供了关键字 explicit 来规避可被单参调用的构造函数引起的隐式类型转换。但<strong>标准转换</strong>以及<strong>隐式类型转换操作符</strong>引起的转换只能由程序员来小心处理了。当然 C++ 语言还是提供了必要的工具，这些工具就是下面要讲的显式类型转换关键字：static_cast, const_cast, dynamic_cast 以及 reinterpret_cast。</p>
<h3 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h3><p>C++ 是一门强类型转换，因此不同自定义类型之间的转换必须进行显式转换，基础数据类型也可以进行显式转换。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">short</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> b;</div><div class="line">b = (<span class="keyword">int</span>) a;    <span class="comment">// c-like cast notation</span></div><div class="line">b = <span class="keyword">int</span> (a);    <span class="comment">// functional notation</span></div></pre></td></tr></table></figure></p>
<p>以上是基础数据类型之间进行传统的强制类型转换。这种强制类型转换可以在两种指向不同类型对象的指针之间进行，这很可能是相当危险的事情。所以 C++ 提供四种转换操作符来细分显式类型转换：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static_cast</span> &lt;new_type&gt; (expression)</div><div class="line"><span class="keyword">const_cast</span> &lt;new_type&gt; (expression)</div><div class="line"><span class="keyword">dynamic_cast</span> &lt;new_type&gt; (expression)</div><div class="line"><span class="keyword">reinterpret_cast</span> &lt;new_type&gt; (expression)</div></pre></td></tr></table></figure></p>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p>static_cast 很像 C 语言中的旧式类型转换。它能进行基础类型之间的转换，也能将带有可被单参调用的构造函数或用户自定义类型转换操作符的类型转换，还能在存有继承关系的类之间进行转换（即可将基类转换为子类，也可将子类转换为基类），还能将 non-const对象转换为 const对象（注意：反之则不行，那是const_cast的职责）</p>
<ol>
<li>基类和子类之间转换：其中子类指针转换成父类指针是安全的；但父类指针转换成子类指针是不安全的。(基类和子类之间的动态类型转换建议用dynamic_cast)</li>
<li>基本数据类型转换。enum, struct, int, char, float等。static_cast不能进行无关类型（如非基类和子类）指针之间的转换。</li>
<li>把空指针转换成目标类型的空指针。</li>
<li>把任何类型的表达式转换成void类型。</li>
<li>static_cast不能去掉类型的const、volitale属性(用const_cast)。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">double</span> d = <span class="number">3.14159265</span>;</div><div class="line"><span class="keyword">int</span> i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(d);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span>&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    B (A a) &#123;&#125;;</div><div class="line">&#125;; </div><div class="line">A a;</div><div class="line">B b = <span class="keyword">static_cast</span>&lt;B&gt;(a);</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span> &#123;</span>&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span> <span class="keyword">public</span> CBase &#123;&#125;;</div><div class="line">CBase * a = <span class="keyword">new</span> CBase;</div><div class="line">CDerived * b = <span class="keyword">static_cast</span>&lt;CDerived *&gt;(a);</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意：</strong>static_cast 转换时并不进行运行时安全检查，所以是非安全的，很容易出问题。因此 C++ 引入 dynamic_cast 来处理安全转型。</p>
<h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p>dynamic_cast 主要用来在<strong>继承体系</strong>中的<strong>安全向下</strong>转型。它能安全地将指向基类的指针转型为指向子类的指针或引用，并获知转型动作成功是否。如果转型失败会返回null（转型对象为指针时）或抛出异常（转型对象为引用时）。<br>dynamic_cast 会动用运行时信息（RTTI）来进行类型安全检查，因此 dynamic_cast 存在一定的效率损失。（曾见过属于优化代码80/20法则中的20那一部分的一段游戏代码，起初使用的是 dynamic_cast，后来被换成 static_cast 以提升效率，当然这仅是权宜之策，并非好的设计。）<br>有条件转换，动态类型转换，运行时类型安全检查(转换失败返回NULL)：</p>
<ol>
<li>安全的基类和子类之间转换。</li>
<li>必须要有虚函数。</li>
<li>相同基类不同子类之间的交叉转换。但结果是NULL。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">int</span> m_iNum;</div><div class="line">  <span class="function">virtualvoid <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;; <span class="comment">//基类必须有虚函数。保持多台特性才能使用dynamic_cast</span></div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClass</span>:</span> <span class="keyword">public</span> BaseClass </div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">char</span>*m_szName[<span class="number">100</span>];</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span>&#123;&#125;;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">BaseClass* pb =<span class="keyword">new</span> DerivedClass();</div><div class="line">DerivedClass *pd1 = <span class="keyword">static_cast</span>&lt;DerivedClass *&gt;(pb); <span class="comment">//子类-&gt;父类，静态类型转换，正确但不推荐</span></div><div class="line">DerivedClass *pd2 = <span class="keyword">dynamic_cast</span>&lt;DerivedClass *&gt;(pb); <span class="comment">//子类-&gt;父类，动态类型转换，正确</span></div><div class="line"> </div><div class="line">BaseClass* pb2 =<span class="keyword">new</span> BaseClass();</div><div class="line">DerivedClass *pd21 = <span class="keyword">static_cast</span>&lt;DerivedClass *&gt;(pb2); <span class="comment">//父类-&gt;子类，静态类型转换，危险！访问子类m_szName成员越界</span></div><div class="line">DerivedClass *pd22 = <span class="keyword">dynamic_cast</span>&lt;DerivedClass *&gt;(pb2); <span class="comment">//父类-&gt;子类，动态类型转换，安全的。结果是NULL</span></div></pre></td></tr></table></figure>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span> &#123;</span> &#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span> <span class="keyword">public</span> CBase &#123; &#125;;</div><div class="line">CBase b;</div><div class="line">CBase* pb;</div><div class="line">CDerived d;</div><div class="line">CDerived* pd;</div><div class="line">pb = <span class="keyword">dynamic_cast</span>&lt;CBase*&gt;(&amp;d);     <span class="comment">// ok: derived-to-base</span></div><div class="line">pd = <span class="keyword">dynamic_cast</span>&lt;CDerived*&gt;(&amp;b);  <span class="comment">// error: base-to-derived</span></div></pre></td></tr></table></figure>
<p>上面的代码中最后一行 VS2010 会报如下错误：error C2683: ‘dynamic_cast’ : ‘CBase’ is not a polymorphic type IntelliSense: the operand of a runtime dynamic_cast must have a polymorphic class type.<br>这是因为 dynamic_cast 只有在基类带有虚函数的情况下才允许将基类转换为子类。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CBase</span></span></div><div class="line"><span class="class"> &#123;</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"> &#125;;</div><div class="line"> <span class="class"><span class="keyword">class</span> <span class="title">CDerived</span>:</span> <span class="keyword">public</span> CBase</div><div class="line"> &#123;</div><div class="line">     <span class="keyword">int</span> a;</div><div class="line"> &#125;;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line"><span class="function"> </span>&#123;</div><div class="line">    CBase * pba = <span class="keyword">new</span> CDerived;</div><div class="line">    CBase * pbb = <span class="keyword">new</span> CBase;</div><div class="line">    CDerived * pd1, * pd2;</div><div class="line">    pd1 = <span class="keyword">dynamic_cast</span>&lt;CDerived*&gt;(pba);</div><div class="line">    pd2 = <span class="keyword">dynamic_cast</span>&lt;CDerived*&gt;(pbb);</div><div class="line">   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>结果是：上面代码中的 pd1 不为 null,而 pd2 为 null。<br>dynamic_cast 也可在 null 指针和指向其他类型的指针之间进行转换，也可以将指向类型的指针转换为 void 指针（基于此，我们可以获取一个对象的内存起始地址 const void <em> rawAddress = dynamic_cast&lt;const void </em>&gt; (this);）。</p>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p>const_cast 可去除对象的常量性（const），它还可以去除对象的易变性（volatile）。<br>const_cast 的唯一职责就在于此，若将 const_cast 用于其他转型将会报错。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span> <span class="params">(<span class="keyword">char</span> * str)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> * c = <span class="string">"hello, world"</span>;</div><div class="line">  print ( <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span> *&gt; (c) );</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><p>reinterpret_cast 用来执行低级转型，如将一个 int 指针强转为 int。其转换结果与编译平台息息相关，不具有可移植性，因此在一般的代码中不常见到它。reinterpret_cast 常用的一个用途是转换函数指针类型，即可以将一种类型的函数指针转换为另一种类型的函数指针，但这种转换可能会导致不正确的结果。<br>总之，reinterpret_cast 只用于底层代码，一般我们都用不到它，如果你的代码中使用到这种转型，务必明白自己在干什么。</p>
<ol>
<li>转换的类型必须是一个指针、引用、算术类型、函数指针或者成员指针。</li>
<li>在比特位级别上进行转换。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。但不能将非32bit的实例转成指针。</li>
<li>最普通的用途就是在函数指针类型之间进行转换。</li>
<li>很难保证移植性。</li>
</ol>
<h3 id="typeid：获取表达式的类型"><a href="#typeid：获取表达式的类型" class="headerlink" title="typeid：获取表达式的类型"></a>typeid：获取表达式的类型</h3><p>typeid 定义在标准头文件<code>&lt;typeinfo&gt;</code>中，用于获取表达式的类型，它返回一个数据类型或类名字的字符串。当 typeid 用于自定义类型时，它使用 RTTI 信息来获取对象的动态类型。基于 typeid，我们可以构建出比较对象（动态）类型的操作。</p>
<h3 id="使用原则：尽量避免类型转换操作；优先使用-C-风格的转型"><a href="#使用原则：尽量避免类型转换操作；优先使用-C-风格的转型" class="headerlink" title="使用原则：尽量避免类型转换操作；优先使用 C++ 风格的转型"></a>使用原则：尽量避免类型转换操作；优先使用 C++ 风格的转型</h3><ol>
<li>鉴于类型转换的隐蔽，不安全，易引起非预期的函数调用，对象切割等诸多问题，应该尽量避免类型转换操作。如使用 explicit 声明可被单参调用的构造函数，按引用传递参数或返回值，使用虚函数机制等等可避免类型转换；</li>
<li>若类型转换不可避免，优先使用 C++ 风格的新式类型转换。C++ 风格的类型转换一则易于辨识，二则有着其特有惯用手法，遵循这些惯用手法好处多多。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>去const属性用const_cast;<br>基本类型转换用static_cast;<br>多态类之间的类型转换用daynamic_cast;<br>不同类型的指针类型转换用reinterpret_cast;</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cppblog.com/kesalin/archive/2012/10/28/type_cast.html" target="_blank" rel="external">参考文章</a></li>
<li><a href="http://www.cnblogs.com/goodhacker/archive/2011/07/20/2111996.html" target="_blank" rel="external">参考文章</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/05/04/cpp-oov-2017-05-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/04/cpp-oov-2017-05-04/" itemprop="url">C++之overload,override,hide</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T16:30:08+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="重载-overload-、覆盖-override-、隐藏-hide-的区别"><a href="#重载-overload-、覆盖-override-、隐藏-hide-的区别" class="headerlink" title="重载(overload)、覆盖(override)、隐藏(hide)的区别"></a>重载(overload)、覆盖(override)、隐藏(hide)的区别</h3><p> 这三个概念都是与OO中的多态有关系的。如果单是区别重载与覆盖这两个概念是比较容易的，但是隐藏这一概念却使问题变得有点复杂了，下面说说它们的区别吧。<br><strong>重载:</strong>是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。<br><strong>覆盖:</strong>(也叫重写)是指在派生类中重新对基类中的虚函数（<strong>注意是虚函数</strong>）重新实现。即函数名和参数都一样，只是函数的实现体不一样。<br><strong>隐藏:</strong>是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。什么叫多态？简单地说就是一个接口，多种实现吧。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;  </span></span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>  </span></div><div class="line"><span class="class">&#123;</span>  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::f(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::g(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125; </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Base::h(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;  </div><div class="line">&#125;;  </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base </div><div class="line">&#123;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::f(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::g(int) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125; </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">(<span class="keyword">float</span> x)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived::h(float) "</span> &lt;&lt; x &lt;&lt; <span class="built_in">endl</span>; &#125; </div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面说明一下：<br>（1）函数Derived::f(float)覆盖(重写)了Base::f(float)。<br>（2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。<br>（3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。</p>
<h3 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h3><p>在实际的编程中，我们会因此遇到什么问题呢？再看下面的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">  Derived  d;  </div><div class="line">  Base *pb = &amp;d;  </div><div class="line">  Derived *pd = &amp;d; </div><div class="line">  </div><div class="line">  <span class="comment">// Good : behavior depends solely on type of the object  </span></div><div class="line">  pb-&gt;f(<span class="number">3.14f</span>); <span class="comment">// Derived::f(float) 3.14  </span></div><div class="line">  pd-&gt;f(<span class="number">3.14f</span>); <span class="comment">// Derived::f(float) 3.14  </span></div><div class="line"></div><div class="line">  <span class="comment">// Bad : behavior depends on type of the pointer  </span></div><div class="line">  pb-&gt;g(<span class="number">3.14f</span>); <span class="comment">// Base::g(float) 3.14  </span></div><div class="line">  pd-&gt;g(<span class="number">3.14f</span>); <span class="comment">// Derived::g(int) 3        (surprise!)  </span></div><div class="line"></div><div class="line">  <span class="comment">// Bad : behavior depends on type of the pointer  </span></div><div class="line">  pb-&gt;h(<span class="number">3.14f</span>); <span class="comment">// Base::h(float) 3.14      (surprise!)  </span></div><div class="line">  pd-&gt;h(<span class="number">3.14f</span>); <span class="comment">// Derived::h(float) 3.14  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在第一种调用中，函数的行为取决于<strong>指针所指向的对象</strong>。<br>在第二第三种调用中，函数的行为取决于<strong>指针的类型</strong>。<br>所以说，隐藏破坏了面向对象编程中多态这一特性，会使得OOP人员产生混乱。<br>不过隐藏也并不是一无是处，它可以帮助编程人员在编译时期找出一些错误的调用。但我觉得还是应该尽量使用隐藏这一些特性，该加virtual时就加吧。</p>
<h3 id="C-重载-覆盖-隐藏的区别和执行方式"><a href="#C-重载-覆盖-隐藏的区别和执行方式" class="headerlink" title="C++ 重载 覆盖 隐藏的区别和执行方式"></a>C++ 重载 覆盖 隐藏的区别和执行方式</h3><p>成员函数被重载的特征<br>（1）相同的范围（在同一个类中）；<br>（2）函数名字相同；<br>（3）参数不同；<br>（4）virtual 关键字可有可无。<br>覆盖是指派生类函数覆盖基类函数，特征是<br>（1）不同的范围（分别位于派生类与基类）；<br>（2）函数名字相同；<br>（3）参数相同；<br>（4）基类函数必须有virtual 关键字。<br>“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下<br>（1）如果派生类的函数与基类的函数同名,但是参数不同。此时,不论有无virtual关键字,基类的函数将被隐藏(注意别与重载混淆).<br>（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）<br>3种情况怎么执行：</p>
<ol>
<li>重载：看参数</li>
<li>隐藏：用什么就调用什么</li>
<li>覆盖：调用派生类</li>
</ol>
<p>###<br>实例一:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CB::f(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CD</span> :</span> <span class="keyword">public</span> CB</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">　 <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CD::f(int,int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">　 <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; f(<span class="number">1</span>); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">　 <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译了一下<code>error C2660: &#39;f&#39; : function does not take 1 parameters</code><br>结论：在类CD这个域中，没有f(int)这样的函数，基类中的void f(int)被隐藏</p>
<p>如果把派生CD中成员函数void f(int,int)的声明改成和基类中一样，即f(int)，基类中的void f(int)还是一样被覆盖，此时编译不会出错，在函数中test调用的是CD中的f(int)　</p>
<p>所以，在基类中的某些函数，如果没有virtral关键字，函数名是f(参数是什么我们不管)，那么如果在派生类CD中也声明了某个f成员函数，那么在类CD域中，基类中所有的那些f都被隐藏。</p>
<p>刚才说的是没有virtual的情况，如果有virtual的情况呢？？<br>实例二：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"> 　　<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CB::f(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CD</span> :</span> <span class="keyword">public</span> CB</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">　　 <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CD::f(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"> 　<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种情况我们叫覆盖(override)！覆盖指的是派生类的虚拟函数覆盖了基类的同名且参数相同的函数！<br>在这里，要强调的是，这种覆盖，要满足两个条件:<br>(a)有virtual关键字，在基类中函数声明的时候加上就可以了<br>(b)基类CB中的函数和派生类CD中的函数要<strong>一模一样</strong>，什么叫一模一样，函数名，参数，返回类型三个条件。<br>有人可能会对(b)中的说法质疑，说返回类型也要一样？？<br>是，覆盖的话必须一样，我试了试，如果在基类中,把f的声明改成virtual int f(int)，编译出错了:error C2555: ‘CD::f’ : overriding virtual function differs from ‘CB::f’ only by return type or calling convention<br>所以，覆盖的话，必须要满足上述的(a)(b)条件.</p>
<p>那么如果基类CB中的函数f有关键字virtual，但是参数和派生类CD中的函数f参数不一样呢，<br>实例三:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CB</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">　<span class="keyword">public</span>:</div><div class="line"> 　　 <span class="function"><span class="keyword">virtual</span>  <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CB::f(int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CD</span> :</span> <span class="keyword">public</span> CB</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line"> 　　 <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>，<span class="keyword">int</span>)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"CD::f(int，int)"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</div><div class="line"> 　　<span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; f(<span class="number">1</span>); &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译出错了，error C2660: ‘f’ : function does not take 1 parameters<br>和实例一中的情况一样哦，结论也是基类中的函数被隐藏了。</p>
<p>通过上面三个例子，得出一个简单的结论<br>如果基类中的函数和派生类中的两个名字一样的函数f<br>满足下面的两个条件<br>(a)在基类中函数声明的时候有virtual关键字<br>(b)基类CB中的函数和派生类CD中的函数一模一样，函数名，参数，返回类型都一样。<br>那么这就是叫做覆盖(override)，这也就是虚函数，多态的性质</p>
<p>那么其他的情况呢？？只要名字一样，不满足上面覆盖的条件，就是隐藏了。</p>
<p>下面我要讲最关键的地方了，好多人认为，基类CB中的f(int)会继承下来和CD中的f(int,int)在派生类CD中构成重载，就像实例一中想像的那样。<br>对吗？我们先看重载的定义<br>重载(overload):<br>必须在一个域中,函数名称相同但是函数参数不同,重载的作用就是同一个函数有不同的行为,因此不是在一个域中的函数是无法构成重载的,这个是重载的重要特征<br>必须在一个域中，而继承明显是在两个类中了，所以上面的想法是不成立的，派生类中的f(int,int)把基类中的f(int)隐藏了<br>所以，<strong>相同的函数名的函数，在基类和派生类中的关系只能是覆盖或者隐藏</strong>。</p>
<p>关于隐藏可以简单的理解成，在派生类域中，看不到基类中的那个同名函数了，或者说，是并没有继承下来给你用，如实例一那样。<br>　　<br>隐藏(hide):指的是派生类的成员函数隐藏了基类函数的成员函数.<br>隐藏一词可以这么理解:在调用一个类的成员函数的时候,编译器会沿着类的继承链逐级的向上查找函数的定义,如果找到了那么就停止查找了,所以如果一个派生类和一个基类都有同一个同名(暂且不论参数是否相同)的函数,而编译器最终选择了在派生类中的函数,那么我们就说这个派生类的成员函数”隐藏”了基类的成员函数,也就是说它阻止了编译器继续向上查找函数的定义.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cnblogs.com/txwsh1/archive/2008/06/28/1231751.html" target="_blank" rel="external">参考文章</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/05/04/cpp-using-2017-05-04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/04/cpp-using-2017-05-04/" itemprop="url">C++之using关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-04T16:05:57+08:00">
                2017-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>有两种基本用法：using声明和using指示（using namespace …）。<br>前者是声明，引入命名空间或基类作用域内已经被声明的名称。后者引入命名空间内所有的名称。<br>C++11新增了一类用法，可以代替typename，同时可以配合template使用（typedef基于语法考虑未被允许加入这种用法）。</p>
<h3 id="在当前文件中引入命名空间"><a href="#在当前文件中引入命名空间" class="headerlink" title="在当前文件中引入命名空间"></a>在当前文件中引入命名空间</h3><p>最熟悉的用法，例如：<code>using namespace std;</code></p>
<h3 id="在子类中使用-using-声明引入基类成员名称（参见C-primer）"><a href="#在子类中使用-using-声明引入基类成员名称（参见C-primer）" class="headerlink" title="在子类中使用 using 声明引入基类成员名称（参见C++ primer）"></a>在子类中使用 using 声明引入基类成员名称（参见C++ primer）</h3><p>在private或者protected继承时，基类成员的访问级别在派生类中更受限：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> n; &#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</div><div class="line">&#125;;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123; . . . &#125;;</div></pre></td></tr></table></figure></p>
<p>在这一继承层次中，成员函数 size 在 Base 中为 public，但在 Derived 中为 private。为了使 size 在 Derived 中成为 public，可以在 Derived 的 public 部分增加一个 using 声明。如下这样改变 Derived 的定义，可以使 size 成员能够被用户访问，并使 n 能够被 Derived的派生类访问：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base </div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">using</span> Base::size;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">  <span class="keyword">using</span> Base::n;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>另外，当子类中的成员函数和基类同名时，子类中重定义的成员函数将隐藏基类中的版本，即使函数原型不同也是如此（隐藏条件见下面）。</p>
<p>如果基类中成员函数有多个重载版本，派生类可以重定义所继承的 0 个或多个版本，但是通过派生类型只能访问派生类中重定义的那些版本，所以如果派生类想通过自身类型使用所有的重载版本，则派生类必须要么重定义所有重载版本，要么一个也不重定义。<br>有时类需要仅仅重定义一个重载集中某些版本的行为，并且想要继承其他版本的含义，在这种情况下，为了重定义需要特化的某个版本而不得不重定义每一个基类版本，可能会令人厌烦。<br>可以在派生类中为重载成员名称提供 using 声明（为基类成员函数名称而作的 using 声明将该函数的所有重载实例加到派生类的作用域），使派生类不用重定义所继承的每一个基类版本。一个 using 声明只能指定一个名字，不能指定形参表，使用using声明将名字加入作用域之后，派生类只需要重定义本类型确实必须定义的那些函数，对其他版本可以使用继承的定义。</p>
<p>“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下：<br>1、如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）<br>2、如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"StdAfx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:    </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">menfcn</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base function"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">menfcn</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="built_in">cout</span>&lt;&lt; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base function with int"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> Base</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:    </div><div class="line">  <span class="keyword">using</span> Base::menfcn;   <span class="comment">//using声明只能指定一个名字，不能带形参表</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">menfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>&#123; <span class="built_in">cout</span>&lt;&lt; <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived function with int"</span>&lt;&lt;<span class="built_in">endl</span>; &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;    </div><div class="line">  Base b; </div><div class="line">  Derived d;   </div><div class="line">  b.menfcn();  </div><div class="line">  <span class="comment">//若去掉Derived类中的using声明,会出现错误:error C2660:'Derived::menfcn':function does not take 0 arguments </span></div><div class="line">  d.menfcn();    </div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.ignore(<span class="built_in">std</span>::<span class="built_in">cin</span>.gcount()+<span class="number">1</span>); <span class="comment">//清空缓冲区    </span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cin</span>.get();<span class="comment">//暂停程序执行  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/20/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/20/">20</a><span class="page-number current">21</span><a class="page-number" href="/page/22/">22</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/22/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvin</p>
              <p class="site-description motion-element" itemprop="description">Learn and live.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">141</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arvin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
