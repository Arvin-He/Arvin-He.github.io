---
title: cookbook10-模块与包
tags:
---
### 构建一个模块的层级包
封装成包是很简单的。在文件系统上组织你的代码，并确保每个目录都定义了一个 `__init__ .py` 文件。
文件 `__init__ .py` 的目的是要包含不同运行级别的包的可选的初始化代码。
举个例子:   
如果你执行了语句`import graphics`，文件 `graphics/__init__ .py` 将被导入, 建立 graphics 命名空间的内容。
比如像`import graphics.format.jpg` 这样导入，那么文件 `graphics/__init__ .py` 和
文件 `graphics/graphics/formats/__init__ .py` 将在文件 `graphics/formats/jpg.py` 导入之前导入。
绝大部分时候让 init .py 空着就好。但是有些情况下可能包含代码。`__init__.py` 能够用来自动加载子模块.

### 控制模块被全部导入的内容
在你的模块中定义一个变量 `__all__` 来明确地列出需要导出的内容.将 `__all__` 定义成一个空列表, 没有东西将被导出。
如果 `__all__` 包含未定义的名字, 在导入时引起 AttributeError.
```python
# somemodule.py
def spam():
    pass

def grok():
    pass

blah = 42

# Only export 'spam' and 'grok'
__all__ = ['spam', 'grok']
```

###  使用相对路径名导入包中子模块
在包内，既可以使用相对路径也可以使用绝对路径来导入
```python
# mypackage/A/spam.py
from mypackage.A import grok # OK
from . import grok # OK
import grok # Error (not found)
```

像 mypackage.A 这样使用绝对路径名的不利之处是这将顶层包名硬编码到你的源
码中。如果你想重新组织它，你的代码将更脆，很难工作.如果你改变了
包名，你就必须检查所有文件来修正源码

import 语句的 `.` 和`..`看起来很滑稽, 但它指定目录名`.` 为当前目录，`..B` 为目录`../B`。这种语法只适用于 import
这里的B应当是一个目录,而不是一个文件.

尽管使用相对导入看起来像是浏览文件系统，但是不能到定义包的目录之外。也就是说，使用点的这种模式从不是包的目录中导入将会引发错误。

最后，相对导入只适用于在合适的包中的模块。尤其是在顶层的脚本的简单模块
中，它们将不起作用。如果包的部分被作为脚本直接执行，那它们将不起作用.
` python3 mypackage/A/spam.py # Relative imports fail`
另一方面，如果你使用 Python 的 -m 选项来执行先前的脚本，相对导入将会正确运行
`% python3 -m mypackage.A.spam # Relative imports work`

###  将模块分割成多个文件
你想将一个模块分割成多个文件。但是你不想将分离的文件统一成一个逻辑模块时使已有的代码遭到破坏。
```python
# mymodule.py
class A:
    def spam(self):
        print('A.spam')

class B(A):
    def bar(self):
        print('B.bar')
```

假设你想 mymodule.py 分为两个文件，每个定义的一个类。要做到这一点，首先用 mymodule 目录来替换文件 mymodule.py。这这个目录下，创建以下文件：
```
mymodule/
    __init__.py
    a.py
    b.py
```

在 a.py 文件中插入以下代码：
```python
# a.py
class A:
    def spam(self):
        print('A.spam')
```

在 b.py 文件中插入以下代码:
```python
# b.py
from .a import A

class B(A):
    def bar(self):
        print('B.bar')
```

最后，在 `__init__ .py` 中，将 2 个文件粘合在一起：
```python
# __init__.py
from .a import A
from .b import B
```

如果按照这些步骤，所产生的包 MyModule 将作为一个单一的逻辑模块：
```python
>>> import mymodule
>>> a = mymodule.A()
>>> a.spam()
A.spam
>>> b = mymodule.B()
>>> b.bar()
B.bar
```

让 mymodule 成为一个大的源文件是最常见的。这一章节展示了如何合并多个文件合并成一个单一的逻辑命名空间。这样做的关键是创建一个包目
录，使用 `__init__ .py` 文件来将每部分粘合在一起。
当一个模块被分割，你需要特别注意交叉引用的文件名。
举个例子，在这一章节中，B 类需要访问 A 类作为基类。用包的相对导入 from .a import A 来获取。

`__init__.py` 文件一次导入所有必需的组件的。但是对于一个很大的模块，可能你只想组件在需要时被加载。要做到
这一点， `__init__.py` 有细微的变化：
```python
# __init__.py
def A():
    from .a import A
    return A()

def B():
    from .b import B
    return B()
```

在这里，类 A 和类 B 被替换为在第一次访问时加载所需的类的函数。
```python
>>> import mymodule
>>> a = mymodule.A()
>>> a.spam()
A.spam
```

延迟加载的主要缺点是继承和类型检查可能会中断, 延迟加载的真实例子, 见标准库 multiprocessing/ init .py 的源码.

### 利用命名空间导入目录分散的代码
你可能有大量的代码，由不同的人来分散地维护。每个部分被组织为文件目录，如
一个包。然而，你希望能用共同的包前缀将所有组件连接起来，不是将每一个部分作
为独立的包来安装。
从本质上讲，你要定义一个顶级 Python 包，作为一个大集合分开维护子包的命名
空间。这个问题经常出现在大的应用框架中，框架开发者希望鼓励用户发布插件或附加包。
在统一不同的目录里统一相同的命名空间，但是要删去用来将组件联合起来
的 `__init__ .py` 文件。假设你有 Python 代码的两个不同的目录如下：
```
foo-package/
    spam/
        blah.py

bar-package/
    spam/
        grok.py
```

在这 2 个目录里，都有着共同的命名空间 spam。在任何一个目录里都没
有 `__init__.py` 文件。
让我们看看，如果将 foo-package 和 bar-package 都加到 python 模块路径并尝试导入会发生什么?
```python
>>> import sys
>>> sys.path.extend(['foo-package', 'bar-package'])
>>> import spam.blah
>>> import spam.grok
```

你会发现这两个不同的包目录被合并到一起，你可以导入 spam.blah 和 spam.grok，并且它们能够工作。

在这里工作的机制被称为“包命名空间”的一个特征。从本质上讲，包命名空间是一种特殊的封装设计，为合并不同的目录的代码到一个共同的命名空间。对于大的框
架，这可能是有用的，因为它允许一个框架的部分被单独地安装下载。它也使人们能够轻松地为这样的框架编写第三方附加组件和其他扩展。

包命名空间的关键是确保顶级目录中没有 `__init__ .py` 文件来作为共同的命名空间。缺失 `__init__ .py` 文件使得在导入包的时候会发生有趣的事情：这并没有产生错误，解释器创建了一个由所有包含匹配包名的目录组成的列表。特殊的包命名空间模块被创建，只读的目录列表副本被存储在其 path 变量中。
```python
>>> import spam
>>> spam.__path__
_NamespacePath(['foo-package/spam', 'bar-package/spam'])
```

在定位包的子组件时，目录 path 将被用到 (例如, 当导入 spam.grok 或者spam.blah 的时候).
包命名空间的一个重要特点是任何人都可以用自己的代码来扩展命名空间。
```
my-package/
    spam/
        custom.py
```

如果你将你的代码目录和其他包一起添加到 sys.path，这将无缝地合并到别的spam 包目录中：
```python
>>> import spam.custom
>>> import spam.grok
>>> import spam.blah
```

一个包是否被作为一个包命名空间的主要方法是检查其 file 属性。如果没有，那包是个命名空间。这也可以由其字符表现形式中的“namespace”这个词体现出来。

### 运行目录或压缩文件
您有一个已成长为包含多个文件的应用，它已远不再是一个简单的脚本，你想向用户提供一些简单的方法运行这个程序
如果你的应用程序已经有多个文件，你可以把你的应用程序放进它自己的目录并添加一个 `__main__ .py` 文件
```
myapplication/
    spam.py
    bar.py
    grok.py
    __main__.py
```

如果 `__main__ .py` 存在，你可以简单地在顶级目录运行 Python 解释器, `bash % python3 myapplication`
解释器将执行 main .py 文件作为主程序, 如果你将你的代码打包成 zip 文件，这种技术同样也适用
```
bash % ls
spam.py bar.py grok.py __main__.py
bash % zip -r myapp.zip *.py
bash % python3 myapp.zip
... output from __main__.py ...
```

### 将文件夹加入到 sys.path
你无法导入你的 Python 代码因为它所在的目录不在 sys.path 里。你想将添加新目录到 Python 路径，但是不想硬链接到你的代码。
有两种常用的方式将新目录添加到 sys.path。
第一种，你可以使用 PYTHONPATH环境变量来添加。
第二种方法是创建一个.pth 文件，将目录列举出来
这个.pth 文件需要放在某个 Python 的 site-packages 目录，通常位于/usr/local/
lib/python3.3/site-packages 或者 ˜/.local/lib/python3.3/sitepackages。当解释器启动
时，.pth 文件里列举出来的存在于文件系统的目录将被添加到 sys.path。安装一个.pth
文件可能需要管理员权限，如果它被添加到系统级的 Python 解释器

### 通过字符串名导入模块
你想导入一个模块，但是模块的名字在字符串里。你想对字符串调用导入命令。
使用 importlib.import module() 函数来手动导入名字为字符串给出的一个模块或者包的一部分

### 通过钩子远程加载模块


### 理解事件驱动的 IO
事件驱动 I/O 本质上来讲就是将基本 I/O 操作（比如读和写）转化为你程序需要处理的事件
实际上所有的事件驱动框架原理最核心的部分，都会有一个轮询的循环来检查活动 socket，并执行响应操作。
事件驱动 I/O 的一个可能好处是它能处理非常大的并发连接，而不需要使用多线
程或多进程。也就是说，select() 调用（或其他等效的）能监听大量的 socket 并响应
它们中任何一个产生事件的。在循环中一次处理一个事件，并不需要其他的并发机制。
事件驱动 I/O 的缺点是没有真正的同步机制。如果任何事件处理器方法阻塞或执
行一个耗时计算，它会阻塞所有的处理进程。调用那些并不是事件驱动风格的库函数
也会有问题，同样要是某些库函数调用会阻塞，那么也会导致整个事件循环停止。
对于阻塞或耗时计算的问题可以通过将事件发送个其他单独的现场或进程来处理。
不过，在事件循环中引入多线程和多进程是比较棘手的，