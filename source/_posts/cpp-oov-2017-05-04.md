---
title: C++之overload,override,hide理解
date: 2017-05-04 16:30:08
tags: [C/C++]
categories: 编程
---

### 重载(overload)、覆盖(override)、隐藏(hide)的区别
 这三个概念都是与OO中的多态有关系的。如果单是区别重载与覆盖这两个概念是比较容易的，但是隐藏这一概念却使问题变得有点复杂了，下面说说它们的区别吧。
**重载:**是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。
**覆盖:**(也叫重写)是指在派生类中重新对基类中的虚函数（**注意是虚函数**）重新实现。即函数名和参数都一样，只是函数的实现体不一样。
**隐藏:**是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。什么叫多态？简单地说就是一个接口，多种实现吧。

```cpp
#include <iostream.h>  
class Base  
{  
public:  
    virtual void f(float x){ cout << "Base::f(float) " << x << endl; }  
    void g(float x){ cout << "Base::g(float) " << x << endl; } 
    void h(float x){ cout << "Base::h(float) " << x << endl; }  
};  

class Derived : public Base 
{  
public:  
    virtual void f(float x){ cout << "Derived::f(float) " << x << endl; }  
    void g(int x){ cout << "Derived::g(int) " << x << endl; } 
    void h(float x){ cout << "Derived::h(float) " << x << endl; } 
};  
```
下面说明一下：
（1）函数Derived::f(float)覆盖(重写)了Base::f(float)。  
（2）函数Derived::g(int)隐藏了Base::g(float)，而不是重载。  
（3）函数Derived::h(float)隐藏了Base::h(float)，而不是覆盖。

### 实际应用
在实际的编程中，我们会因此遇到什么问题呢？再看下面的代码：
```cpp
void main(void)  
{  
  Derived  d;  
  Base *pb = &d;  
  Derived *pd = &d; 
  
  // Good : behavior depends solely on type of the object  
  pb->f(3.14f); // Derived::f(float) 3.14  
  pd->f(3.14f); // Derived::f(float) 3.14  

  // Bad : behavior depends on type of the pointer  
  pb->g(3.14f); // Base::g(float) 3.14  
  pd->g(3.14f); // Derived::g(int) 3        (surprise!)  

  // Bad : behavior depends on type of the pointer  
  pb->h(3.14f); // Base::h(float) 3.14      (surprise!)  
  pd->h(3.14f); // Derived::h(float) 3.14  
} 
```
在第一种调用中，函数的行为取决于**指针所指向的对象**。
在第二第三种调用中，函数的行为取决于**指针的类型**。
所以说，隐藏破坏了面向对象编程中多态这一特性，会使得OOP人员产生混乱。  
不过隐藏也并不是一无是处，它可以帮助编程人员在编译时期找出一些错误的调用。但我觉得还是应该尽量使用隐藏这一些特性，该加virtual时就加吧。


### C++ 重载 覆盖 隐藏的区别和执行方式
成员函数被重载的特征
（1）相同的范围（在同一个类中）； 
（2）函数名字相同； 
（3）参数不同； 
（4）virtual 关键字可有可无。 
覆盖是指派生类函数覆盖基类函数，特征是
（1）不同的范围（分别位于派生类与基类）； 
（2）函数名字相同； 
（3）参数相同； 
（4）基类函数必须有virtual 关键字。 
“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下
（1）如果派生类的函数与基类的函数同名,但是参数不同。此时,不论有无virtual关键字,基类的函数将被隐藏(注意别与重载混淆).
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆） 
3种情况怎么执行：
1. 重载：看参数
2. 隐藏：用什么就调用什么
3. 覆盖：调用派生类

###
实例一:
```cpp
#include "stdafx.h"
#include <iostream.h>

class CB
{
public:
　　void f(int) { cout << "CB::f(int)" << endl; }
};

class CD : public CB
{
public:
　 void f(int, int) { cout << "CD::f(int,int)" << endl; }
　 void test() { f(1); }
};

int main(int argc, char* argv[])
{
　 return 0;
}
```
编译了一下`error C2660: 'f' : function does not take 1 parameters`
结论：在类CD这个域中，没有f(int)这样的函数，基类中的void f(int)被隐藏

如果把派生CD中成员函数void f(int,int)的声明改成和基类中一样，即f(int)，基类中的void f(int)还是一样被覆盖，此时编译不会出错，在函数中test调用的是CD中的f(int)　

所以，在基类中的某些函数，如果没有virtral关键字，函数名是f(参数是什么我们不管)，那么如果在派生类CD中也声明了某个f成员函数，那么在类CD域中，基类中所有的那些f都被隐藏。

刚才说的是没有virtual的情况，如果有virtual的情况呢？？
实例二：
```cpp
#include "stdafx.h"
#include <iostream.h>

class CB
{
public:
 　　virtual void f(int) { cout << "CB::f(int)" << endl; }
};

class CD : public CB
{
public:
　　 void f(int) { cout << "CD::f(int)" << endl; }
};

int main(int argc, char* argv[])
{
 　return 0;
}
```

这种情况我们叫覆盖(override)！覆盖指的是派生类的虚拟函数覆盖了基类的同名且参数相同的函数！
在这里，要强调的是，这种覆盖，要满足两个条件:
(a)有virtual关键字，在基类中函数声明的时候加上就可以了
(b)基类CB中的函数和派生类CD中的函数要**一模一样**，什么叫一模一样，函数名，参数，返回类型三个条件。
有人可能会对(b)中的说法质疑，说返回类型也要一样？？
是，覆盖的话必须一样，我试了试，如果在基类中,把f的声明改成virtual int f(int)，编译出错了:error C2555: 'CD::f' : overriding virtual function differs from 'CB::f' only by return type or calling convention
所以，覆盖的话，必须要满足上述的(a)(b)条件.

那么如果基类CB中的函数f有关键字virtual，但是参数和派生类CD中的函数f参数不一样呢，
实例三:
```cpp
#include "stdafx.h"
#include <iostream.h>

class CB
{
　public:
 　　 virtual  void f(int) { cout << "CB::f(int)" << endl; }
};

class CD : public CB
{
public:
 　　 void f(int，int) { cout << "CD::f(int，int)" << endl; }
 　　void test() { f(1); }
};

int main(int argc, char* argv[])
{
  return 0;
}
```
编译出错了，error C2660: 'f' : function does not take 1 parameters
和实例一中的情况一样哦，结论也是基类中的函数被隐藏了。

通过上面三个例子，得出一个简单的结论
如果基类中的函数和派生类中的两个名字一样的函数f
满足下面的两个条件
(a)在基类中函数声明的时候有virtual关键字
(b)基类CB中的函数和派生类CD中的函数一模一样，函数名，参数，返回类型都一样。
那么这就是叫做覆盖(override)，这也就是虚函数，多态的性质

那么其他的情况呢？？只要名字一样，不满足上面覆盖的条件，就是隐藏了。

下面我要讲最关键的地方了，好多人认为，基类CB中的f(int)会继承下来和CD中的f(int,int)在派生类CD中构成重载，就像实例一中想像的那样。
对吗？我们先看重载的定义
重载(overload):
必须在一个域中,函数名称相同但是函数参数不同,重载的作用就是同一个函数有不同的行为,因此不是在一个域中的函数是无法构成重载的,这个是重载的重要特征
必须在一个域中，而继承明显是在两个类中了，所以上面的想法是不成立的，派生类中的f(int,int)把基类中的f(int)隐藏了
所以，**相同的函数名的函数，在基类和派生类中的关系只能是覆盖或者隐藏**。

关于隐藏可以简单的理解成，在派生类域中，看不到基类中的那个同名函数了，或者说，是并没有继承下来给你用，如实例一那样。
　　
隐藏(hide):指的是派生类的成员函数隐藏了基类函数的成员函数.
隐藏一词可以这么理解:在调用一个类的成员函数的时候,编译器会沿着类的继承链逐级的向上查找函数的定义,如果找到了那么就停止查找了,所以如果一个派生类和一个基类都有同一个同名(暂且不论参数是否相同)的函数,而编译器最终选择了在派生类中的函数,那么我们就说这个派生类的成员函数"隐藏"了基类的成员函数,也就是说它阻止了编译器继续向上查找函数的定义.


### 参考
* [](http://www.cnblogs.com/txwsh1/archive/2008/06/28/1231751.html)