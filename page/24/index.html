<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Simple & Freedom" type="application/atom+xml" />






<meta name="description" content="Learn and live.">
<meta property="og:type" content="website">
<meta property="og:title" content="Simple &amp; Freedom">
<meta property="og:url" content="http://arvin-he.github.io/page/24/index.html">
<meta property="og:site_name" content="Simple &amp; Freedom">
<meta property="og:description" content="Learn and live.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple &amp; Freedom">
<meta name="twitter:description" content="Learn and live.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://arvin-he.github.io/page/24/"/>





  <title>Simple & Freedom</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Simple & Freedom</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Learn and live.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/04/17/http-note4-2017-04-17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/17/http-note4-2017-04-17/" itemprop="url">Http读书笔记第四章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-17T20:01:13+08:00">
                2017-04-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="返回结果的-HTTP-状态码"><a href="#返回结果的-HTTP-状态码" class="headerlink" title="返回结果的 HTTP 状态码"></a>返回结果的 HTTP 状态码</h3><p>HTTP 状态码负责表示客户端 HTTP 请求的返回结果、标记服务器端的处理是否正常、通知出现的错误等工作。</p>
<p>状态码的类别</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">类别</th>
<th style="text-align:left">原因短语</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">Informational（信息性状态码）</td>
<td style="text-align:left">接收的请求正在处理</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">Success（成功状态码）</td>
<td style="text-align:left">请求正常处理完毕</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">Redirection（重定向状态码）</td>
<td style="text-align:left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">Client Error（客户端错误状态码）</td>
<td style="text-align:left">服务器无法处理请求</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">Server Error（服务器错误状态码）</td>
<td style="text-align:left">服务器处理请求出错</td>
</tr>
</tbody>
</table>
<p>仅记录在 RFC2616 上的 HTTP 状态码就达 40 种，若再加上<br>WebDAV（Web-based Distributed Authoring and Versioning，基于万维网的分布式创作和版本控制）（RFC4918、5842） 和附加 HTTP 状态码<br>(RFC6585)等扩展，数量就达 60 余种,实际上经常使用的大概只有 14 种.</p>
<h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><p>2XX 的响应结果表明请求被正常处理了。</p>
<h4 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h4><p>该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。<br>一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
<h4 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h4><p>该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<h4 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h4><p>永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。</p>
<h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户（本次）能使用新的 URI 访问。<br>302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。</p>
<h4 id="303-See-Other"><a href="#303-See-Other" class="headerlink" title="303 See Other"></a>303 See Other</h4><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET方法定向获取请求的资源。<br>303 状态码和 302 Found 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点与 302 状态码有区别。</p>
<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。<br>附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified-Since，If-None-Match，If-Range,If-Unmodified-Since 中任一首部。</p>
<h4 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h4><p>临时重定向。该状态码与 302 Found 有着相同的含义。尽管 302 标准禁止 POST 变换成 GET，但实际使用时大家并不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET。但是，对于处理响应时的行为，每种浏览器有可能出现不同的情况。</p>
<h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><p>4XX 的响应结果表明<strong>客户端</strong>是发生错误的原因所在。</p>
<h4 id="400-Bad-Request"><a href="#400-Bad-Request" class="headerlink" title="400 Bad Request"></a>400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p>
<h4 id="401-Unauthorized"><a href="#401-Unauthorized" class="headerlink" title="401 Unauthorized"></a>401 Unauthorized</h4><p>该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。<br>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p>
<h4 id="403-Forbidden"><a href="#403-Forbidden" class="headerlink" title="403 Forbidden"></a>403 Forbidden</h4><p>该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了.<br>未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。</p>
<h4 id="404-Not-Found"><a href="#404-Not-Found" class="headerlink" title="404 Not Found"></a>404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><p>5XX 的响应结果表明<strong>服务器</strong>本身发生错误。</p>
<h4 id="500-Internal-Server-Error"><a href="#500-Internal-Server-Error" class="headerlink" title="500 Internal Server Error"></a>500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web应用存在的 bug 或某些临时的故障。</p>
<h4 id="503-Service-Unavailable"><a href="#503-Service-Unavailable" class="headerlink" title="503 Service Unavailable"></a>503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入RetryAfter 首部字段再返回给客户端。</p>
<p>状态码和状况的不一致<br>不少返回的状态码响应都是错误的，但是用户可能察觉不到这点。<br>比如 Web 应用程序内部发生错误，状态码依然返回 200 OK，这种<br>情况也经常遇到。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/04/16/http-note3-2017-04-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/http-note3-2017-04-16/" itemprop="url">Http读书笔记第三章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T20:47:54+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>术语:<br>MIME:（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）</p>
<h3 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h3><p>用于 HTTP 协议交互的信息被称为 HTTP 报文.<br>请求端（客户端）的HTTP 报文叫做请求报文，响应端（服务器端）的叫做响应报文。HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。<br>HTTP 报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分,通常，并不一定要有报文主体。</p>
<p><img src="http-note3-2017-04-16/1.jpg" alt=""></p>
<h3 id="请求报文及响应报文的结构"><a href="#请求报文及响应报文的结构" class="headerlink" title="请求报文及响应报文的结构"></a>请求报文及响应报文的结构</h3><p><img src="http-note3-2017-04-16/2.jpg" alt=""></p>
<p>请求行:包含用于请求的方法，请求 URI 和 HTTP 版本。<br>状态行:包含表明响应结果的状态码，原因短语和 HTTP 版本。<br>首部字段:包含表示请求和响应的各种条件和属性的各类首部。<br>一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。<br>其他:可能包含 HTTP 的 RFC 里未定义的首部（Cookie 等）</p>
<h3 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h3><p>HTTP 在传输数据时可以按照数据原貌直接传输，但也可以在传输过程中通过编码提升传输速率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的 CPU 等资源</p>
<p>报文主体和实体主体的差异<br>报文（message）<br>是 HTTP 通信中的基本单位，由 8 位组字节流（octet sequence，其中 octet 为 8 个比特）组成，通过 HTTP 通信传输。<br>实体（entity）<br>作为请求或响应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成。</p>
<p>HTTP 报文的主体用于传输请求或响应的实体主体。通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。</p>
<p>压缩传输的内容编码<br>内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。</p>
<p>常用的内容编码有以下几种。</p>
<ul>
<li>gzip（GNU zip）</li>
<li>compress（UNIX 系统的标准压缩）</li>
<li>deflate（zlib）</li>
<li>identity（不进行编码）</li>
</ul>
<p>分割发送的分块传输编码<br>在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。<br>分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标记。<br>使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。<br>HTTP/1.1 中存在一种称为传输编码（Transfer Coding）的机制，它可以在通信时按某种编码方式传输，但只定义作用于分块传输编码中。</p>
<p>在 HTTP 报文中使用多部分对象集合时，需要在首部字段里加上Content-type.<br>使用 boundary 字符串来划分多部分对象集合指明的各类实体.boundary 字符串指定的各个实体的起始行之前插入“–”标记.</p>
<p>多部分对象集合的每个部分类型中，都可以含有首部字段。另外，可<br>以在某个部分中嵌套使用多部分对象集合。</p>
<h3 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h3><p>可恢复的机制:所谓恢复是指能从之前下载中断处恢复下载.<br>要实现可恢复功能需要指定下载的实体范围。<br>执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。响应会返回状态码为 206 Partial Content 的响应报文.<br>对于多重范围的范围请求，响应会在首部字段 Content-Type 标明 multipart/byteranges 后返回响应报文.如果服务器端无法响应范围请求，则会返回状态码 200 OK 和完整的实体内容。</p>
<h3 id="内容协商返回最合适的内容"><a href="#内容协商返回最合适的内容" class="headerlink" title="内容协商返回最合适的内容"></a>内容协商返回最合适的内容</h3><p>当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时，则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。<br>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。</p>
<p>包含在请求报文中的某些首部字段（如下）就是判断的基准:</p>
<ul>
<li>Accept</li>
<li>Accept-Charset</li>
<li>Accept-Encoding</li>
<li>Accept-Language</li>
<li>Content-Language</li>
</ul>
<p>内容协商技术有以下 3 种类型:</p>
<ol>
<li>服务器驱动协商（Server-driven Negotiation）<br>由服务器端进行内容协商。以请求的首部字段为参考，在服务器端自动处理。但对用户来说，以浏览器发送的信息作为判定的依据，并不一定能筛选出最优内容。</li>
<li>客户端驱动协商（Agent-driven Negotiation）<br>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。还可以利用 JavaScript 脚本在 Web 页面上自动进行上述选择。比如按 OS 的类型或浏览器类型，自行切换成 PC 版页面或手机版页面。</li>
<li>透明协商（Transparent Negotiation）<br>是服务器驱动和客户端驱动的结合体，是由服务器端和客户端各自进行内容协商的一种方法。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/04/16/flask-userlogin-2017-16/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/16/flask-userlogin-2017-16/" itemprop="url">Flask用户登录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-16T17:19:00+08:00">
                2017-04-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Flask用户登录是建立 web 表单和数据库的联系，并且编写登录系统。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>对于登录系统，会使用到两个扩展，Flask-Login 和 Flask-OpenID,<br>Flask-OpenID 扩展需要一个存储文件的临时文件夹的路径。对此，我们提供了一个 tmp 文件夹的路径。</p>
<h3 id="重构用户模型"><a href="#重构用户模型" class="headerlink" title="重构用户模型"></a>重构用户模型</h3><p>Flask-Login 扩展需要在我们的 User 类中实现一些特定的方法。但是类如何去实现这些方法却没有什么要求。</p>
<h3 id="user-loader回调"><a href="#user-loader回调" class="headerlink" title="user_loader回调"></a>user_loader回调</h3><p>必须编写一个函数用于从数据库加载用户。这个函数将会被 Flask-Login 使用</p>
<h3 id="登录视图函数"><a href="#登录视图函数" class="headerlink" title="登录视图函数"></a>登录视图函数</h3><p>oid.loginhandle 告诉 Flask-OpenID 这是登录视图函数。<br>在函数开始的时候，用检查 g.user 是否被设置成一个认证用户，如果是的话将会被重定向到首页。这里的想法是如果是一个已经登录的用户的话，就不需要二次登录了。<br>Flask 中的 g 全局变量是一个在请求生命周期中用来存储和共享数据。将登录的用户存储在这里(g)。<br>在 redirect 调用中使用的 url_for 函数是定义在 Flask 中，以一种干净的方式为一个给定的视图函数获取 URL。 让 Flask 为你构建 URLs是一个很好的选择。<br>OpenID 认证异步发生。如果认证成功的话，Flask-OpenID 将会调用一个注册了 oid.after_login 装饰器的函数。如果失败的话，用户将会回到登陆页面。</p>
<h3 id="Flask-OpenID-登录回调"><a href="#Flask-OpenID-登录回调" class="headerlink" title="Flask-OpenID 登录回调"></a>Flask-OpenID 登录回调</h3><p>这里是 after_login 函数</p>
<h3 id="全局变量g-user"><a href="#全局变量g-user" class="headerlink" title="全局变量g.user"></a>全局变量g.user</h3><p>在登录视图函数中我们检查 g.user 为了决定用户是否已经登录.<br>为了实现这个我们用 Flask 的 before_request 装饰器。任何使用了 before_request 装饰器的函数在接收请求之前都会运行</p>
<h3 id="登出"><a href="#登出" class="headerlink" title="登出"></a>登出</h3><p>只需要检查有效的用户是否被设置到 g.user 以及是否我们已经添加了登出链接。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/04/14/pyqt-translate-2017-04-14/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/14/pyqt-translate-2017-04-14/" itemprop="url">PyQt5的翻译机制分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-14T14:17:42+08:00">
                2017-04-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-PyQt中的翻译流程"><a href="#1-PyQt中的翻译流程" class="headerlink" title="1. PyQt中的翻译流程"></a>1. PyQt中的翻译流程</h3><ol>
<li><p>遍历要翻译的文件,如*.py和*.ui,以及其他需要翻译的文件等,并创建*.pro文件,(如translations.pro),将扫描到的要翻译的文件按照指定格式写入到*.pro文件中,其格式如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 如translations.pro中的内容格式</div><div class="line">// SOURCES指定要翻译的文本文件的路径,最好用相对路径</div><div class="line">// FORMS指定要翻译的ui文件的路径</div><div class="line">// TRANSLATIONS指定翻译文件的路径 </div><div class="line">SOURCES += \</div><div class="line">    E:/working/srd/plugins/tool/tool1.py \</div><div class="line">    E:/working/srd/plugins/tool/tooldialog1.py \</div><div class="line">    E:/working/srd/tool/tooldialog2.py</div><div class="line"></div><div class="line">FORMS += \</div><div class="line">    E:/working/srd/plugins/tool/res/tool.ui \</div><div class="line">    E:/working/srd/plugins/tool/res/tooldialog1.ui \</div><div class="line">    E:/working/srd/plugins/tool/res/tooldialog2.ui</div><div class="line"></div><div class="line">TRANSLATIONS += \</div><div class="line">    E:/working/srd/plugins/tool/res/translations/zh_CN.ts</div></pre></td></tr></table></figure>
</li>
<li><p>在<em>.py或者其他文本文件中创建翻译对象,并标记要翻译的文本源,这是用来提取要翻译的文本源,也是标明哪些文件需要被翻译,对于\</em>ui文件一般都是默认可翻译的.<br>同时在应用程序运行时,根据翻译对象去查找翻译后的文本,<br><strong>注意:</strong>创建的翻译对象要统一,不要不同的文件创建不同的翻译对象,这样很容易错乱掉,且不要和系统函数或者内建函数或变量重名.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">_translate = QtCore.QCoreApplication.translate</div><div class="line">pushButton = QtWidgets.QPushButton(_translate(&quot;centering&quot;, &quot;Record &#123;&#125;&quot;).format(item))</div><div class="line">_logger.error(_translate(&quot;centering&quot;, &quot;y2 is equal to y1, please pick fit coordination&quot;))</div></pre></td></tr></table></figure>
</li>
<li><p>使用Linguist翻译工具中的lupdate工具运行加载translations.pro文件,lupdate工具就会扫描SOURCES和FORMS中的文件(如*.py和*.ui文件),并创建ts文件,并将扫描到的要翻译的源文本提取出来按照指定的格式写入到ts文件中去,然后在Linguist中打开ts文件并开始翻译.ts的格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</div><div class="line">&lt;TS version=&quot;2.0&quot; language=&quot;zh_CN&quot;&gt;</div><div class="line">    &lt;context&gt;</div><div class="line">        &lt;name&gt;MACRO&lt;/name&gt;</div><div class="line">        &lt;message&gt;</div><div class="line">            &lt;location filename=&quot;../user/PROBE_SUB/9336&quot; line=&quot;231&quot;&gt;&lt;/location&gt;</div><div class="line">            &lt;source&gt;74&lt;/source&gt;</div><div class="line">            &lt;translation type=&quot;unfinished&quot;&gt;&lt;/translation&gt;</div><div class="line">        &lt;/message&gt;</div><div class="line">        &lt;message&gt;</div><div class="line">            &lt;location filename=&quot;../user/ARRAYRECT_PATH_CYCLE&quot; line=&quot;34&quot;&gt;&lt;/location&gt;</div><div class="line">            &lt;source&gt;Please select 2 plane in 2 plane machining&lt;/source&gt;</div><div class="line">            &lt;translation&gt;两板加工时请选择两板&lt;/translation&gt;</div><div class="line">        &lt;/message&gt;</div><div class="line">        &lt;message&gt;</div><div class="line">            &lt;location filename=&quot;../../centering.py&quot; line=&quot;180&quot;/&gt;</div><div class="line">            &lt;source&gt;Y1 and Y2 centering has done??&lt;/source&gt;</div><div class="line">            &lt;translation type=&quot;obsolete&quot;&gt;Y1与Y2分中完成!&lt;/translation&gt;</div><div class="line">        &lt;/message&gt;</div><div class="line">    &lt;/context&gt;</div><div class="line">&lt;/TS&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>翻译好并保存ts文件后,使用lrelease工具生成qm文件,lrelease工具会加载ts文件,并做一些去重的工作,以节省qm文件的大小.</p>
</li>
<li>最后在应用程序中加载qm翻译文件,qm文件也是一种资源文件,在应用程序中需要注意加载的时机,比如应当在界面显示前或者日志打印前加载好.<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">translator = QtCore.QTranslator()</div><div class="line">translator.load(QtCore.QLocale(), &quot;&quot;, &quot;&quot;, &quot;:/&#123;&#125;/translations&quot;.format(__name__.replace(&quot;.&quot;, &quot;/&quot;)))</div><div class="line">QtWidgets.qApp.installTranslator(translator)</div><div class="line"></div><div class="line"># 指定名称的翻译文件 </div><div class="line">if os.path.exists(os.path.join(basic.sysDir, &apos;macro/translations/common_zh_CN.qm&apos;)):</div><div class="line">    _common_macro_translator = QtCore.QTranslator()</div><div class="line">    _common_macro_translator.load(QtCore.QLocale(), &quot;common&quot;, &quot;_&quot;, os.path.join(</div><div class="line">        basic.sysDir, &quot;macro/translations&quot;))</div><div class="line">    QtWidgets.qApp.installTranslator(_common_macro_translator)</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-关于PyQt的Linguist"><a href="#2-关于PyQt的Linguist" class="headerlink" title="2. 关于PyQt的Linguist"></a>2. 关于PyQt的Linguist</h3><p>在PyQt5的安装包有一个Linguist翻译工具,为应用程序的国际化提供很好的支持.<br>Linguist提供了两款工具lupdate和lrelease.它们可以处理qmake项目文件(*.pro)，可直接在文件系统上运行.</p>
<ol>
<li>lupdate会逐个扫描应用程序中的.ui和.py文件,然后产生翻译源文件(*.ts),里面包含所有用户可见的文本,但未经过翻译(unfinished).<br>生成的.ts文件通过Linguist翻译工具打开即可看到所扫描到的要被翻译的源文本.<br>当*.py或*.ui的源文本被修改了,再次运行lupdate,就可以从应用程序中同步可见的文本,且不会破坏已经翻译好的文本.<br>lupdate工具从应用程序中提取的用户界面字符串。它读取应用程序的.pro文件，以确定哪些源文件包含的文本需要被翻译。这意味着源文件都必须被列在.pro中。如果文件没有列出，其中的文本则不会被发现。</li>
<li>运行lrelease会读取对应的.ts文件,并生成用于应用程序运行是用的.qm文件.<br>运行lrelese时生成.qm文件时会删除相同的源文本,只保留一个,这样.qm文件会比较小,且生成的.qm文件是二进制的.</li>
</ol>
<h3 id="3-使用lupdate和lrelease"><a href="#3-使用lupdate和lrelease" class="headerlink" title="3. 使用lupdate和lrelease"></a>3. 使用lupdate和lrelease</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># Qt</div><div class="line">lupdate myproject.pro </div><div class="line"># PyQt</div><div class="line">pylupdate translations.pro </div><div class="line">lrelease myproject.pro</div></pre></td></tr></table></figure>
<h3 id="4-ts文件规格分析"><a href="#4-ts文件规格分析" class="headerlink" title="4. ts文件规格分析"></a>4. ts文件规格分析</h3><p>ts文件是可读的XML文件,包含源短语及其翻译，ts文件通常由lupdate创建与更新.</p>
<ol>
<li><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</code>ts文件的开头说明,其实是xml文件的开头说明.指明xml版本和编码</li>
<li><code>&lt;!DOCTYPE TS&gt;</code>指明文档类型是一个ts文件,可有可无</li>
<li><p>TS标签<br>TS标签格式如下,指定Linguist版本和翻译后的语言,TS标签里的内容是由context标签组成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;TS version=&quot;2.1&quot; language=&quot;zh_CN&quot;&gt;</div><div class="line">    &lt;context&gt;</div><div class="line">        ...</div><div class="line">    &lt;/context&gt;</div><div class="line">    &lt;context&gt;</div><div class="line">        ...</div><div class="line">    &lt;/context&gt;</div><div class="line">    &lt;context&gt;</div><div class="line">        ...</div><div class="line">    &lt;/context&gt;</div><div class="line">    ...</div><div class="line">&lt;/TS&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>context标签<br>context标签是一个上下文标签,不同的context是根据子标签的<name>来区分,指明这个context的对象名.<br>通常一个文件就是一个context,如果是以ui文件,那么name就是这个ui的对象名,注意不是ui文件名,如果是一个py文件,那么name就是py文件名.<br>如果想把多个文件合并到一个context中去,那么需要指定一个name,那么这多个文件的翻译都会放在这一个context中.这个name最终传给翻译对象的第一个参数.</name></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;context&gt;</div><div class="line">    &lt;name&gt;...&lt;/name&gt;</div><div class="line">    &lt;message&gt;</div><div class="line">        &lt;location filename=&quot;...&quot; line=&quot;...&quot;/&gt;</div><div class="line">        &lt;source&gt;...&lt;/source&gt;</div><div class="line">        &lt;translation&gt;...&lt;/translation&gt;</div><div class="line">    &lt;/message&gt;</div><div class="line">    &lt;message&gt;</div><div class="line">        &lt;location filename=&quot;...&quot; line=&quot;...&quot;/&gt;</div><div class="line">        &lt;source&gt;...&lt;/source&gt;</div><div class="line">        &lt;translation&gt;...&lt;/translation&gt;</div><div class="line">    &lt;/message&gt;</div><div class="line">    ...</div><div class="line">&lt;/context&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>注意:</strong>这里的name其实是对应这翻译对象里的name的参数.如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">macro_text = \_translate(&quot;MACRO&quot;, dst\_text)</div><div class="line">pushButton = QPushButton(_translate(&quot;centering&quot;, &quot;Record &#123;&#125;&quot;).format(item))</div></pre></td></tr></table></figure></p>
<ol>
<li>message标签<br>message标签由location,source和translation标签组成,其中:<br>location:指定被翻译文件的路径和行号,注意:被翻译文件路径是相对与这个ts文件的相对路径<br>source:翻译的源文本<br>translation:翻译文本<br>translation的翻译状态有type指定,type有三种情况:unfinished(未翻译),空(已翻译),obsolete(废弃的)<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;message&gt;</div><div class="line">        &lt;location filename=&quot;...&quot; line=&quot;...&quot;/&gt;</div><div class="line">        &lt;source&gt;...&lt;/source&gt;</div><div class="line">        &lt;translation&gt;...&lt;/translation&gt;</div><div class="line">&lt;/message&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="5-qm文件"><a href="#5-qm文件" class="headerlink" title="5. qm文件"></a>5. qm文件</h3><p>qm(Qt message)文件和ts文件的文件名称一样,一一对应,qm文件由lrelease创建.</p>
<h3 id="6-创建ts文件"><a href="#6-创建ts文件" class="headerlink" title="6. 创建ts文件"></a>6. 创建ts文件</h3><p>ts文件其实就是xml文件,创建ts文件可以应用python的第三方包:xmltodict,可将字典数据结构直接转化成xml了.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">TS_XML = OrderedDict()</div><div class="line">TS = OrderedDict()</div><div class="line">context = OrderedDict()</div><div class="line">TS[<span class="string">"@version"</span>] = <span class="string">"2.1"</span></div><div class="line">TS[<span class="string">"@language"</span>] = <span class="string">"zh_CN"</span></div><div class="line">context[<span class="string">"name"</span>] = <span class="string">"MACRO"</span></div><div class="line">message = OrderedDict()</div><div class="line">location = OrderedDict()</div><div class="line">translation = OrderedDict()</div><div class="line"><span class="comment"># message/location 标签</span></div><div class="line">location[<span class="string">"@filename"</span>] = os.path.relpath(file_path, trans_path).replace(<span class="string">"\\"</span>, <span class="string">"/"</span>)</div><div class="line">location[<span class="string">"@line"</span>] = line_index + <span class="number">1</span></div><div class="line">message[<span class="string">"location"</span>] = location</div><div class="line"><span class="keyword">if</span> line_content.strip()[<span class="number">0</span>:<span class="number">3</span>] == <span class="string">'ASK'</span>:</div><div class="line">    source = ((match.group()[<span class="number">4</span>:<span class="number">-1</span>]).split(<span class="string">','</span>))[<span class="number">2</span>]</div><div class="line"><span class="comment"># message/source 标签</span></div><div class="line">message[<span class="string">"source"</span>] = source</div><div class="line"><span class="comment"># message/translation 标签</span></div><div class="line">translation[<span class="string">"@type"</span>] = <span class="string">"unfinished"</span></div><div class="line">message[<span class="string">"translation"</span>] = translation</div><div class="line">TS[<span class="string">"context"</span>] = context</div><div class="line">TS_XML[<span class="string">"TS"</span>] = TS</div><div class="line"><span class="comment"># 创建ts文件</span></div><div class="line"><span class="keyword">with</span> open(os.path.join(ts_path, trans_file_name), <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</div><div class="line">    xmltodict.unparse(TS_XML, f, pretty=<span class="keyword">True</span>, newl=new_line, indent=indent)</div></pre></td></tr></table></figure></p>
<p>有了ts文件,就可以应用lupdate和lrelease工具生成qm文件<br>当翻译源文本有了修改,就需要重新生成ts文件了,这里需要注意一个问题,没有修改的翻译会被丢失.<br>这就需要先解析修改前的ts文件,然后对比修改后的ts文件的源文本,只更新修改了的.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">parseTS</span><span class="params">(ts_path)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="string">'base'</span> <span class="keyword">in</span> ts_path <span class="keyword">and</span> <span class="string">'macro'</span> <span class="keyword">in</span> ts_path:</div><div class="line">        trans_file_name = <span class="string">"common_zh_CN.ts"</span></div><div class="line">    <span class="keyword">elif</span> <span class="string">'sys'</span> <span class="keyword">in</span> ts_path <span class="keyword">and</span> <span class="string">'macro'</span> <span class="keyword">in</span> ts_path:</div><div class="line">        trans_file_name = <span class="string">"user_zh_CN.ts"</span></div><div class="line">    ts_file = os.path.join(ts_path, trans_file_name)</div><div class="line">    <span class="keyword">with</span> open(ts_file, <span class="string">"r"</span>, <span class="number">-1</span>, <span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</div><div class="line">        document = f.read()</div><div class="line">    ts_xml = xmltodict.parse(document)</div><div class="line">    macro_context_list = ts_xml[<span class="string">'TS'</span>][<span class="string">'context'</span>][<span class="string">'message'</span>]</div><div class="line">    <span class="keyword">return</span> macro_context_list</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">updateTS</span><span class="params">(ts_path, new_message_list)</span>:</span></div><div class="line">    old_message_list = parseTS(ts_path)</div><div class="line">    <span class="keyword">for</span> new_message <span class="keyword">in</span> new_message_list:</div><div class="line">        <span class="keyword">for</span> old_message <span class="keyword">in</span> old_message_list:</div><div class="line">            <span class="keyword">if</span> new_message[<span class="string">"source"</span>] == old_message[<span class="string">"source"</span>]:</div><div class="line">                new_message[<span class="string">"translation"</span>] = old_message[<span class="string">"translation"</span>]</div><div class="line">    <span class="keyword">return</span> new_message_list</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/04/13/http-note2-2017-04-13/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/13/http-note2-2017-04-13/" itemprop="url">Http读书笔记第二章</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-13T22:28:20+08:00">
                2017-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="客户端与服务端"><a href="#客户端与服务端" class="headerlink" title="客户端与服务端"></a>客户端与服务端</h3><p>客户端:请求访问文本或图像等资源的一端,<br>服务器端:提供资源响应的一端.<br>两台计算机之间使用 HTTP 协议通信时，在一条通信线路上必定有一端是客户端，另一端则是服务器端.实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的，而用 HTTP 协议能够明确区分哪端是客户端，哪端是服务器端。</p>
<h3 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h3><p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。换句话说，肯定是先从客户端开始建立通信的，服务器端在没有接收到请求之前不会发送响应。</p>
<p>请求报文组成:<br>是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。</p>
<p>响应报文组成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 200 OK</div><div class="line">Date: Tue, 10 Jul 2012 06:50:15 GMT</div><div class="line">Content-Length: 362</div><div class="line">Content-Type: text/html</div><div class="line"></div><div class="line">&lt;html&gt;</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>在起始行开头的 HTTP/1.1 表示服务器对应的 HTTP 版本。紧挨着的 200 OK 表示请求的处理结果的状态码（status code）和原因短语（reason-phrase）。下一行显示了创建响应的日期时间，是首部字段（header field）内的一个属性。接着以一空行分隔，之后的内容称为资源实体的主体（entitybody）。</p>
<p>响应报文基本上由协议版本、状态码（表示请求成功或失败的数字代码）、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</p>
<h3 id="HTTP-是不保存状态的协议"><a href="#HTTP-是不保存状态的协议" class="headerlink" title="HTTP 是不保存状态的协议"></a>HTTP 是不保存状态的协议</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议.HTTP 协议自身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个级别，协议对于发送过的请求或响应都不做持久化处理。使用 HTTP 协议，每当有新的请求发送时，就会有对应的新响应产生。协议本身并不保留之前一切的请求或响应报文的信息。</p>
<p>HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。</p>
<h3 id="请求-URI-定位资源"><a href="#请求-URI-定位资源" class="headerlink" title="请求 URI 定位资源"></a>请求 URI 定位资源</h3><p>HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。</p>
<h3 id="告知服务器意图的-HTTP-方法"><a href="#告知服务器意图的-HTTP-方法" class="headerlink" title="告知服务器意图的 HTTP 方法"></a>告知服务器意图的 HTTP 方法</h3><p>GET ：获取资源<br>GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接口）那样的程序，则返回经过执行后的输出结果。</p>
<p>POST：传输实体主体<br>虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但POST 的主要目的并不是获取响应的主体内容。</p>
<p>PUT：传输文件<br>PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用<br>REST（REpresentational State Transfer，表征状态转移）标准的同类Web 网站，就可能会开放使用 PUT 方法。</p>
<p>HEAD：获得报文首部<br>HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认URI 的有效性及资源更新的日期时间等。</p>
<p>DELETE：删除文件<br>DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按请求 URI 删除指定的资源。<br>HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。</p>
<p>OPTIONS：询问支持的方法<br>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</p>
<p>TRACE：追踪路径<br>TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改/ 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。但是，TRACE 方法本来就不怎么常用，再加上它容易引发XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。</p>
<p>CONNECT：要求用隧道协议连接代理<br>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。CONNECT 方法的格式:CONNECT 代理服务器名:端口号 HTTP版本</p>
<h3 id="持久连接节省通信量"><a href="#持久连接节省通信量" class="headerlink" title="持久连接节省通信量"></a>持久连接节省通信量</h3><p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP连接。为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使<br>HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相应提高了。<br>在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并未标准化。虽然有一部分服务器通过非标准的手段实现了持久连接，但服务器端不一定能够支持持久连接。毫无疑问，除了服务器端，客户端也需要支持持久连接。</p>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。</p>
<h3 id="使用-Cookie-的状态管理"><a href="#使用-Cookie-的状态管理" class="headerlink" title="使用 Cookie 的状态管理"></a>使用 Cookie 的状态管理</h3><p>HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。无状态协议当然也有它的优点。由于不必保存状态，自然可减少服务器的 CPU 及内存资源的消耗。</p>
<p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。<br>Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/23/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/23/">23</a><span class="page-number current">24</span><a class="page-number" href="/page/25/">25</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/25/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvin</p>
              <p class="site-description motion-element" itemprop="description">Learn and live.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">141</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arvin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
