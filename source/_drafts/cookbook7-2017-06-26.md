---
title: cookbook7-2017-06-26
tags:
---
## 函数
使用 def 语句定义函数是所有程序的基础,本章的目标是讲解一些更加高级和不
常见的函数定义与使用模式。涉及到的内容包括默认参数、任意数量参数、强制关键
字参数、注解和闭包。另外，一些高级的控制流和利用回调函数传递数据的技术.

### 可接受任意数量参数的函数
让一个函数接受任意数量的位置参数，使用一个 * 参数
```python
def avg(first, *rest):
    return (first + sum(rest)) / (1 + len(rest))
```

接受任意数量的关键字参数，使用一个以 ** 开头的参数
```python
def make_element(name, value, **attrs):
    keyvals = [' %s="%s"' % item for item in attrs.items()]
    attr_str = ''.join(keyvals)
    element = '<{name}{attrs}>{value}</{name}>'.format( name=name,
                                                        attrs=attr_str,
                                                        value=html.escape(value))
return element
```

一个 * 参数只能出现在函数定义中最后一个位置参数后面，而**参数只能出现在
最后一个参数。有一点要注意的是，在 * 参数后面仍然可以定义其他参数。
```python
def a(x, *args, y):
pass

def b(x, *args, y, **kwargs):
pass
```

### 只接受关键字参数的函数
将强制关键字参数放到某个 * 参数或者单个 * 后面就能达到这种效果
```python
def recv(maxsize, *, block):
'Receives a message'
    pass

recv(1024, True) # TypeError
recv(1024, block=True) # Ok
```

在接受任意多个位置参数的函数中指定关键字参数
```python
def mininum(*values, clip=None):
    m = min(values)
    if clip is not None:
        m = clip if clip > m else m
    return m

minimum(1, 5, 2, -5, 10) # Returns -5
minimum(1, 5, 2, -5, 10, clip=0) # Returns 0
```

### 给函数参数增加元信息
使用函数参数注解是一个很好的办法，它能提示程序员应该怎样正确使用这个函数
```python
def add(x:int, y:int) -> int:
    return x + y
```

函数注解只存储在函数的 annotations 属性中
```python
>>> add.__annotations__
{'y': <class 'int'>, 'return': <class 'int'>, 'x': <class 'int'>}
```

### 返回多个值的函数
函数直接 return 一个元组就行了
```python
>>> def myfun():
... return 1, 2, 3
```

尽管 myfun() 看上去返回了多个值，实际上是先创建了一个元组然后返回的。这个
语法看上去比较奇怪，实际上我们使用的是**逗号**来生成一个元组，而不是用括号。    

### 定义有默认参数的函数
定义一个函数或者方法，它的一个或多个参数是可选的并且有一个默认值.
定义一个有可选参数的函数是非常简单的，直接在函数定义中给参数指定一个默认值，并放到参数列表最后就行了.
```python
def spam(a, b=42):
    print(a, b)

spam(1) # Ok. a=1, b=42
spam(1, 2) # Ok. a=1, b=2    
```

如果默认参数是一个可修改的容器比如一个列表、集合或者字典，可以使用 None作为默认值，
```python
def spam(a, b=None):
    if b is None:
        b = []
    ...
```

如果你并不想提供一个默认值，而是想仅仅测试下某个默认参数是不是有传递进来，可以像下面这样写：
```python
_no_value = object()

def spam(a, b=_no_value):
    if b is _no_value:
        print('No b value supplied')

>>> spam(1)
No b value supplied
>>> spam(1, 2) # b = 2
>>> spam(1, None) # b = None
>>>        
```

默认参数的值仅仅在函数定义的时候赋值一次
```python
>>> x = 42
>>> def spam(a, b=x):
...     print(a, b)
...
>>> spam(1)
1 42
>>> x = 23 # Has no effect
>>> spam(1)
1 42
>>>
```

注意到当我们改变 x 的值的时候对默认参数值并没有影响，这是因为在函数定义的
时候就已经确定了它的默认值了。
其次，默认参数的值应该是不可变的对象，比如 None、True、False、数字或字符
串。特别的，千万不要像下面这样写代码：
```python
def spam(a, b=[]): # NO!
    ...
```    

如果你这么做了，当默认值在其他地方被修改后你将会遇到各种麻烦。这些修改会
影响到下次调用这个函数时的默认值。
```python
>>> def spam(a, b=[]):
...     print(b)
...     return b
...
>>> x = spam(1)
>>> x
[]
>>> x.append(99)
>>> x.append('Yow!')
>>> x
[99, 'Yow!']
>>> spam(1) # Modified list gets returned!
[99, 'Yow!']
>>>
```

这种结果应该不是你想要的。为了避免这种情况的发生，最好是将默认值设为None，然后在函数里面检查它.


在测试 None 值时使用 is 操作符是很重要的，也是这种方案的关键点。
```python
def spam(a, b=None):
    if not b: # NO! Use 'b is None' instead
        b = []
    ...
```

这么写的问题在于尽管 None 值确实是被当成 False，但是还有其他的对象 (比如长
度为 0 的字符串、列表、元组、字典等) 都会被当做 False。因此，上面的代码会误将
一些其他输入也当成是没有输入。

一个问题比较微妙，那就是一个函数需要测试某个可选参数是否被使用者传递
进来。这时候需要小心的是你不能用某个默认值比如 None、0 或者 False 值来测试用
户提供的值 (因为这些值都是合法的值，是可能被用户传递进来的)。因此，你需要其
他的解决方案了。
为了解决这个问题，你可以创建一个独一无二的私有对象实例，就像上面
的 no value 变量那样。在函数里面，你可以通过检查被传递参数值跟这个实例是否
一样来判断。这里的思路是用户不可能去传递这个 no value 实例作为输入。因此，这
里通过检查这个值就能确定某个参数是否被传递进来了。

###  定义匿名或内联函数
当一些函数很简单，仅仅只是计算一个表达式的值的时候，就可以使用 lambda 表达式来代替.
```python
>>> add = lambda x, y: x + y
>>> add(2,3)
5
>>> add('hello', 'world')
'helloworld'
```

lambda 表达式典型的使用场景是排序或数据 reduce 等：
`sorted(names, key=lambda name: name.split()[-1].lower())`

尽管 lambda 表达式允许你定义简单函数，但是它的使用是**有限制**的。你只能指定
单个表达式，它的值就是最后的返回值。也就是说不能包含其他的语言特性了，包括
**多个语句**、**条件表达式**、**迭代**以及**异常处理**等等。
你可以不使用 lambda 表达式就能编写大部分 python 代码。但是，当有人编写大
量计算表达式值的短小函数或者需要用户提供回调函数的程序的时候，你就会看到
lambda 表达式的身影了。

### 匿名函数捕获变量值
```python
>>> a = lambda y: x + y

>>> x = 15
>>> a(10)
25
>>> x = 3
>>> a(10)
13
```

 lambda 表达式中的 x 是一个自由变量，在运行时绑定值，而不
是定义时就绑定，这跟函数的默认值参数定义是不同的。因此，在调用这个 lambda 表
达式的时候，x 的值是执行时的值。

有些新手可能会不恰当的使用
lambda 表达式。比如，通过在一个循环或列表推导中创建一个 lambda 表达式列
表，并期望函数能在定义时就记住每次的迭代值。例如：
```python
>>> funcs = [lambda x: x+n for n in range(5)]
>>> for f in funcs:
...     print(f(0))
...
4
4
4
4
4
```

但是实际效果是运行是 n 的值为迭代的最后一个值。现在我们用另一种方式修改一下：
```python
>>> funcs = [lambda x, n=n: x+n for n in range(5)]
>>> for f in funcs:
...     print(f(0))
...
0
1
2
3
4
```

### 减少可调用对象的参数个数
减少某个函数的参数个数，你可以使用 functools.partial() 。
partial() 函数允许你给一个或多个参数设置固定的值，减少接下来被调用时的参数个数。

应用: 解决的问题是让原本不兼容的代码可以一起工作

### 将单方法的类转换为函数
大多数情况下，可以使用闭包来将单个方法的类转换成函数。
简单来讲，一个闭包就是一个函数，只不过在函数内部带上了一个额外的变量环境。闭包关键特点就是它会记住自己被定义时的环境。
任何时候只要你碰到需要给某个函数增加额外的状态信息的问题，都可以考虑使用
闭包。相比将你的函数转换成一个类而言，闭包通常是一种更加简洁和优雅的方案。

### 带额外状态信息的回调函数
你的代码中需要依赖到回调函数的使用 (比如事件处理器、等待后台任务完成后的
回调等)，并且你还需要让回调函数拥有额外的状态值，以便在它的内部使用到。
```python
def apply_async(func, args, *, callback):
    # Compute the result
    result = func(*args)
    # Invoke the callback with the result
    callback(result)
```

实际上，这段代码可以做任何更高级的处理，包括线程、进程和定时器，但是这些
都不是我们要关心的。我们仅仅只需要关注回调函数的调用。
```python
>>> def print_result(result):
...     print('Got:', result)
...
>>> def add(x, y):
...     return x + y
...
>>> apply_async(add, (2, 3), callback=print_result)
Got: 5
>>> apply_async(add, ('hello', 'world'), callback=print_result)
Got: helloworld
>>>
```

注意到 print result() 函数**仅仅只接受一个参数 result** 。不能再传入其他信息。
而当你想让回调函数访问其他变量或者特定环境的变量值的时候就会遇到麻烦。
为了让回调函数访问外部信息，一种方法是使用一个绑定方法来代替一个简单函
数。比如，下面这个类会保存一个内部序列号，每次接收到一个 result 的时候序列号
加 1：
```python
class ResultHandler:
    def __init__(self):
        self.sequence = 0

    def handler(self, result):
        self.sequence += 1
        print('[{}] Got: {}'.format(self.sequence, result))
```

使用这个类的时候，你先创建一个类的实例，然后用它的 handler() 绑定方法来
做为回调函数：
```python
>>> r = ResultHandler()
>>> apply_async(add, (2, 3), callback=r.handler)
[1] Got: 5
>>> apply_async(add, ('hello', 'world'), callback=r.handler)
[2] Got: helloworld
>>>
```

第二种方式，作为类的替代，可以使用一个闭包捕获状态值，例如：
```python
def make_handler():
    sequence = 0
    def handler(result):
        nonlocal sequence
        sequence += 1
        print('[{}] Got: {}'.format(sequence, result))
    return handler
```

下面是使用闭包方式的一个例子：
```python
>>> handler = make_handler()
>>> apply_async(add, (2, 3), callback=handler)
[1] Got: 5
>>> apply_async(add, ('hello', 'world'), callback=handler)
[2] Got: helloworld
>>>
```

还有另外一个更高级的方法，可以使用协程来完成同样的事情：
```python
def make_handler():
    sequence = 0
    while True:
    result = yield
    sequence += 1
    print('[{}] Got: {}'.format(sequence, result))
```
对于协程，你需要使用它的 send() 方法作为回调函数，如下所示：
```python
>>> handler = make_handler()
>>> next(handler) # Advance to the yield
>>> apply_async(add, (2, 3), callback=handler.send)
[1] Got: 5
>>> apply_async(add, ('hello', 'world'), callback=handler.send)
[2] Got: helloworld
```

基于回调函数的软件通常都有可能变得非常复杂。一部分原因是回调函数通常会
跟请求执行代码断开。因此，请求执行和处理结果之间的执行环境实际上已经丢失了。
如果你想让回调函数连续执行多步操作，那你就必须去解决如何保存和恢复相关的状
态信息了。

至少有两种主要方式来捕获和保存状态信息，你可以在一个对象实例 (通过一个绑
定方法) 或者在一个闭包中保存它。两种方式相比，闭包或许是更加轻量级和自然一
点，因为它们可以很简单的通过函数来构造。它们还能自动捕获所有被使用到的变量。
因此，你无需去担心如何去存储额外的状态信息 (代码中自动判定)。

如果使用闭包，你需要注意对那些可修改变量的操作。在上面的方案中，nonlocal
声明语句用来指示接下来的变量会在回调函数中被修改。如果没有这个声明，代码会
报错。

而使用一个协程来作为一个回调函数就更有趣了，它跟闭包方法密切相关。某种意
义上来讲，它显得更加简洁，因为总共就一个函数而已。并且，你可以很自由的修改
变量而无需去使用 nonlocal 声明。这种方式唯一缺点就是相对于其他 Python 技术而
已或许比较难以理解。另外还有一些比较难懂的部分，比如使用之前需要调用 next()
，实际使用时这个步骤很容易被忘记。

### 内联回调函数
当你编写使用回调函数的代码的时候，担心很多小函数的扩张可能会弄乱程序控制
流。你希望找到某个方法来让代码看上去更像是一个普通的执行序列。
通过使用生成器和协程可以使得回调函数内联在某个函数中。为了演示说明，假
设你有如下所示的一个执行某种计算任务然后调用一个回调函数的函数 
```python
def apply_async(func, *args, callback):
    # Compute the result
    result = func(*args)
    # Invoke the callback with the result
    callback(result)
```

接下来让我们看一下下面的代码，它包含了一个 Async 类和一个 inlined async
装饰器：
```python
from queue import Queue
from functools import wraps

class Async:
    def __init__(self, func, args):
        self.func = func
        self.args = args

def inlined_async(func):
    @wraps(func)
    def wrapper(*args):
        f = func(*args)
        result_queue = Queue()
        result_queue.put(None)
        while True:
            result = result_queue.get()
            try:
                a = f.send(result)
                apply_async(a.func, a.args, callback=result_queue.put)
            except StopIteration:
                break
    return wrapper
```

这两个代码片段允许你使用 yield 语句内联回调步骤。比如：
```python
def add(x, y):
    return x + y

@inlined_async
def test():
    r = yield Async(add, (2, 3))
    print(r)
    r = yield Async(add, ('hello', 'world'))
    print(r)
    for n in range(10):
        r = yield Async(add, (n, n))
        print(r)
    print('Goodbye')
```

如果你调用 test() ，你会得到类似如下的输出：
```
5
helloworld
0
2
4
6
8
10
12
14
16
18
Goodbye
```

你会发现，除了那个特别的装饰器和 yield 语句外，其他地方并没有出现任何的
回调函数 (其实是在后台定义的)。

首先，在需要使用到回调的代码中，关键点在于当前计算工作会挂起并在将来
的某个时候重启 (比如异步执行)。当计算重启时，回调函数被调用来继续处理结果。
apply async() 函数演示了执行回调的实际逻辑，尽管实际情况中它可能会更加复杂
(包括线程、进程、事件处理器等等)。

计算的暂停与重启思路跟生成器函数的执行模型不谋而合。具体来讲，yield 操作
会使一个生成器函数产生一个值并暂停。接下来调用生成器的 next () 或 send() 方
法又会让它从暂停处继续执行。

关键点就是，装饰器会逐步遍历生成器函数的所有 yield 语句，每一次一个。为了这样做，刚
开始的时候创建了一个 result 队列并向里面放入一个 None 值。然后开始一个循环
操作，从队列中取出结果值并发送给生成器，它会持续到下一个 yield 语句，在这里
一个 Async 的实例被接受到。然后循环开始检查函数和参数，并开始进行异步计算
apply async() 。然而，这个计算有个最诡异部分是它并没有使用一个普通的回调函
数，而是用队列的 put() 方法来回调。

主循环立即返回顶部并在队列上执
行 get() 操作。如果数据存在，它一定是 put() 回调存放的结果。如果没有数据，那
么先暂停操作并等待结果的到来。这个具体怎样实现是由 apply async() 函数来决定
的。如果你不相信会有这么神奇的事情，你可以使用 multiprocessing 库来试一下，
在单独的进程中执行异步计算操作，如下所示:
```python
if __name__ == '__main__':
    import multiprocessing
    pool = multiprocessing.Pool()
    apply_async = pool.apply_async
    # Run the test function
    test()
```

将复杂的控制流隐藏到生成器函数背后的例子在标准库和第三方包中都能看到。比
如，在 contextlib 中的 @contextmanager 装饰器使用了一个令人费解的技巧，通过
一个 yield 语句将进入和离开上下文管理器粘合在一起。另外非常流行的 Twisted 包
中也包含了非常类似的内联回调。

### 访问闭包中定义的变量
扩展函数中的某个闭包，允许它能访问和修改函数的内部变量。
闭包的内部变量对于外界来讲是完全隐藏的。但是，你可以通过编写访
问函数并将其作为函数属性绑定到闭包上来实现这个目的.
```python
def sample():
    n = 0
    # Closure function
    def func():
        print('n=', n)

    # Accessor methods for n
    def get_n():
        return n

    def set_n(value):
        nonlocal n
        n = value

    # Attach as function attributes
    func.get_n = get_n
    func.set_n = set_n
    return func


>>> f = sample()
>>> f()
n= 0
>>> f.set_n(10)
>>> f()
n= 10
>>> f.get_n()
10
```

有两点需要解释一下。
首先，nonlocal 声明可以让我们编写函数来修改内部变量的值。
其次，函数属性允许我们用一种很简单的方式将访问方法绑定到闭包函数上，这个跟实例方法很像 


可以进一步的扩展，让闭包模拟类的实例。你要做的仅仅是复制上面的内部函数到一个字典实例中并返回它即可.
```python
import sys
class ClosureInstance:
    def __init__(self, locals=None):
        if locals is None:
            locals = sys._getframe(1).f_locals
        # Update instance dictionary with callables
        self.__dict__.update((key,value) for key, value in locals.items() if callable(value))

    # Redirect special methods
    def __len__(self):
        return self.__dict__['__len__']()

# Example use
def Stack():
    items = []
    def push(item):
        items.append(item)

    def pop():
        return items.pop()

    def __len__():
        return len(items)

    return ClosureInstance()
```

总体上讲，在配置的时候给闭包添加方法会有更多的实用功能，比如你需要重置内部状态、刷新缓冲区、清除缓存或其他的反馈机制的时候。