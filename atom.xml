<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simple &amp; Freedom</title>
  
  <subtitle>Learn and live.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arvin-he.github.io/"/>
  <updated>2017-09-29T07:47:43.927Z</updated>
  <id>http://arvin-he.github.io/</id>
  
  <author>
    <name>Arvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python 缓存机制与 functools.lru_cache</title>
    <link href="http://arvin-he.github.io/2017/09/29/py-cache-2017-09-29/"/>
    <id>http://arvin-he.github.io/2017/09/29/py-cache-2017-09-29/</id>
    <published>2017-09-29T07:37:17.000Z</published>
    <updated>2017-09-29T07:47:43.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存概念"><a href="#缓存概念" class="headerlink" title="缓存概念"></a>缓存概念</h3><p>缓存是一种将定量数据加以保存以备迎合后续请求的处理方式，目的是为了加快数据的检索速度<br>下面看一个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span>:</span></div><div class="line">    <span class="string">""""""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Constructor"""</span></div><div class="line">        self.cache = &#123;&#125;</div><div class="line">        self.max_cache_size = <span class="number">10</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        根据该键是否存在于缓存当中返回True或者False</span></div><div class="line"><span class="string">        """</span></div><div class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.cache</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        更新该缓存字典，您可选择性删除最早条目</span></div><div class="line"><span class="string">        """</span></div><div class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache <span class="keyword">and</span> len(self.cache) &gt;= self.max_cache_size:</div><div class="line">            self.remove_oldest()</div><div class="line">        self.cache[key] = &#123;<span class="string">'date_accessed'</span>: datetime.datetime.now(),</div><div class="line">                           <span class="string">'value'</span>: value&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_oldest</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        删除具备最早访问日期的输入数据</span></div><div class="line"><span class="string">        """</span></div><div class="line">        oldest_entry = <span class="keyword">None</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.cache:</div><div class="line">            <span class="keyword">if</span> oldest_entry == <span class="keyword">None</span>:</div><div class="line">                oldest_entry = key</div><div class="line">            <span class="keyword">elif</span> self.cache[key][<span class="string">'date_accessed'</span>] &lt; self.cache[oldest_entry][<span class="string">'date_accessed'</span>]:</div><div class="line">                oldest_entry = key</div><div class="line"></div><div class="line">        self.cache.pop(oldest_entry)</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        返回缓存容量大小</span></div><div class="line"><span class="string">        """</span></div><div class="line">        <span class="keyword">return</span> len(self.cache)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment">#测试缓存</span></div><div class="line">    keys = [<span class="string">'test'</span>, <span class="string">'red'</span>, <span class="string">'fox'</span>, <span class="string">'fence'</span>, <span class="string">'junk'</span>, \</div><div class="line">            <span class="string">'other'</span>, <span class="string">'alpha'</span>, <span class="string">'bravo'</span>, <span class="string">'cal'</span>, <span class="string">'devo'</span>, <span class="string">'ele'</span>]</div><div class="line">    s = <span class="string">'abcdefghijklmnop'</span></div><div class="line">    cache = MyCache()</div><div class="line">    <span class="keyword">for</span> i, key <span class="keyword">in</span> enumerate(keys):</div><div class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> cache:</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            value = <span class="string">''</span>.join([random.choice(s) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)])</div><div class="line">            cache.update(key, value)</div><div class="line">        print(<span class="string">"#%s iterations, #%s cached entries"</span> % (i+<span class="number">1</span>, cache.size))</div></pre></td></tr></table></figure></p><p>在 Python 的 3.2 版本中，引入了一个非常优雅的缓存机器，即 functool 模块中的 <code>lru_cache</code> 装饰器。如果要在 python2 中使用 <code>lru_cahce</code> 需要安装 <code>functools32</code>。lru_cache 原型如下：<code>@functools.lru_cache(maxsize=None, typed=False)</code><br>使用functools模块的lur_cache装饰器，可以缓存最多 maxsize 个此函数的调用结果，从而提高程序执行的效率，特别适合于耗时的函数。参数maxsize为最多缓存的次数，如果为None，则无限制，设置为2n时，性能最佳；<br>被 <code>lru_cache</code> 装饰的函数会有 <code>cache_clear</code> 和 <code>cache_info</code> 两个方法，分别用于清除缓存和查看缓存信息。<br>这里用一个简单的示例演示 lru_cache 效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</div><div class="line"><span class="meta">@lru_cache(None)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line">    print(<span class="string">"calculating: %s + %s"</span> % (x, y))</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"></div><div class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">print(add(<span class="number">2</span>, <span class="number">3</span>))</div><div class="line"></div><div class="line"><span class="comment">#输出结果：</span></div><div class="line">calculating: <span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">3</span></div><div class="line">calculating: <span class="number">2</span> + <span class="number">3</span></div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure></p><p>从结果可以看出，当第二次调用 add(1, 2) 时，并没有真正执行函数体，而是直接返回缓存的结果。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://blog.konghy.cn/2016/04/20/python-cache/" target="_blank" rel="external">http://blog.konghy.cn/2016/04/20/python-cache/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;缓存概念&quot;&gt;&lt;a href=&quot;#缓存概念&quot; class=&quot;headerlink&quot; title=&quot;缓存概念&quot;&gt;&lt;/a&gt;缓存概念&lt;/h3&gt;&lt;p&gt;缓存是一种将定量数据加以保存以备迎合后续请求的处理方式，目的是为了加快数据的检索速度&lt;br&gt;下面看一个例子:&lt;br&gt;&lt;fig
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>谷歌浏览器常用快捷键</title>
    <link href="http://arvin-he.github.io/2017/09/29/chrome-hotkey-2017-09-29/"/>
    <id>http://arvin-he.github.io/2017/09/29/chrome-hotkey-2017-09-29/</id>
    <published>2017-09-29T06:20:11.000Z</published>
    <updated>2017-09-29T06:33:46.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Chrome窗口和标签页快捷键："><a href="#Chrome窗口和标签页快捷键：" class="headerlink" title="Chrome窗口和标签页快捷键："></a>Chrome窗口和标签页快捷键：</h3><ol><li>Ctrl+N    打开新窗口</li><li>Ctrl+T    打开新标签页</li><li>Ctrl+Shift+N    在隐身模式下打开新窗口</li><li>Ctrl+O，然后选择文件，在谷歌浏览器中打开计算机上的文件</li><li>按住 Ctrl 键，然后点击链接，从后台在新标签页中打开链接，但您仍停留在当前标签页中</li><li>按住 Ctrl+Shift 键，然后点击链接    在新标签页中打开链接，同时切换到新打开的标签页</li><li>按住 Shift 键，然后点击链接    在新窗口中打开链接</li><li>Alt+F4    关闭当前浏览器窗口</li><li>Ctrl+Shift+T 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。</li><li>将链接拖动到标签页内    在指定标签页中打开链接</li><li>将链接拖动到两个标签页之间    在标签页横条的指定位置建立一个新标签页，在该标签页中打开链接</li><li>Ctrl+1 到 Ctrl+8    切换到指定位置编号的标签页。您按下的数字代表标签页横条上的相应标签位置。</li><li>Ctrl+9    切换到最后一个标签页</li><li>Ctrl+Tab 或 Ctrl+PgDown    切换到下一个标签页</li><li>Ctrl+Shift+Tab 或 Ctrl+PgUp    切换到上一个标签页</li><li>Ctrl+W 或 Ctrl+F4    关闭当前标签页或弹出式窗口</li><li>Alt+Home    打开主页</li></ol><h3 id="Chrome地址栏快捷键-："><a href="#Chrome地址栏快捷键-：" class="headerlink" title="Chrome地址栏快捷键 ："></a>Chrome地址栏快捷键 ：</h3><h4 id="在地址栏，进行下列操作之一："><a href="#在地址栏，进行下列操作之一：" class="headerlink" title="在地址栏，进行下列操作之一："></a>在地址栏，进行下列操作之一：</h4><ol><li>键入搜索字词    使用默认搜索引擎进行搜索</li><li>键入网址中”www.”和”.com”之间的部分，然后按Ctrl+Enter 键    为您在地址栏中输入的内容添加”www.”和”.com”，然后打开网址</li><li>键入搜索引擎关键字或网址，按 Tab键，然后键入搜索字词    使用与关键字或网址相关联的搜索引擎进行搜索。如果谷歌浏览器可以识别您要使用的搜索引擎，则会提示您按 Tab 键。</li><li>F6 或 Ctrl+L 或 Alt+D    选中网址区域中的内容</li><li>键入网址，然后按 Alt+Enter 键    在新标签页中打开网址</li><li>打开谷歌chrome浏览器各功能的快捷键</li><li>Ctrl+B    打开和关闭书签栏</li><li>Ctrl+Shift+B    打开书签管理器</li><li>Ctrl+H    查看”历史记录”页</li><li>Ctrl+J    查看”下载”页</li><li>Shift+Escape    查看任务管理器</li><li>Shift+Alt+T    将焦点设置在工具栏上。使用键盘上的向右和向左箭头，可导航至工具栏上的不同按钮。</li></ol><h3 id="Chrome网页快捷键："><a href="#Chrome网页快捷键：" class="headerlink" title="Chrome网页快捷键："></a>Chrome网页快捷键：</h3><ol><li>Ctrl+P    打印当前页</li><li>Ctrl+S    保存当前页</li><li>F5    重新加载当前页</li><li>Esc    停止加载当前页</li><li>Ctrl+F    打开”在网页上查找”框</li><li>点击鼠标中键或滚轮（只在谷歌浏览器测试版（只有英文版）中可用）    激活自动滚动。当您移动鼠标时，网页会根据鼠标的移动方向自动滚动。</li><li>Ctrl+F5 或 Shift+F5    重新加载当前页，但忽略缓存内容</li><li>按住 Alt 键，然后点击链接    下载链接</li><li>Ctrl+G 或 F3    查找与您在”在网页上查找”框中输入的内容相匹配的下一个匹配项</li><li>Ctrl+Shift+G 或 Shift+F3    查找与您在”在网页上查找”框中输入的内容相匹配的上一个匹配项</li><li>Ctrl+U    查看源代码</li><li>将链接拖动到书签栏    将链接加入书签</li><li>Ctrl+D    将当前网页加入书签</li><li>Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮    放大网页上的所有内容</li><li>Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮    缩小网页上的所有内容</li><li>Ctrl+0    将网页上的所有内容都恢复到正常大小</li><li>空格键                             向下滚动网页。</li><li>Home                               转至网页顶部。</li><li>End                                转至网页底部。</li><li>按住 Shift 键的同时滚动鼠标滚轮。  在网页上横向滚动。</li></ol><h3 id="浏览器文本快捷键："><a href="#浏览器文本快捷键：" class="headerlink" title="浏览器文本快捷键："></a>浏览器文本快捷键：</h3><ol><li>Ctrl+C                             将突出显示的内容复制到剪贴板中。</li><li>Ctrl+V 或 Shift+Insert             从剪贴板中粘贴内容。</li><li>Ctrl+Shift+V                       从剪贴板中粘贴内容(不带格式)。</li><li>Ctrl+X 或 Shift+Delete             删除突出显示的内容并将其复制到剪贴板中。</li></ol><h3 id="chrome命令16个非常有用的chrome-命令，操作方法与上述类似。"><a href="#chrome命令16个非常有用的chrome-命令，操作方法与上述类似。" class="headerlink" title="chrome命令16个非常有用的chrome://命令，操作方法与上述类似。"></a>chrome命令16个非常有用的chrome://命令，操作方法与上述类似。</h3><ol><li>chrome://downloads 等同于从菜单中查看下载内容，其快捷键是Ctrl+J</li><li>chrome://extensions 等同于菜单-工具-扩展</li><li>chrome://plugins 显示已安装插件 </li><li>chrome://bookmarks 等同于菜单-书签-书签管理器，快捷键Ctrl+Shift+O</li><li>chrome://history 等同于从菜单-历史直接访问，快捷键 Ctrl+H</li><li>chrome://restart 重启chrome浏览器</li><li>chrome://apps 打开chrome网上应用商店</li><li>chrome://flags 可用来启用或者关闭某些chrome的体验特性</li><li>chrome://dns 显示浏览器预抓取的主机名列表，让你随时了解DNS状态</li><li>chrome://memory 重定向到chrome://memory-redirect/，显示系统运行中的浏览器内存使用情况，以及浏览器中进程的详细信息。</li><li>chrome://net-internals 显示网络相关信息，用来捕获浏览器生成的网络事件，可导出数据，可查看DNS主机解析缓存。</li><li>chrome://quota-internals 用来显示浏览器所使用磁盘空间配额的情况。</li><li>chrome://sessions 该命令用来显示当前运行的浏览器的会话信息数以及详细列表</li><li>chrome://settings 该命令可通过菜单-选项直接访问，可用来控制浏览器各项设置值</li><li>chrome://sync-internals 用来显示 chrome 的同步状态</li><li>chrome://about/ 查看 chrome 所有的命令</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Chrome窗口和标签页快捷键：&quot;&gt;&lt;a href=&quot;#Chrome窗口和标签页快捷键：&quot; class=&quot;headerlink&quot; title=&quot;Chrome窗口和标签页快捷键：&quot;&gt;&lt;/a&gt;Chrome窗口和标签页快捷键：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Ctrl+N  
      
    
    </summary>
    
      <category term="工具" scheme="http://arvin-he.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="谷歌" scheme="http://arvin-he.github.io/tags/%E8%B0%B7%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记</title>
    <link href="http://arvin-he.github.io/2017/09/29/scrapy-notes2-2017-09-29/"/>
    <id>http://arvin-he.github.io/2017/09/29/scrapy-notes2-2017-09-29/</id>
    <published>2017-09-29T05:40:34.000Z</published>
    <updated>2017-09-29T06:57:19.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一些常识"><a href="#一些常识" class="headerlink" title="一些常识"></a>一些常识</h3><ol><li>代理ip会被集体封禁,然后过一段时间再开放</li><li>ip被封禁后,有的会过段时间解除封禁</li><li>代理ip不是全部可靠的,通常有效代理大概在70%左右</li></ol><h3 id="爬虫错误处理方法"><a href="#爬虫错误处理方法" class="headerlink" title="爬虫错误处理方法"></a>爬虫错误处理方法</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一些常识&quot;&gt;&lt;a href=&quot;#一些常识&quot; class=&quot;headerlink&quot; title=&quot;一些常识&quot;&gt;&lt;/a&gt;一些常识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;代理ip会被集体封禁,然后过一段时间再开放&lt;/li&gt;
&lt;li&gt;ip被封禁后,有的会过段时间解除封禁&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="爬虫" scheme="http://arvin-he.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB配置</title>
    <link href="http://arvin-he.github.io/2017/09/27/mongodb-config-2017-09-27/"/>
    <id>http://arvin-he.github.io/2017/09/27/mongodb-config-2017-09-27/</id>
    <published>2017-09-27T11:59:15.000Z</published>
    <updated>2017-09-29T05:39:56.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h3><p>安装就免了吧,安装好mongodb,然后配置环境变量</p><h3 id="创建MongoDB配置文件"><a href="#创建MongoDB配置文件" class="headerlink" title="创建MongoDB配置文件"></a>创建MongoDB配置文件</h3><p>先创建一个配置文件,名称为mongodb.cfg,配置内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#数据文件存放位置</div><div class="line">dbpath=F:/mongodb/data/db</div><div class="line"></div><div class="line">#日志文件存放位置</div><div class="line">logpath=F:/mongodb/data/log/mongodb.log</div><div class="line"></div><div class="line">#PID的路径</div><div class="line">pidfilepath=F:/mongodb/pid/mongodb.pid</div><div class="line"></div><div class="line">#端口号</div><div class="line">port=27017</div><div class="line"></div><div class="line">#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件</div><div class="line">logappend=true</div><div class="line"></div><div class="line">#启用日志文件，默认启用</div><div class="line">journal=true</div><div class="line"></div><div class="line">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</div><div class="line">quiet=true</div><div class="line"></div><div class="line">#打开28017网页端口（若不开启注释掉即可）</div><div class="line">rest=true</div></pre></td></tr></table></figure></p><h3 id="启动mongodb"><a href="#启动mongodb" class="headerlink" title="启动mongodb"></a>启动mongodb</h3><p>在终端执行:<code>mongod --config F:/mongodb/config/mongodb.cfg</code><br>然后在浏览器输入:127.0.0.1:27017,回车会看到网页有”It looks like you are trying to access MongoDB over HTTP on the native driver port.”,则表明启动成功</p><h3 id="注册mongodb服务"><a href="#注册mongodb服务" class="headerlink" title="注册mongodb服务"></a>注册mongodb服务</h3><p>如果每次都按照步骤三那样操作，岂不是很麻烦，按照如下命令来创建并启动MongoDB服务，就可以通过windows服务来管理MongoDB的启动和关闭了.<br>安装mongodb服务,在终端输入: <code>mongod --config F:/mongodb/config/mongodb.cfg --install --serviceName MongoDB</code><br>启动mongodb服务,在终端输入: <code>net start MongoDB</code>, 回车,然后有提示出来:MongoDB服务正在启动, MongoDB服务已经启动成功</p><h3 id="去除mongodb服务"><a href="#去除mongodb服务" class="headerlink" title="去除mongodb服务"></a>去除mongodb服务</h3><p>如果需要去除MongoDB服务，执行如下命令：<br><code>mongod --remove --serviceName MongoDB</code></p><h3 id="如何创建用户管理员"><a href="#如何创建用户管理员" class="headerlink" title="如何创建用户管理员"></a>如何创建用户管理员</h3><p>用户管理员是第一个要创建的用户。在没有创建任何用户之前，你可以随意创建用户；但数据库中一旦有了用户，那么未登录的客户端就没有权限做任何操作了，除非使用db.auth(username, password)方法登录。</p><p>用户管理员的角色名叫 userAdminAnyDatabase，这个角色只能在 admin 数据库中创建。下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; use admin</div><div class="line">switched to db admin</div><div class="line">&gt; db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[&quot;userAdminAnyDatabase&quot;]&#125;)</div><div class="line">Successfully added user: &#123; &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;userAdminAnyDatabase&quot; ] &#125;</div></pre></td></tr></table></figure></p><p>这个例子创建了一个名为 root 的用户管理员。创建完了这个用户之后，我们应该马上以该用户的身份登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; db.auth(&quot;root&quot;,&quot;root123&quot;)</div><div class="line">1</div><div class="line">db.auth() 方法返回 1 表示登录成功。接下来我们为指定的数据库创建访问所需的账号。</div></pre></td></tr></table></figure></p><h3 id="如何创建数据库用户"><a href="#如何创建数据库用户" class="headerlink" title="如何创建数据库用户"></a>如何创建数据库用户</h3><p>首先保证你已经以用户管理员的身份登录 admin 数据库。然后用 use 命令切换到目标数据库，<br>同样用 db.createUser() 命令来创建用户，其中角色名为 “readWrite”。</p><p>普通的数据库用户角色有两种，read 和 readWrite。顾名思义，前者只能读取数据不能修改，后者可以读取和修改。<br>下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; use test</div><div class="line">switched to db test</div><div class="line">&gt; db.createUser(&#123;user:&quot;testuser&quot;,pwd:&quot;testpass&quot;,roles:[&quot;readWrite&quot;]&#125;)</div><div class="line">Successfully added user: &#123; &quot;user&quot; : &quot;testuser&quot;, &quot;roles&quot; : [ &quot;readWrite&quot; ] &#125;</div><div class="line">&gt; db.auth(&quot;testuser&quot;,&quot;testpass&quot;)</div><div class="line">1</div></pre></td></tr></table></figure></p><p>这样 MongoDB 的数据安全性就得到保障了，没有登录的客户端将无法执行任何命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装mongodb&quot;&gt;&lt;a href=&quot;#安装mongodb&quot; class=&quot;headerlink&quot; title=&quot;安装mongodb&quot;&gt;&lt;/a&gt;安装mongodb&lt;/h3&gt;&lt;p&gt;安装就免了吧,安装好mongodb,然后配置环境变量&lt;/p&gt;
&lt;h3 id=&quot;创建M
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="MongoDB" scheme="http://arvin-he.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Python定时器</title>
    <link href="http://arvin-he.github.io/2017/09/20/py-timer-2017-09-20/"/>
    <id>http://arvin-he.github.io/2017/09/20/py-timer-2017-09-20/</id>
    <published>2017-09-20T12:15:37.000Z</published>
    <updated>2017-09-21T00:45:12.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python中定时器"><a href="#python中定时器" class="headerlink" title="python中定时器"></a>python中定时器</h3><p>python中的定时器在threading模块中,而且只执行一次, 那么如何定时循环调用呢?<br>Timer:  隔一定时间调用一个函数,如果想实现每隔一段时间就调用一个函数的话，就要在Timer调用的函数中，再次设置Timer。<br>Timer其实是Thread的一个派生类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">"hello %s\n"</span> % name)</div><div class="line">    <span class="keyword">global</span> timer</div><div class="line">    timer = threading.Timer(<span class="number">2.0</span>, hello, [<span class="string">"world"</span>])</div><div class="line">    timer.start()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    timer = threading.Timer(<span class="number">2.0</span>, hello, [<span class="string">"world"</span>])</div><div class="line">    timer.start()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python中定时器&quot;&gt;&lt;a href=&quot;#python中定时器&quot; class=&quot;headerlink&quot; title=&quot;python中定时器&quot;&gt;&lt;/a&gt;python中定时器&lt;/h3&gt;&lt;p&gt;python中的定时器在threading模块中,而且只执行一次, 那么如何
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux一些常用命令</title>
    <link href="http://arvin-he.github.io/2017/09/19/linux-cmds-2017-09-19/"/>
    <id>http://arvin-he.github.io/2017/09/19/linux-cmds-2017-09-19/</id>
    <published>2017-09-19T13:46:02.000Z</published>
    <updated>2017-09-29T06:46:08.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h2><p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件或文件夹.scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p><p>命令格式：<br>scp [参数] [原路径] [目标路径]</p><h3 id="从本地服务器复制到远程服务器："><a href="#从本地服务器复制到远程服务器：" class="headerlink" title="从本地服务器复制到远程服务器："></a>从本地服务器复制到远程服务器：</h3><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">scp local_file remote_username@remote_ip:remote_folder  </div><div class="line">或者  </div><div class="line">scp local_file remote_username@remote_ip:remote_file  </div><div class="line">或者  </div><div class="line">scp local_file remote_ip:remote_folder  </div><div class="line">或者  </div><div class="line">scp local_file remote_ip:remote_file</div></pre></td></tr></table></figure></p><p>第1,2个指定了用户名，命令执行后需要输入用户密码，<br>第1个仅指定了远程的目录，文件名字不变，<br>第2个指定了文件名<br>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，<br>第3个仅指定了远程的目录，文件名字不变，<br>第4个指定了文件名 </p><h3 id="从本地拷贝文件夹到远程服务器："><a href="#从本地拷贝文件夹到远程服务器：" class="headerlink" title="从本地拷贝文件夹到远程服务器："></a>从本地拷贝文件夹到远程服务器：</h3><p>命令格式：<br><code>scp -r local_folder remote_username@remote_ip:remote_folder</code><br>或者<br><code>scp -r local_folder remote_ip:remote_folder</code><br>第1个指定了用户名，命令执行后需要输入用户密码；<br>第2个没有指定用户名，命令执行后需要输入用户名和密码；</p><h3 id="从远程服务器复制到本地服务器："><a href="#从远程服务器复制到本地服务器：" class="headerlink" title="从远程服务器复制到本地服务器："></a>从远程服务器复制到本地服务器：</h3><p>从远程复制到本地的scp命令与上面的命令相似，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。</p><p><code>scp arvin@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/</code></p><h3 id="screen命令"><a href="#screen命令" class="headerlink" title="screen命令"></a>screen命令</h3><p> 当使用SSH 或者 telent 远程登录到 Linux 服务器,经常有一些长时间运行的任务，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，但是他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉终端窗口或者断开连接，也不能关机, 否则这个任务就会被杀掉，一切半途而废了。显然,这不是我们所希望的.</p><p>screen命令可以远程运行服务器程序并观察程序执行,即使关闭终端或者关闭电脑也不要紧,服务器上的程序也一直在运行.<br>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> 创建一个screen会话窗口</span></div><div class="line">screen -S test</div><div class="line"><span class="meta">#</span><span class="bash"> 执行程序</span></div><div class="line">python3 test.py</div><div class="line"><span class="meta">#</span><span class="bash"> 查看正在运行的程序,会显示程序执行的pid</span></div><div class="line">screen -ls</div><div class="line"><span class="meta">#</span><span class="bash"> 查看某个程序在终端的输出, 6245是执行成的pid</span></div><div class="line">screen -r -D 6245</div></pre></td></tr></table></figure></p><p><strong>注意:</strong> 如果程序在运行时,不要按下CTRL+C, 这样会中止程序的运行,直接关闭终端窗口就可以了,这样不会关闭程序的运行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">其他常用的命令选项有：</div><div class="line">-c file使用配置文件file，而不使用默认的$HOME/.screenrc</div><div class="line">-d|-D [pid.tty.host]不开启新的screen会话，而是断开其他正在运行的screen会话</div><div class="line">-h num指定历史回滚缓冲区大小为num行</div><div class="line">-list|-ls列出现有screen会话，格式为pid.tty.host</div><div class="line">-d -m启动一个开始就处于断开模式的会话</div><div class="line">-r sessionowner/ [pid.tty.host]重新连接一个断开的会话。多用户模式下连接到其他用户screen会话需要指定sessionowner，需要setuid-root权限</div><div class="line">-S sessionname创建screen会话时为会话指定一个名字</div><div class="line">-v显示screen版本信息</div><div class="line">-wipe [match]同-list，但删掉那些无法连接的会话</div></pre></td></tr></table></figure><p>下例显示当前有两个处于detached状态的screen会话，你可以使用<code>screen -r &lt;screen_pid&gt;</code>重新连接上.<br>如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态。使用screen -wipe命令清除该会话.</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill[参数][进程号]</p><p>init进程是不可杀的,<br>init是Linux系统操作中不可缺少的程序之一。所谓的init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。所以,init始终是第一个进程（其进程编号始终为1）。 其它所有进程都是init进程的子孙。init进程是不可杀的！</p><p>常用的信号：只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HUP    1    终端断线</div><div class="line">INT     2    中断（同 Ctrl + C）</div><div class="line">QUIT    3    退出（同 Ctrl + \）</div><div class="line">TERM   15    终止</div><div class="line">KILL    9    强制终止</div><div class="line">CONT   18    继续（与STOP相反， fg/bg命令）</div><div class="line">STOP    19    暂停（同 Ctrl + Z）</div></pre></td></tr></table></figure></p><p>彻底杀死进程:<br>命令：<code>kill –9 3268</code></p><p>应注意:</p><ol><li><p>信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。</p></li><li><p>要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scp命令&quot;&gt;&lt;a href=&quot;#scp命令&quot; class=&quot;headerlink&quot; title=&quot;scp命令&quot;&gt;&lt;/a&gt;scp命令&lt;/h2&gt;&lt;p&gt;scp是secure copy的简写，用于在Linux下进行远程拷贝文件或文件夹.scp传输是加密的。可能会稍微影响
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http://arvin-he.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>python之beautifulsoup使用</title>
    <link href="http://arvin-he.github.io/2017/09/18/py-bs4-2017-09-18/"/>
    <id>http://arvin-he.github.io/2017/09/18/py-bs4-2017-09-18/</id>
    <published>2017-09-18T13:20:12.000Z</published>
    <updated>2017-09-20T00:54:45.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="find-find-all"><a href="#find-find-all" class="headerlink" title="find()/find_all()"></a>find()/find_all()</h3><p>find() 返回文档中符合条件的tag，如果没找到符合条件的tag返回Node<br>find_all()返回文档中全部符合条件的tag的列表，如果不存在返回空列表<br>注意find()函数返回的是符合条件的tag，因此可以进行链式调用，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#先查找class属性为‘post-content’的div标签，然后查找该div标签下的所有的img标签</span></div><div class="line">soup.find(<span class="string">'div'</span>, class_=<span class="string">'post-content'</span>).find_all(<span class="string">'img'</span>)</div></pre></td></tr></table></figure></p><p>而<code>find_all()</code>返回的是列表，列表是不存在find()和find_all()函数的，因此不能进行链式调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;find-find-all&quot;&gt;&lt;a href=&quot;#find-find-all&quot; class=&quot;headerlink&quot; title=&quot;find()/find_all()&quot;&gt;&lt;/a&gt;find()/find_all()&lt;/h3&gt;&lt;p&gt;find() 返回文档中符合条件的t
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>mongodb笔记(三)</title>
    <link href="http://arvin-he.github.io/2017/09/18/mongodb-note3-2017-09-18/"/>
    <id>http://arvin-he.github.io/2017/09/18/mongodb-note3-2017-09-18/</id>
    <published>2017-09-18T13:05:16.000Z</published>
    <updated>2017-09-20T02:20:22.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mongodb突然无法打开"><a href="#mongodb突然无法打开" class="headerlink" title="mongodb突然无法打开"></a>mongodb突然无法打开</h3><p>检查mongodb数据所在的文件夹下是否有一个类似”locked file”,删掉这个文件,然后再开启mongodb</p><h3 id="再说插入操作"><a href="#再说插入操作" class="headerlink" title="再说插入操作"></a>再说插入操作</h3><p>单条插入<br>批量插入</p><h3 id="find操作"><a href="#find操作" class="headerlink" title="find操作"></a>find操作</h3><p>查询是用的最多的操作了, 常用的有2类:</p><ol><li><blockquote><p>, &gt;=, &lt;, &lt;=, !=, =</p></blockquote></li><li>And，OR，In，NotIn</li></ol><p>这些操作在mongodb里面都有对应封装.</p><ol><li>“$gt”, “$gte”, “$lt”, “$lte”, “$ne”, “”<br>这些与上面 &gt;, &gt;=, &lt;, &lt;=, !=, = 这6个符号操作一一对应</li><li>“”, “$or”, “$in”，”$nin”<br>与 And，OR，In，NotIn 操作一一对应</li></ol><p>正则表达式匹配<br>在mongodb中还有一个特殊的匹配，那就是支持正则表达式.</p><p>$where操作</p><h3 id="update操作"><a href="#update操作" class="headerlink" title="update操作"></a>update操作</h3><p>整体更新<br>局部更新</p><p>局部更新:<br>mongodb中已经给我们提供了两个修改器： $inc 和 $set。</p><p>$inc修改器<br>$inc也就是increase的缩写，自增$inc指定的值，如果“文档”中没有此key，则会创建key。</p><p>$set修改器</p><h3 id="upsert操作"><a href="#upsert操作" class="headerlink" title="upsert操作"></a>upsert操作</h3><p>upsert操作就是说：如果我没有查到，我就在数据库里面新增一条，其实这样也有好处，就是避免了我在数据库里面判断是update还是add操作，使用起来很简单将update的第三个参数设为true即可。</p><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>在mongodb中如果匹配多条，默认的情况下只更新第一条，那么如果我们有需求必须批量更新，那么在mongodb中实现也是很简单的，在update的第四个参数中设为true即可.</p><h3 id="查询某一字段重复的记录"><a href="#查询某一字段重复的记录" class="headerlink" title="查询某一字段重复的记录"></a>查询某一字段重复的记录</h3><h3 id="查询某一字段重复的记录的数目"><a href="#查询某一字段重复的记录的数目" class="headerlink" title="查询某一字段重复的记录的数目"></a>查询某一字段重复的记录的数目</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mongodb突然无法打开&quot;&gt;&lt;a href=&quot;#mongodb突然无法打开&quot; class=&quot;headerlink&quot; title=&quot;mongodb突然无法打开&quot;&gt;&lt;/a&gt;mongodb突然无法打开&lt;/h3&gt;&lt;p&gt;检查mongodb数据所在的文件夹下是否有一个类似”
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="MongoDB" scheme="http://arvin-he.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记</title>
    <link href="http://arvin-he.github.io/2017/09/18/py-note1-2017-09-18/"/>
    <id>http://arvin-he.github.io/2017/09/18/py-note1-2017-09-18/</id>
    <published>2017-09-18T12:57:31.000Z</published>
    <updated>2017-09-21T00:48:34.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python路径操作"><a href="#python路径操作" class="headerlink" title="python路径操作"></a>python路径操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment">#创建目录</span></div><div class="line">os.mkdir(<span class="string">"D:\\python\\2"</span>)</div><div class="line"><span class="comment">#删除目录</span></div><div class="line">os.rmdir(<span class="string">"D:\\python\\2"</span>)</div><div class="line"></div><div class="line"><span class="comment">#创建多级目录</span></div><div class="line">os.makedirs(<span class="string">"D:\\python\\oo\\2\\3"</span>)</div><div class="line"><span class="comment">#删除多级目录</span></div><div class="line">os.removedirs(<span class="string">"D:\\python\\oo\\2\\3"</span>)</div><div class="line"></div><div class="line"><span class="comment">#获取目录下文件夹及文件</span></div><div class="line">paths=os.listdir(<span class="string">"D:\\python"</span>)</div><div class="line"><span class="keyword">for</span> path <span class="keyword">in</span> paths:</div><div class="line">    print(path)</div><div class="line"></div><div class="line"><span class="comment">#获取当前目录位置</span></div><div class="line">path1=os.getcwd()</div><div class="line">print(path1)</div><div class="line"></div><div class="line"><span class="comment">#切换目录</span></div><div class="line">os.chdir(<span class="string">"D:\\python\\oo\\3"</span>)</div><div class="line">path2=os.getcwd()</div><div class="line">print(path2)</div><div class="line"></div><div class="line"><span class="comment">#遍历所有子目录及文件</span></div><div class="line"><span class="keyword">for</span> p1,d,filelist <span class="keyword">in</span> os.walk(<span class="string">'D:'</span>+os.sep+<span class="string">'python'</span>):</div><div class="line">    <span class="keyword">for</span> f1 <span class="keyword">in</span> filelist:</div><div class="line">        fp=os.path.join(p1,f1)</div><div class="line">        print(fp)</div></pre></td></tr></table></figure><h3 id="python文件压缩操作"><a href="#python文件压缩操作" class="headerlink" title="python文件压缩操作"></a>python文件压缩操作</h3><h3 id="python数据库连接操作"><a href="#python数据库连接操作" class="headerlink" title="python数据库连接操作"></a>python数据库连接操作</h3><h3 id="python字符串操作"><a href="#python字符串操作" class="headerlink" title="python字符串操作"></a>python字符串操作</h3><h3 id="python异常处理"><a href="#python异常处理" class="headerlink" title="python异常处理"></a>python异常处理</h3><h3 id="python日志操作"><a href="#python日志操作" class="headerlink" title="python日志操作"></a>python日志操作</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python路径操作&quot;&gt;&lt;a href=&quot;#python路径操作&quot; class=&quot;headerlink&quot; title=&quot;python路径操作&quot;&gt;&lt;/a&gt;python路径操作&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>mongodb笔记(二)</title>
    <link href="http://arvin-he.github.io/2017/09/13/mongodb-note2-2017-09-13/"/>
    <id>http://arvin-he.github.io/2017/09/13/mongodb-note2-2017-09-13/</id>
    <published>2017-09-13T13:15:25.000Z</published>
    <updated>2017-09-20T00:54:45.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>mongoDB三要素: 数据库，集合，文档，其中“集合”就是对应关系数据库中的“表”，“文档”对应“行”。</li><li>mongoDB发布版本: 32bit和64bit<ul><li>根据业界规则，偶数为“稳定版”(如：1.6.X，1.8.X)，奇数为“开发版”(如：1.7.X，1.9.X)</li><li>32bit的mongodb最大只能存放2G的数据，64bit就没有限制</li></ul></li></ol><h3 id="mongoDB安装与启动"><a href="#mongoDB安装与启动" class="headerlink" title="mongoDB安装与启动"></a>mongoDB安装与启动</h3><ol><li>安装: 安装就不多说了,注意安装完将mongodb安装目录下的bin目录(C:\Program Files\MongoDB\Server\3.4\bin)放到环境变量中去,默认是没有放到环境变量中.这样有一些很好用的工具和命令可以在终端使用.</li><li>启动: 启动之前必须给monggodb指定一个文件夹,这里取名为”mongodata”,路径位:C:\mongodata,用来存放mongodb的数据。如果你将mongodb安装在C:/program File目录下,那么这个mongodata文件夹不要放在C:/program File目录下.因为这需要管理员权限才能添加和删除文件夹.</li><li>在终端指定数据存放地点:<br>mongod –dbpath=C:/mongodata</li><li>查看是否成功:<br>最后要看下是否开启成功，从图中的信息中获知，mongodb采用27017端口，那么我们就在浏览器里面键入“<a href="http://localhost:27017/”，" target="_blank" rel="external">http://localhost:27017/”，</a><br>打开后，mongodb告诉我们在27017上Add 1000可以用http模式查看mongodb的管理信息(貌似在新版本3.4.9没有成功)。</li></ol><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在终端指定数据存放点后,mongod –dbpath=C:/mongodata,不要关闭该终端,再开一个终端，输入mongo命令打开shell，其实这个shell就是mongodb的客户端，同时也是一个js的编译器，默认连接的是“test”数据库。</p><ol><li>insert操作</li></ol><p><img src="/2017/09/13/mongodb-note2-2017-09-13/1.png" alt=""></p><ol><li>find 操作</li></ol><p>这里要注意两点：<br>“_id”： 这个字段是数据库默认给我们加的GUID，目的就是保证数据的唯一性。<br>严格的按照Bson的形式书写文档，不过也没关系，错误提示还是很强大的。</p><p><img src="/2017/09/13/mongodb-note2-2017-09-13/2.png" alt=""></p><ol><li>update操作</li></ol><p>update方法的第一个参数为“查找的条件”，第二个参数为“更新的值”。</p><p><img src="/2017/09/13/mongodb-note2-2017-09-13/3.png" alt=""></p><ol><li>remove操作</li></ol><p>删除指定数据</p><p><img src="/2017/09/13/mongodb-note2-2017-09-13/4.png" alt=""></p><p>删除所有数据</p><p><img src="/2017/09/13/mongodb-note2-2017-09-13/5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;mongoDB三要素: 数据库，集合，文档，其中“集合”就是对应关系数据库中的“表”，“文档”对应“行”。&lt;/l
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mongoDB" scheme="http://arvin-he.github.io/tags/mongoDB/"/>
    
  </entry>
  
  <entry>
    <title>mongoDB笔记</title>
    <link href="http://arvin-he.github.io/2017/09/12/mongodb-note1-2017-09-12/"/>
    <id>http://arvin-he.github.io/2017/09/12/mongodb-note1-2017-09-12/</id>
    <published>2017-09-12T01:36:54.000Z</published>
    <updated>2017-09-20T00:54:45.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见的关系型数据库"><a href="#常见的关系型数据库" class="headerlink" title="常见的关系型数据库"></a>常见的关系型数据库</h2><p>关系数据库管理系统(Relational DataBase Management System，RDBMS)<br>MySQL、PostgreSQL、SQLite、Oracle、MS SQLServer </p><h3 id="mongoDB简介"><a href="#mongoDB简介" class="headerlink" title="mongoDB简介"></a>mongoDB简介</h3><p>MongoDB(源自单词 humongous)是一种较新的数据库，它没有表、模式、SQL 或行的概念。<br>它没有事务、ACID 兼容性、连接、外键或其他许多容易在凌晨引起问题的特性。</p><p>记住：MongoDB 不会尝试为所有人完成所有事情。但对于许多目的(例如构建 Web 应用)，<br>MongoDB 是一个能够实现解决方案的完美工具。</p><p>MongoDB 以C++编写，因此迁移相对容易，并且可以在任何位置运行该应用。MongoDB 提供了一个功能丰富的面向文档数据库，并且对运行速度和扩展性做了优化。它也几乎可运行在任何目标上。MongoDB的网站上包含了可运行在 Linux、Mac OS、Windows 和 Solaris 中的安装文件。</p><p><strong>警告：</strong><br>32 位版本的 MongoDB 数据库大小被限制为小于等于 2GB，因为 MongoDB 内部使用内存<br>映射文件来实现高性能。在 32 位系统中任何大于 2GB 的文件都需要一些特殊的处理，这样会<br>降低处理速度，也会使应用代码变得复杂。官方关于该限制的观点是：64 位环境很容易获得；<br>因此，增加代码的复杂性并不是很好的权衡之计。64 位版本的 MongoDB 可以实现所有的意图<br>和目的，并且不含任何限制。</p><h3 id="关于BSON"><a href="#关于BSON" class="headerlink" title="关于BSON"></a>关于BSON</h3><p>MongoDB 并未使用 JSON 存储数据，而使用由 MongoDB 团队开发的一种称为<br>BSON(二进制 JSON 的英文简称)的开放数据格式。大多数情况下，使用 BSON 取代 JSON 并不<br>会改变处理数据的方式。BSON 通过使计算机更容易处理和搜索文档的方式，使 MongoDB 处<br>理速度变得更快。BSON 还添加了一些标准 JSON 不支持的特性，包括数字数据(例如 int32 和<br>int64)的许多扩展类型，以及支持处理二进制数据。</p><p>BSON 是一个开放标准，在网址 <a href="http://bsonspec.org/上可以找到它的规范。当人们听到" target="_blank" rel="external">http://bsonspec.org/上可以找到它的规范。当人们听到</a> BSON<br>是 JSON 的二进制形式时，他们期望 BSON 占用的空间要比 JSON 少得多。不过，事实并不一<br>定是这样的；许多情况下，BSON 版本与相同的 JSON 相比要占用更多的空间。</p><p>首先，要记住 MongoDB 的设计目标是快速，而不是节省空间。虽然这并不意味着 MongoDB<br>会浪费空间(它不会)；不过，如果处理数据的速度更快(它确实是这样的)，那么存储文档时的一<br>点开销是完全可以接受的。简单地说，BSON 更易于遍历(即浏览)，遍历索引页非常快。</p><p>BSON 支持在一个文档中存储最多 16MB 的二进制数据，</p><h3 id="关于唯一键"><a href="#关于唯一键" class="headerlink" title="关于唯一键"></a>关于唯一键</h3><p>MongoDB 要求每个文档必须有唯一标识符；在 MongoDB 中，该标识符<br>被称为_id。除非为该字段指定某个值，否则 MongoDB 将自动创建唯一值。即使是在已经成熟<br>的 RDBMS 数据库世界中，也存在着是应该自己提供唯一键还是由数据库提供的分歧。最近，<br>由数据库创建唯一键的方式已经变得更加流行。MongoDB 是一个分布式数据库，所以其主要<br>目标之一是消除对共享资源的依赖(例如检查主键是否独一无二)。非分布式的数据库通常使用<br>一个简单的主键，例如自动递增的序列号。MongoDB 的默认_id 格式是一个 ObjectId，它是一<br>个 12 字节的唯一标识符，可以独立地在分布式环境中生成。<br>之前，使用 MongoDB 的大多数开发者似乎更喜欢创建自己的唯一键，由自己来维护键的<br>唯一性。然而，现在人们更愿意使用 MongoDB 创建的默认 ID 值。不过，在使用 RDBMS 数据<br>库时，选择哪种方式更多地取决于个人偏好。我们更愿意使用数据库提供的值，因为这意味着<br>我们可以保证键是唯一的，并且是独立的。<br>最终，你必须决定哪种方式更适合自己。如果有信心保证自己的键一定是唯一的(并且可能<br>不会改变)，那么就可以使用。如果不确定键的唯一性或者不希望担心这件事情，最好还是使用<br>MongoDB 提供的默认键。</p><h3 id="关于集合"><a href="#关于集合" class="headerlink" title="关于集合"></a>关于集合</h3><p>集合有点类似于表，但它们不那么死板。集合非常像一个贴有标签的盒子。<br>最后但并非最不重要的是，集合可以按需求即时创建。尤其是，在第一次尝试保存文档时，<br>MongoDB 将创建引用它的集合。这意味着可以按照需求即时创建集合(但并不是应该这么做)。<br>因为 MongoDB 也允许动态地创建索引，执行其他数据库级别的命令，所以可以利用该特性构<br>建出一些非常动态的应用。</p><p>理解 MongoDB 中数据库的最简单方式就是将它看成一个集合的集合</p><h3 id="存储二进制数据"><a href="#存储二进制数据" class="headerlink" title="存储二进制数据"></a>存储二进制数据</h3><p>GridFS 是 MongoDB 在数据库中存储二进制数据的解决方案。<br>GridFS 通过在 files 集合中存储文件的信息(称为元数据)来实现。数据本身被分成多块(称为<br>信息块)存储在 chunks 集合中。这种方式使数据存储既简单又有扩展性；还使范围操作(例如获<br>取文件的特定部分)变得更简单。</p><h3 id="实施分片"><a href="#实施分片" class="headerlink" title="实施分片"></a>实施分片</h3><p>对于涉及大规模部署的应用，自动分片可能是 MongoDB 最重要和最常用的特性。<br>在自动分片场景中，MongoDB 将处理所有数据的分割和重组。它将保证数据进入正确的<br>服务器，并以最高效的方式运行查询和重组结果。事实上，从开发者的角度看，使用含有数百<br>个分片的 MongoDB 数据库和使用单个 MongoDB 数据库并没有区别。</p><h3 id="使用-map-和-reduce-函数"><a href="#使用-map-和-reduce-函数" class="headerlink" title="使用 map 和 reduce 函数"></a>使用 map 和 reduce 函数</h3><p>MongoDB 并不要求使用 map 和 reduce 函数。事实上，MongoDB 只依赖于简单的查询语法，<br>这种语法与 MySQL 中使用的类似。不过，对于希望使用该功能的人，MongoDB 也提供了对这<br>些函数的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见的关系型数据库&quot;&gt;&lt;a href=&quot;#常见的关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;常见的关系型数据库&quot;&gt;&lt;/a&gt;常见的关系型数据库&lt;/h2&gt;&lt;p&gt;关系数据库管理系统(Relational DataBase Management S
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mongoDB" scheme="http://arvin-he.github.io/tags/mongoDB/"/>
    
  </entry>
  
  <entry>
    <title>怎样避免陷入无止境地看教程的陷阱</title>
    <link href="http://arvin-he.github.io/2017/09/08/learn-minds-2017-06-19/"/>
    <id>http://arvin-he.github.io/2017/09/08/learn-minds-2017-06-19/</id>
    <published>2017-09-08T03:51:39.704Z</published>
    <updated>2017-09-08T03:51:39.707Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/09/08/learn-minds-2017-06-19/1.jpeg" alt=""></p><p>我们可能都曾遇到过这样的情况：学习编程的时候，一个教程接着一个教程地学，但是不清楚自己学到什么了程度。然后你开始自我怀疑：“这太难了。”或“也许编程不适合我。”我知道你懂这种感受。</p><p>我自己在最近就切身体会到了这种感觉。我本身算是个比较自信的PHP攻城狮，打算学习Python—尤其是Django。</p><p>我搜索了一些相关资料并找到了看似完美的教程，足够复杂富有挑战，又足够简单不至于击垮我的兴趣。</p><p>作为一个基于项目实战的教程，我对完成后的项目相当喜欢。我认为将它添加到我的成长作品集会是很酷的一件事。</p><p>跟着教程做到接近80%的时候，我突然产生了一股自我怀疑。我已经看了视频教程并一个个字敲了所有的代码，我已经有了一个简单的项目可以展示给他人，可为什么我感觉反倒没有刚开始那样好？</p><p><img src="/2017/09/08/learn-minds-2017-06-19/2.jpg" alt=""></p><p>跟着这个教程又花了几个星期的晚上，我有了一个漂亮的完工项目。即便如此，我还是觉得在没有指南的情况下我是不具备重新实现这个项目的技能的。所以，将它放到我的作品集里真的好吗？</p><p>将一个在外观和功能上与别人的一模一样的项目展示出来真的说服力吗？而且代码和GitHub教程上的一模一样。</p><p>如你所见，跟着教程学习，接触到新的技能，是很棒的。但是只跟着教程学习，你无法掌握作为一名合格的初级工程师所需的更多技能，我指的是：</p><ul><li>设计和组织项目</li><li>了解哪些工具对于一个具体项目是最佳选择</li><li>尝试通过搜索来解决遇到的一些问题</li><li>解决在实际项目开发中无可避免的一些问题</li></ul><h2 id="教程是快速上手的好办法"><a href="#教程是快速上手的好办法" class="headerlink" title="教程是快速上手的好办法"></a>教程是快速上手的好办法</h2><hr><p>为了避免大家误解，交代一下相关背景，我是一个29岁的初级码农，目前在一家软件开发公司工作。我在一年前转行进入编程行业，</p><p>很多新手码农一样，在开始学习高级教程之前我先完成基础的教程。我主要是学习PHP（因为在我开始学习编程的时候听说PHP是全世界最好的语言），我很快就熟悉了语法和一些基本用法。</p><p>大概花了9个月的时间，我完成了足够多的教程，有了足够的理解，也有了足够的动力去说服一家软件开发公司给我提供一份工作。（你可以通过这篇文章了解到我是如何说服老板给我工作机会的 take a chance on me and pay me to learn to code.）</p><p>让我能在如此短的时间内得到一份编程工作，得益于我创建的可以展示的实际项目。值得注意的是，是<strong>我自己</strong>的项目，而不是跟着教程复制粘贴的那种。</p><h2 id="教程也只能帮你到这里了-之后你需要开发实际项目"><a href="#教程也只能帮你到这里了-之后你需要开发实际项目" class="headerlink" title="教程也只能帮你到这里了 之后你需要开发实际项目"></a>教程也只能帮你到这里了 之后你需要开发实际项目</h2><hr><p><img src="/2017/09/08/learn-minds-2017-06-19/3.jpeg" alt=""></p><p>不要理解错了我的意思–教程是很棒的，尤其是在新手学习基础的情况下。当然，教程的质量是良莠不齐的，解释的详细程度也大相径庭。但是一个教程接着一个教程的学习是无法让你成为一个专业的开发者的。</p><p>你必须开发自己的项目。一旦你对你选择的语言的语法和基本的实现有了一定的认识，你就可以开始开发属于自己的东西了，不再是“手把手”式的学习。</p><p>当我向别人说这些的时候，通常得到的回应是：“开发什么呢？我一点想法都没有。”</p><p>额，实际上没人指望你创造出什么牛逼的东西来，而且你应该不具备这样的技能去做这样的事情，就算你有想法。</p><p>这里有一份清单，列出了你可以开发的500个项目，有例子: <a href="http://rosettacode.org/wiki/Category:Programming_Tasks" target="_blank" rel="external">http://rosettacode.org/wiki/Category:Programming_Tasks</a> 。</p><p>你也可以开发类似博客这样的项目。是的，有无数个教程都是基于构建博客的。你可能还会复制、粘贴一些代码，这也许不是一个令人印象深刻的项目，但是。。。</p><p>开发属于<strong>你自己的博客</strong>。坐下来，在开始之前，制定好每一步的计划和特色功能。搜索并选择一门你想用的语言和框架。了解怎么安装需要的工具，构建开发环境，通过包管理工具安装所需的依赖等。当你卡在某个环节时，Google或者通过可靠的技术社区去解决你遇到的一些问题。</p><p>通过这样的方式你的学习效率可能比跟着任何一个教程学习都快很多,你自己开发的项目的在你作品中的价值也远远大于其他几十个跟着教程做的项目的总和。</p><p>取决于你选择的项目的复杂程度，在你找工作的时候你的个人作品集里可能就不再需要其他的东西了，只是可能。你的代码可能不是非常出色，但这是你自己写的代码。你可以解释每一行代码的意义，你可以解释你是如何实现的和为什么这样做。</p><p>同时，你也证明了你可以管理一个项目，单独完成，学习需要的新技能，并递交最终完成的产品。对于潜在的雇主而言，你现在拥有了几项有价值的技能。</p><p>如果花12到18月的时间去学习，还没有找到一份工作，或者说你总感觉实际尚未成熟，<strong>别灰心，不要放弃</strong>。不要开始有这样的想法：你需要花动辄上万的学费去参加什么牛逼的培训班。只需要开始开发你自己的东西你就会惊讶于你进步的速度！</p><blockquote><p>通过freeCodeCamp找到工作的人数在不断增长可能也是因为它基于项目的学习方式。freeCodeCamp是一个不错的学习平台，不过本文就不替原作者多做宣传了。本文翻译自 <a href="https://medium.freecodecamp.com/how-to-dig-yourself-out-of-the-coding-tutorial-rut-7d3b2232f234" target="_blank" rel="external">https://medium.freecodecamp.com/how-to-dig-yourself-out-of-the-coding-tutorial-rut-7d3b2232f234</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2017/09/08/learn-minds-2017-06-19/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可能都曾遇到过这样的情况：学习编程的时候，一个教程接着一个教程地学，但是不清楚自己学到什么了程度。然后你开始自我怀疑：“这太难了。”或
      
    
    </summary>
    
      <category term="life" scheme="http://arvin-he.github.io/categories/life/"/>
    
    
      <category term="思想" scheme="http://arvin-he.github.io/tags/%E6%80%9D%E6%83%B3/"/>
    
      <category term="方法" scheme="http://arvin-he.github.io/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python程序打包问题</title>
    <link href="http://arvin-he.github.io/2017/09/01/py-packproblems-2017-09-01/"/>
    <id>http://arvin-he.github.io/2017/09/01/py-packproblems-2017-09-01/</id>
    <published>2017-09-01T06:33:39.000Z</published>
    <updated>2017-09-08T03:51:39.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ImportError-DLL-load-failed-The-specified-module-could-not-be-found"><a href="#ImportError-DLL-load-failed-The-specified-module-could-not-be-found" class="headerlink" title="ImportError: DLL load failed: The specified module could not be found."></a>ImportError: DLL load failed: The specified module could not be found.</h3><p>win7-64bit或win10-64bit打包python32位程序在win7-32bit系统上运行报错:ImportError: DLL load failed: The specified module could not be found.</p><p>Finally,I find the solution:<br>Install <a href="https://www.microsoft.com/de-at/download/details.aspx?id=48145" target="_blank" rel="external">Microsoft Visual C++ 2015 Redistributable Update 3 x86</a>.</p><p>注意:</p><ol><li>选择X86版本</li><li>vc_redist.x86.exe 一定要选择update 3版本,之前的版本还是会报错.</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/tensorflow/tensorflow/issues/7995" target="_blank" rel="external">stackoverflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ImportError-DLL-load-failed-The-specified-module-could-not-be-found&quot;&gt;&lt;a href=&quot;#ImportError-DLL-load-failed-The-specified-module-coul
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python中关于在GUI应用程序读取stdin内容</title>
    <link href="http://arvin-he.github.io/2017/08/30/py-stdin-2017-08-30/"/>
    <id>http://arvin-he.github.io/2017/08/30/py-stdin-2017-08-30/</id>
    <published>2017-08-30T02:11:08.000Z</published>
    <updated>2017-09-08T03:51:39.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>键盘输入的字符串是保存在stdin中的,我在程序中如何将stdin中数据拿到并赋给一个变量? 之前我是通过sys.stdin.readline()来读取stdin中的数据的,但是导致界面卡死,我想问一下你有什么办法?我google一下,没有找到我想要的</p><p>data = input()<br>用 sys.stdin.readline 或 input, 都只能读取整行数据. 如果没有按回车键, 调用是阻塞不返回的.</p><p>这就是为什么程序界面被卡死的原因.</p><p>Qt 里还有个键盘事件的钩子. 需要在终端键盘输入时, 可能需要配置一下.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">QtCore.pyqtRemoveInputHook()</div><div class="line">code.InteractiveConsole(_locals).interact()</div><div class="line">QtCore.pyqtRestoreInputHook()</div></pre></td></tr></table></figure></p><p>当QtCore模块第一次导入时，它会安装一个Python输入钩子（即它设置Python的PyOS_InputHook变量的值）。这允许在应用程序运行时在解释器提示符处输入命令。然后可以动态创建新的Qt对象并调用任何现有的Qt对象的方法。输入钩子可能会导致某些类型的应用程序出现问题，特别是那些通过不同手段提供类似设备的应用程序。此功能删除PyQt安装的输入钩。</p><p>对于图形界面程序, 最合理的做法还是只用输入控件, LineEdit 等, 不用控制台, 也就是不用 sys.stdin<br>Qt 处理键盘消息应该用键盘事件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;键盘输入的字符串是保存在stdin中的,我在程序中如何将stdin中数据拿到并赋给一个变量? 之前我是通过sys.stdin.readlin
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统之镜像备份</title>
    <link href="http://arvin-he.github.io/2017/08/28/linux-backup-2017-08-28/"/>
    <id>http://arvin-he.github.io/2017/08/28/linux-backup-2017-08-28/</id>
    <published>2017-08-28T05:51:53.000Z</published>
    <updated>2017-09-08T03:51:39.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算文件拷贝的进度"><a href="#计算文件拷贝的进度" class="headerlink" title="计算文件拷贝的进度"></a>计算文件拷贝的进度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># dd_process.sh</span></div><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"><span class="comment">####dd 命令反映进度####</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne 2 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"需要 盘符名 镜像名"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line">dupath=`du -m --total / --exclude=proc --exclude=media |grep 总用量 |cut -f 1`</div><div class="line"><span class="built_in">echo</span> <span class="string">"根文件大小为<span class="variable">$dupath</span> M"</span></div><div class="line"><span class="built_in">let</span> SIZE=<span class="variable">$dupath</span>+200</div><div class="line">    <span class="keyword">while</span> <span class="literal">true</span></div><div class="line">    <span class="keyword">do</span></div><div class="line">    dusize=`du -hm /media/Lark/<span class="variable">$1</span>/<span class="variable">$2</span> |cut -f 1`</div><div class="line">    <span class="built_in">echo</span> <span class="string">"生成文件大小为 <span class="variable">$dusize</span> M"</span></div><div class="line">    <span class="keyword">if</span> [ <span class="variable">$dusize</span> == <span class="variable">$SIZE</span> ]</div><div class="line">        <span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"文件生成成功！"</span></div><div class="line">        <span class="built_in">exit</span> 0</div><div class="line">    <span class="keyword">fi</span></div><div class="line">    <span class="keyword">done</span></div></pre></td></tr></table></figure><h3 id="将根文件备份到u盘"><a href="#将根文件备份到u盘" class="headerlink" title="将根文件备份到u盘"></a>将根文件备份到u盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"><span class="comment">#################################</span></div><div class="line"><span class="comment">###  get img to u_disk                                 ### </span></div><div class="line"><span class="comment">### 功能：将根文件备份到u盘                      ###  </span></div><div class="line"><span class="comment">#################################</span></div><div class="line"><span class="comment">#卸载备份区，保证/media/Lark下只挂载u盘</span></div><div class="line"><span class="keyword">if</span> [ -d /media/Lark/.linuxroot ];<span class="keyword">then</span></div><div class="line">/bin/umount /media/Lark/.linuxroot</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"请切换root权限执行"</span></div><div class="line"><span class="built_in">exit</span> -5</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne 2 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"请输入 u盘名 镜像名称!"</span></div><div class="line"><span class="built_in">exit</span> -7</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment">#检测出u盘个数及盘符名</span></div><div class="line"></div><div class="line">LS_MEDIA_LARK=`ls /media/Lark`</div><div class="line">SELECTED_DISK=</div><div class="line">counter=0</div><div class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls /media/Lark`</div><div class="line"><span class="keyword">do</span></div><div class="line">counter=`expr <span class="variable">$counter</span> + 1`</div><div class="line"><span class="keyword">done</span></div><div class="line"><span class="comment">#echo $counter</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$counter</span> == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="comment">#没有U盘插入，退出</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"没有插入u盘或者没有挂载盘符！！请检测u盘是否可正常识别!"</span></div><div class="line"><span class="built_in">exit</span> -1</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment">#echo "LS_MEDIA_LARK is $LS_MEDIA_LARK "</span></div><div class="line">DISK1=`<span class="built_in">echo</span> <span class="variable">$LS_MEDIA_LARK</span>|awk -F <span class="string">' '</span> <span class="string">'&#123;print $1&#125;'</span>`</div><div class="line">DISK2=`<span class="built_in">echo</span> <span class="variable">$LS_MEDIA_LARK</span>|awk -F <span class="string">' '</span> <span class="string">'&#123;print $2&#125;'</span>`</div><div class="line"><span class="comment">#echo "DISK1 is $DISK1,DISK2 is $DISK2"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"检测目前根文件大小"</span></div><div class="line">dupath=`du -m --total / --exclude=proc --exclude=media |grep 总用量 |cut -f 1`</div><div class="line"><span class="built_in">echo</span> <span class="string">"根文件大小为<span class="variable">$dupath</span> M"</span></div><div class="line"><span class="comment">#size=2700</span></div><div class="line"><span class="comment">#if [ $dupath -gt $size ];then</span></div><div class="line"><span class="comment">#echo "注意：当前系统生成镜像大于3GB，生成镜像文件不可使用Lark升级工具烧写，但可使用原厂工具烧写"</span></div><div class="line"><span class="comment">#exit 0</span></div><div class="line"><span class="comment">#fi</span></div><div class="line"><span class="comment">#TODO :校验U盘可用空间，与根文件做对比</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"####生成根文件镜像####"</span></div><div class="line"><span class="built_in">let</span> SIZE=<span class="variable">$dupath</span>+10</div><div class="line"><span class="built_in">echo</span> <span class="string">"生成文件大小为<span class="variable">$SIZE</span> M"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"步骤一:选择存放镜像的U盘"</span></div><div class="line"><span class="keyword">if</span> <span class="literal">false</span>;<span class="keyword">then</span></div><div class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$DISK2</span>"</span> ] ;<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"共检测出u盘 <span class="variable">$counter</span>个：请选择1.<span class="variable">$DISK1</span> 2.<span class="variable">$DISK2</span>"</span></div><div class="line"><span class="built_in">read</span> CHOICE</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="variable">$CHOICE</span> <span class="keyword">in</span></div><div class="line">1) </div><div class="line"><span class="built_in">echo</span> <span class="string">"你选择的u盘为<span class="variable">$DISK1</span>"</span></div><div class="line">SELECTED_DISK=<span class="variable">$DISK1</span></div><div class="line">;;</div><div class="line">2)</div><div class="line"><span class="built_in">echo</span> <span class="string">"你选择的u盘为<span class="variable">$DISK2</span>"</span></div><div class="line">SELECTED_DISK=<span class="variable">$DISK2</span></div><div class="line">;;</div><div class="line">*)</div><div class="line"><span class="built_in">echo</span> <span class="string">"选择错误"</span></div><div class="line"><span class="built_in">exit</span> -2</div><div class="line">;;</div><div class="line"><span class="keyword">esac</span></div><div class="line"><span class="keyword">else</span></div><div class="line">SELECTED_DISK=<span class="variable">$DISK1</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">fi</span></div><div class="line">SELECTED_DISK=<span class="variable">$1</span></div><div class="line"><span class="comment">#检测所选u盘是剩余空间</span></div><div class="line"></div><div class="line">DISK_SPACE=`df -hm /media/Lark/<span class="variable">$SELECTED_DISK</span> | sed -n <span class="string">"2p"</span> | awk <span class="string">'&#123;print $4&#125;'</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"剩余空间为 <span class="variable">$DISK_SPACE</span> M"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$SIZE</span> -gt <span class="variable">$DISK_SPACE</span> ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"根文件大小大于备份区最大空间，请删减可删减的文件进行备份"</span></div><div class="line"><span class="built_in">exit</span> -3</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"步骤二:切换到U盘目录，且创建镜像文件，请耐心等待"</span></div><div class="line"><span class="built_in">cd</span>  /media/Lark/<span class="variable">$SELECTED_DISK</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="literal">false</span>;<span class="keyword">then</span></div><div class="line"><span class="comment">#后台检测，一旦U盘断开，或者卸载，则退出此次操作</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span> <span class="literal">true</span></div><div class="line"><span class="keyword">do</span></div><div class="line">CHECK_DISK=/media/Lark/<span class="variable">$SELECTED_DISK</span></div><div class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$CHECK_DISK</span> ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"u盘已断开，请检测其连接性并重新执行"</span></div><div class="line"><span class="built_in">echo</span></div><div class="line"><span class="built_in">exit</span> -4</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$FLAGS</span> == 1 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line">&#125;&amp;</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">IMAGE_NAME=<span class="variable">$2</span><span class="string">".tmp"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span>  <span class="string">"步骤三:生成镜像名:<span class="variable">$IMAGE_NAME</span>"</span></div><div class="line">touch <span class="variable">$IMAGE_NAME</span></div><div class="line"><span class="built_in">echo</span>  <span class="string">"步骤四：生成指定大小空文件"</span></div><div class="line">dd <span class="keyword">if</span>=/dev/zero of=<span class="variable">$IMAGE_NAME</span> bs=1M count=<span class="variable">$SIZE</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span>  <span class="string">"步骤五：格式化镜像文件"</span></div><div class="line">mkfs.ext4 -F -L .linuxroot <span class="variable">$IMAGE_NAME</span></div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"dd 操作失误"</span></div><div class="line"><span class="built_in">exit</span> -1;</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"步骤六：挂载镜像文件到mnt目录"</span></div><div class="line">        mount -o loop <span class="variable">$IMAGE_NAME</span> /mnt</div><div class="line"></div><div class="line">    <span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"步骤七：同步根分区到mnt"</span></div><div class="line">rsync -axv / /mnt</div><div class="line"><span class="keyword">fi</span> </div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? == 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步完成"</span></div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步失败，请重新执行"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="comment">#echo "请卸载U盘"</span></div><div class="line"><span class="built_in">cd</span> /tmp</div><div class="line">umount /mnt</div><div class="line"><span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"挂载点已卸载"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">echo</span> <span class="string">" 镜像已生成！"</span></div><div class="line">sleep 3</div><div class="line"><span class="comment">#fuser -km /media/Lark/$SELECTED_DISK</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"镜像修正以便烧写"</span></div><div class="line">mv /media/Lark/<span class="variable">$SELECTED_DISK</span>/<span class="variable">$IMAGE_NAME</span> /media/Lark/<span class="variable">$SELECTED_DISK</span>/<span class="variable">$2</span><span class="string">".img"</span></div><div class="line">umount /media/Lark/<span class="variable">$SELECTED_DISK</span></div><div class="line"><span class="keyword">if</span> [ $? == 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$SELECTED_DISK</span> 已卸载成功"</span> </div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"请卸载并拔除U盘"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure><h3 id="系统备份"><a href="#系统备份" class="headerlink" title="系统备份"></a>系统备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -d /media/Lark/.linuxroot ];<span class="keyword">then</span></div><div class="line">/bin/umount /media/Lark/.linuxroot</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"检测目前根文件大小"</span></div><div class="line">dupath=`du -m --total / --exclude=proc --exclude=media |grep 总用量 |cut -f 1`</div><div class="line">    fssize=<span class="variable">$dupath</span></div><div class="line">size=2500</div><div class="line"><span class="keyword">if</span> [ <span class="variable">$fssize</span> -gt <span class="variable">$size</span> ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"根文件大小大于备份区最大空间，请删减可删减的文件进行备份"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"检测系统一致性"</span></div><div class="line">/sbin/e2fsck -f -y  /dev/mmcblk0p6</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"一致性检测失败，请检测重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"扩展备份区到最大限额2.8G"</span></div><div class="line">/sbin/resize2fs /dev/mmcblk0p6 2600M</div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"扩大分区失败，请重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"挂载系统备份区"</span></div><div class="line"></div><div class="line">/bin/mount -o loop /dev/block/mtd/by-name/linuxfsbk /mnt</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"挂载系统备份区失败，请重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步当前系统"</span></div><div class="line"></div><div class="line">/usr/bin/rsync -axv --delete / /mnt </div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步当前系统失败，请重试"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"卸载系统备份区"</span></div><div class="line">/bin/umount /mnt</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"卸载系统备份区失败，请重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步完成"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"卸载系统备份区"</span></div><div class="line">/bin/umount /mnt</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"卸载系统备份区失败，请重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"系统备份成功 "</span></div><div class="line"></div><div class="line">sleep 2</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算文件拷贝的进度&quot;&gt;&lt;a href=&quot;#计算文件拷贝的进度&quot; class=&quot;headerlink&quot; title=&quot;计算文件拷贝的进度&quot;&gt;&lt;/a&gt;计算文件拷贝的进度&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http://arvin-he.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Web之REST概念</title>
    <link href="http://arvin-he.github.io/2017/08/25/web-rest-2017-08-25/"/>
    <id>http://arvin-he.github.io/2017/08/25/web-rest-2017-08-25/</id>
    <published>2017-08-25T08:52:13.000Z</published>
    <updated>2017-09-08T03:51:40.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="REST当中为什么要使用HTTP-PUT"><a href="#REST当中为什么要使用HTTP-PUT" class="headerlink" title="REST当中为什么要使用HTTP PUT"></a>REST当中为什么要使用HTTP PUT</h3><p>REST(Representational State Transfer)是<strong>网络服务接口</strong>的一种<strong>风格</strong>，并不是一个标准，就web service而言，REST要比SOAP（SOAP是标准，不是风格）轻量得多，容易得多。我记得我最初开始接触web service的时候，所有的材料上来就是一大堆的名词，SOAP, WSDL,看得头都要大了，后来提出来的REST就容易理解得多，虽然目前SOAP在企业级的web service中还有一席之地，但是在公共的Internet上，不是REST的服务实在不好意思和人打招呼，我们经常可以看到评价某某服务是RESTful的，但是从来没有听说某某服务是SOAPful的 :-)<br>微软对REST的支持有点晚，自.NET3.5开始，WCF也可以提供RESTful接口。当然，REST不光限于web service，网页服务也可以RESTful，微软的ASP.NET MVC框架提供了直接的REST支持。</p><p>因为REST只是风格，不是标准，所以有的方面容易有误解，比如说创建和更新某个URI代表的资源的时候，是用HTTP的PUT还是POST命令。REST常用的四种HTTP命令，GET、DELETE、PUT和POST，对于GET和DELETE，一个是获取资源，一个是删除资源，没什么异议，问题是PUT和POST，两者都有更改指定URI的语义，那么，究竟是用哪一个呢？</p><p>有的观点认为，应该用POST来创建一个资源，用PUT来更新一个资源；有的观点认为，应该用PUT来创建一个资源，用POST来更新一个资源；还有的观点认为可以用PUT和POST中任何一个来做创建或者更新一个资源。这些观点都只看到了风格，争论起来也只是争论哪种风格更好，其实，用PUT还是POST，不是看这是创建还是更新资源的动作，这不是风格的问题，而是语义的问题。</p><p>REST是一种风格，但是还是依赖于HTTP协议，在HTTP中，PUT被定义为idempotent(幂等)的方法，POST则不是，这是一个很重要的区别。</p><p>“Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.”</p><p>上面的话就是说，如果一个方法重复执行多次，产生的效果是一样的，那就是idempotent的。</p><p>举一个简单的例子，加入由一个博客系统提供一个Web API，模式是这样<a href="http://superblogging/blogs/post/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP" target="_blank" rel="external">http://superblogging/blogs/post/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP</a> PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。我们应该用PUT方法还是POST方法？取决于这个REST服务的行为是否是idempotent的，假如我们发送两个<a href="http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。" target="_blank" rel="external">http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。</a></p><p>也许你会觉得这个两个方法的差别没什么大不了的，用错了也不会有什么问题，但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦。比如，没准Google Crawler也会访问你的服务，如果让一个不是indempotent的服务可以用indempotent的方法访问，那么你服务器的状态可能就会被Crawler修改，这是不应该发生的。</p><h3 id="关于幂等的概念"><a href="#关于幂等的概念" class="headerlink" title="关于幂等的概念"></a>关于幂等的概念</h3><p>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p><p>　　(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p><p>　　* 注意：这里安全的含义仅仅是指是非修改信息。</p><p>　　(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念：</p><p>幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。<br>幂等有一下几种定义：<br>对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。</p><p>对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。<br>看完上述解释后，应该可以理解GET幂等的含义了。</p><p>但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.cnblogs.com/shanyou/archive/2011/10/17/2215930.html" target="_blank" rel="external">REST当中为什么要使用HTTP PUT</a></li><li><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">浅谈HTTP中Get与Post的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;REST当中为什么要使用HTTP-PUT&quot;&gt;&lt;a href=&quot;#REST当中为什么要使用HTTP-PUT&quot; class=&quot;headerlink&quot; title=&quot;REST当中为什么要使用HTTP PUT&quot;&gt;&lt;/a&gt;REST当中为什么要使用HTTP PUT&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Web" scheme="http://arvin-he.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Web之Get和Post区别</title>
    <link href="http://arvin-he.github.io/2017/08/25/web-getpost-2017-08-25/"/>
    <id>http://arvin-he.github.io/2017/08/25/web-getpost-2017-08-25/</id>
    <published>2017-08-25T07:22:07.000Z</published>
    <updated>2017-09-08T03:51:40.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两种-HTTP-请求方法：GET-和-POST"><a href="#两种-HTTP-请求方法：GET-和-POST" class="headerlink" title="两种 HTTP 请求方法：GET 和 POST"></a>两种 HTTP 请求方法：GET 和 POST</h3><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p><p>GET - 从指定的资源请求数据。</p><p>POST - 向指定的资源提交要被处理的数据</p><h3 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h3><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：<br><code>/test/demo_form.asp?name1=value1&amp;name2=value2</code></p><p>有关 GET 请求的其他一些注释：</p><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制</li><li>GET 请求只应当用于取回数据</li></ul><h3 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h3><p>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POST /test/demo_form.asp HTTP/1.1</div><div class="line">Host: w3schools.com</div><div class="line">name1=value1&amp;name2=value2</div></pre></td></tr></table></figure></p><p>有关 POST 请求的其他一些注释：</p><ul><li>OST 请求不会被缓存</li><li>POST 请求不会保留在浏览器历史记录中</li><li>POST 不能被收藏为书签</li><li>POST 请求对数据长度没有要求</li></ul><h3 id="GET-与-POST区别"><a href="#GET-与-POST区别" class="headerlink" title="GET 与 POST区别"></a>GET 与 POST区别</h3><ol><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ol><h3 id="一些误区"><a href="#一些误区" class="headerlink" title="一些误区"></a>一些误区</h3><p>误区一：POST可以比GET提交更多更长的数据？<br>由于使用GET方法提交数据时，以?分割URL和传输数据，参数之间以&amp;相连，在URL后面添加需要提交的参数，有人就会说了，浏览器地址栏输入的参数是有限的，而POST不用再地址栏输入，所以POST就比GET可以提交更多的数据。难道真的是这样的么？<br>而实际上，URL不存在参数上限的问题，HTTP协议规范<strong>没有</strong>对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。<br>同时，POST是没有大小限制的，HTTP协议规范也没有进行大小限制。POST数据是没有限制的，<strong>起限制作用的是服务器的处理程序的处理能力。</strong><br>总归一句话，这个限制是针对所有HTTP请求的，与GET、POST没有多少关系。</p><p>误区二：POST比GET安全？<br>首先，我们要承认安全的概念有很多种，要是从最基本的肉眼看到就不安全，肉眼看不到那就是安全的概念说呢，GET确实没有POST安全，毕竟小白用户确实可以看到在URL中带有的数据信息，这个你无法狡辩。那么要是往严谨了说呢，POST是不是要比GET安全呢？其实不是的。<br>上面也说了，GET将提交到服务器的数据添加到URL中了，可见；虽然POST的数据，你肉眼看不到，你抓个包看看，在HTTP包的包体中，我们提交的数据时仍然可见的.</p><h3 id="比较GET-与-POST"><a href="#比较GET-与-POST" class="headerlink" title="比较GET 与 POST"></a>比较GET 与 POST</h3><p>下面的表格比较了两种 HTTP 方法：GET 和 POST。</p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>很多时候，大家都觉的使用GET很方便，毕竟使用POST要用到Form，但是，你要知道，你使用GET方法时，浏览器可能会缓存你的地址等信息，还会留下历史记录，而对于POST方法呢，则不会进行缓存。在开发中，一定要分清楚GET和POST的使用场合，什么时候要使用GET，什么时候要使用POST，自己做到心中有数。</p><p>可能，你在Google类似的文章的时候，可能会看到分析POST和PUT区别的文章，这又是一类纠结的东西，更多的时候，我们分析这种东西都是分实际情景，结合设计者的语义去使用.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="external">w3cschool</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;两种-HTTP-请求方法：GET-和-POST&quot;&gt;&lt;a href=&quot;#两种-HTTP-请求方法：GET-和-POST&quot; class=&quot;headerlink&quot; title=&quot;两种 HTTP 请求方法：GET 和 POST&quot;&gt;&lt;/a&gt;两种 HTTP 请求方法：GET 
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Web" scheme="http://arvin-he.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>爬虫基础知识(一)</title>
    <link href="http://arvin-he.github.io/2017/08/25/py-scrapy1-2017-08-25/"/>
    <id>http://arvin-he.github.io/2017/08/25/py-scrapy1-2017-08-25/</id>
    <published>2017-08-25T06:12:06.000Z</published>
    <updated>2017-09-08T03:51:39.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-URL"><a href="#1-URL" class="headerlink" title="1. URL"></a>1. URL</h3><p>URL的格式由三部分组成：<br>第一部分是协议(或称为服务方式)。<br>第二部分是存有该资源的主机IP地址(有时也包括端口号)。<br>第三部分是主机资源的具体地址，如目录和文件名等。</p><p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫学习有很大帮助。</p><h3 id="关于urllib2包"><a href="#关于urllib2包" class="headerlink" title="关于urllib2包"></a>关于urllib2包</h3><p>python 3.X版本是不需要安装urllib2包，urllib和urllib2包集合成在一个包为urllib了.<br>在python3.x版本中，如何使用：urllib2.urlopen()？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"></div><div class="line">response = urllib.request.urlopen(<span class="string">"http://www.baidu.com"</span>)</div><div class="line">print(response.read())</div><div class="line"></div><div class="line">URL = <span class="string">"http://www.baidu.com"</span></div><div class="line">request = urllib.request.Request(URL)</div><div class="line">response = urllib.request.urlopen(request)</div><div class="line">print(response.read())</div></pre></td></tr></table></figure></p><h3 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h3><p>大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。</p><p>urlopen一般接受三个参数，它的参数如下：<code>urlopen(url, data, timeout)</code><br>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。<br>第二,三个参数是可以不传送的，data默认为空None，timeout默认为 <code>socket._GLOBAL_DEFAULT_TIMEOUT</code></p><h4 id="POST方式："><a href="#POST方式：" class="headerlink" title="POST方式："></a>POST方式：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"> </div><div class="line">values = &#123;<span class="string">"username"</span>:<span class="string">"xxxx@qq.com"</span>,<span class="string">"password"</span>:<span class="string">"XXXX"</span>&#125;</div><div class="line">data = urllib.urlencode(values) </div><div class="line">url = <span class="string">"https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"</span></div><div class="line">request = urllib.request.Request(url, data)</div><div class="line">response = urllib.request.urlopen(request)</div><div class="line">print(response.read())</div></pre></td></tr></table></figure><h4 id="GET方式："><a href="#GET方式：" class="headerlink" title="GET方式："></a>GET方式：</h4><p>至于GET方式我们可以直接把参数写到网址上面，直接<strong>构建一个带参数的URL</strong>出来即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"> </div><div class="line">values=&#123;&#125;</div><div class="line">values[<span class="string">'username'</span>] = <span class="string">"xxxx@qq.com"</span></div><div class="line">values[<span class="string">'password'</span>]=<span class="string">"XXXX"</span></div><div class="line">data = urllib.urlencode(values) </div><div class="line">url = <span class="string">"http://passport.csdn.net/account/login"</span></div><div class="line">geturl = url + <span class="string">"?"</span> + data</div><div class="line">request = urllib.request.Request(geturl)</div><div class="line">response = urllib.request.urlopen(request)</div><div class="line">print(response.read())</div></pre></td></tr></table></figure></p><h3 id="python3中urllib的模块分4个子模块"><a href="#python3中urllib的模块分4个子模块" class="headerlink" title="python3中urllib的模块分4个子模块"></a>python3中urllib的模块分4个子模块</h3><p>urllib.request for opening and reading URLs<br>urllib.error containing the exceptions raised by urllib.request<br>urllib.parse for parsing URLs<br>urllib.robotparser for parsing robots.txt files</p><h3 id="python3中urllib报错"><a href="#python3中urllib报错" class="headerlink" title="python3中urllib报错"></a>python3中urllib报错</h3><p> 爬虫过程报错：http.client.RemoteDisconnected: Remote end closed connection without response<br> 利用 urllib 发起的请求，UA 默认是 Python-urllib/3.5 而在 chrome 中访问则 user_agent = ‘Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36’，因为服务器根据 UA 来判断拒绝了 python 爬虫。</p><p> 在浏览器中可以查看自己浏览器的UA</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-URL&quot;&gt;&lt;a href=&quot;#1-URL&quot; class=&quot;headerlink&quot; title=&quot;1. URL&quot;&gt;&lt;/a&gt;1. URL&lt;/h3&gt;&lt;p&gt;URL的格式由三部分组成：&lt;br&gt;第一部分是协议(或称为服务方式)。&lt;br&gt;第二部分是存有该资源的主机IP地址(
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="爬虫" scheme="http://arvin-he.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python之jsonrpc</title>
    <link href="http://arvin-he.github.io/2017/08/25/py-jsonrpc-2017-08-25/"/>
    <id>http://arvin-he.github.io/2017/08/25/py-jsonrpc-2017-08-25/</id>
    <published>2017-08-25T03:38:39.000Z</published>
    <updated>2017-09-08T03:51:39.871Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># server</span></div><div class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</div><div class="line"><span class="keyword">from</span> jsonrpcserver <span class="keyword">import</span> methods</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@methods.add</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span>(<span class="string">'ping'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@methods.add</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hao</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span>(<span class="string">'hao'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@methods.add</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span>(<span class="string">'Hello, %s'</span> % name)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@methods.add</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sum</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">return</span>(a + b)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestHttpServer</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># Process request</span></div><div class="line">        request = self.rfile.read(int(self.headers[<span class="string">'Content-Length'</span>])).decode()</div><div class="line">        response = methods.dispatch(request)</div><div class="line">        <span class="comment"># Return response</span></div><div class="line">        self.send_response(response.http_status)</div><div class="line">        self.send_header(<span class="string">'Content-type'</span>, <span class="string">'application/json'</span>)</div><div class="line">        self.end_headers()</div><div class="line">        self.wfile.write(str(response).encode())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    HTTPServer((<span class="string">'localhost'</span>, <span class="number">5000</span>), TestHttpServer).serve_forever()</div></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> jsonrpcclient.http_client <span class="keyword">import</span> HTTPClient</div><div class="line"></div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'ping'</span>)</div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'hao'</span>)</div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'hello'</span>, <span class="string">'Nancy'</span>)</div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'Sum'</span>, <span class="number">5</span>, <span class="number">7</span>)</div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'lid'</span>)</div></pre></td></tr></table></figure><p>先运行服务端,再运行客户端代码</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">--&gt; &#123;&quot;id&quot;: 1, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;ping&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: &quot;ping&quot;, &quot;id&quot;: 1&#125; (200 OK)</div><div class="line">--&gt; &#123;&quot;id&quot;: 2, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;hao&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: &quot;hao&quot;, &quot;id&quot;: 2&#125; (200 OK)</div><div class="line">--&gt; &#123;&quot;params&quot;: [&quot;Nancy&quot;], &quot;id&quot;: 3, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;hello&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: &quot;Hello, Nancy&quot;, &quot;id&quot;: 3&#125; (200 OK)</div><div class="line">--&gt; &#123;&quot;params&quot;: [5, 7], &quot;id&quot;: 4, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;Sum&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 12, &quot;id&quot;: 4&#125; (200 OK)</div><div class="line">--&gt; &#123;&quot;id&quot;: 5, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;lid&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;error&quot;: &#123;&quot;code&quot;: -32601, &quot;message&quot;: &quot;Method not found&quot;&#125;, &quot;id&quot;: 5&#125; (404 Not Found)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;js_client.py&quot;, line 7, in &lt;module&gt;</div><div class="line">    HTTPClient(&apos;http://localhost:5000&apos;).request(&apos;lid&apos;)</div><div class="line">  File &quot;C:\Python34\lib\site-packages\jsonrpcclient\client.py&quot;, line 200, in request</div><div class="line">    return self.send(Request(method_name, *args, **kwargs))</div><div class="line">  File &quot;C:\Python34\lib\site-packages\jsonrpcclient\client.py&quot;, line 171, in send</div><div class="line">    return self._send_message(request, **kwargs)</div><div class="line">  File &quot;C:\Python34\lib\site-packages\jsonrpcclient\http_client.py&quot;, line 82, in _send_message</div><div class="line">    log_format=&apos;&lt;-- %(message)s (%(http_code)s %(http_reason)s)&apos;)</div><div class="line">  File &quot;C:\Python34\lib\site-packages\jsonrpcclient\client.py&quot;, line 114, in _process_response</div><div class="line">    response[&apos;error&apos;].get(&apos;data&apos;))</div><div class="line">jsonrpcclient.exceptions.ReceivedErrorResponse: Method not found</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;&gt;&lt;/a&gt;服务端&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>正向代理和反向代理</title>
    <link href="http://arvin-he.github.io/2017/08/24/web-forwardbackagent-2017-08-24/"/>
    <id>http://arvin-he.github.io/2017/08/24/web-forwardbackagent-2017-08-24/</id>
    <published>2017-08-24T06:56:13.000Z</published>
    <updated>2017-09-08T03:51:40.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 <a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a> 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求<code>google.com</code>，代理把请求返回的相应结构再返回给我.</p><p><img src="/2017/08/24/web-forwardbackagent-2017-08-24/1.png" alt=""></p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡.</p><p><img src="/2017/08/24/web-forwardbackagent-2017-08-24/2.png" alt=""></p><p>两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.zhihu.com/question/24723688" target="_blank" rel="external">知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h3&gt;&lt;p&gt;我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="web" scheme="http://arvin-he.github.io/tags/web/"/>
    
  </entry>
  
</feed>
