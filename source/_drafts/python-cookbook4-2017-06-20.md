---
title: python-cookbook4-2017-06-20
tags:
---
手动遍历迭代器
为了手动的遍历可迭代对象，使用 next() 函数并在代码中捕获 StopIteration 异常.

代理迭代
你构建了一个自定义容器对象，里面包含有列表、元组或其他可迭代对象。你想直接在你的这个新容器对象上执行迭代操作。
实际上你只需要定义一个`__iter__ ()` 方法，将迭代操作代理到容器内部的对象上去.
Python 的迭代器协议需要 `__iter__()` 方法返回一个实现了 `__next__()` 方法的迭代器对象。如果你只是迭代遍历其他容器的内容，你无须担心底层是怎样实现的。你所要做的只是传递迭代请求既可。这里的 iter() 函数的使用简化了代码， iter(s) 只是简单的通过调用`s.__iter__()` 方法来返回对应的迭代器对象，就跟 len(s) 会调用`s.__len__()`原理是一样的。

反向迭代
使用内置的 reversed() 函数
反向迭代仅仅当对象的大小可预先确定或者对象实现了 reversed () 的特殊方法时才能生效。如果两者都不符合，那你必须先将对象转换为一个列表才行.
要注意的是如果可迭代对象元素很多的话，将其预先转换为一个列表要消耗大量的内存。
很多程序员并不知道可以通过在自定义类上实现 reversed () 方法来实现反向迭代。

迭代器切片 
迭代器和生成器不能使用标准的切片操作，因为它们的长度事先我们并不知道 (并且也没有实现索引)。函数 islice() 返回一个可以生成指定元素的迭代器，它通过遍历并丢弃直到切片开始索引位置的所有元素。然后才开始一个个的返回元素，并直到切片结束索引位置。这里要着重强调的一点是 islice() 会消耗掉传入的迭代器中的数据。必须考虑到迭代器是不可逆的这个事实。所以如果你需要之后再次访问这个迭代器的话，那你就得先将它里面的数据放入一个列表中。

同时迭代多个序列
你想同时迭代多个序列，每次分别从一个序列中取一个元素。使用 zip() 函数.还可以使用 itertools.zip longest() 函数来代替.

不同集合上元素的迭代
你想在多个对象执行相同的操作，但是这些对象在不同的容器中，你希望代码在不失可读性的情况下避免写重复的循环。
itertools.chain() 方法可以用来简化这个任务。它接受一个可迭代对象列表作为输入，并返回一个迭代器，有效的屏蔽掉在多个容器中迭代细节。
使用 chain() 的一个常见场景是当你想对不同的集合中所有元素执行某些操作的时候.


展开嵌套的序列
将一个多层嵌套的序列展开成一个单层列表, 写一个包含 yield from 语句的递归生成器来轻松解决这个问题,
语句 yield from 在你想在生成器中调用其他生成器作为子例程的时候非常有用。如果你不使用它的话，那么就必须写额外的 for 循环了

顺序迭代合并后的排序迭代对象
有一系列排序序列，想将它们合并后得到一个排序序列并在上面迭代遍历。heapq.merge() 函数可以帮你解决这个问题

迭代器代替 while 无限循环
iter 函数一个鲜为人知的特性是它接受一个可选的 callable 对象和一个标记 (结
尾) 值作为输入参数。当以这种方式使用的时候，它会创建一个迭代器，这个迭代器会
不断调用 callable 对象直到返回值和标记值相等为止。
这种特殊的方法对于一些特定的会被重复调用的函数很有效果，比如涉及到 I/O
调用的函数。举例来讲，如果你想从套接字或文件中以数据块的方式读取数据，通常
你得要不断重复的执行 read() 或 recv() ，并在后面紧跟一个文件结尾测试来决定是
否终止。