---
title: redis笔记
date: 2017-11-25 21:45:48
tags: redis
categories: 数据库
---

### redis下载与安装
1. windows下redis下载地址:
![https://github.com/MicrosoftArchive/redis/releases](https://github.com/MicrosoftArchive/redis/releases)

2. 下载zip版本,在C盘根目录下(或者你想安装的目录下)解压

3. 添加redis环境变量

4. 注册redis服务
`redis-server.exe --service-install redis.windows.conf --loglevel verbose`

5. 启动redis服务
`redis-server.exe --service-start`

6. 下载redis可视化客户端软件RedisDesktopManager

下载地址:
![https://redisdesktop.com/download](https://redisdesktop.com/download)

### python下安装redis绑定包
`pip install redis`

### redis, mongodb与memcache对比
mongodb 直接持久化 
redis 半持久化 
memcache 只能在内存，轻量级缓存

### redis简介
redis是一个key-value存储系统。和Memcached类似,支持的类型操作有: String操作, Hash操作, List操作, Set操作, Sort Set操作(zset)
这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的.
redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。
区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。

### python操作redis
edis-py提供两个类Redis和StrictRedis用于实现Redis的命令，
StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，
Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。

redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。
默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池。
```python
import redis

r = redis.Redis(host='127.0.0.1', port=6379)
r.set('foo', 'Bar')
print (r.get('foo'))
# 使用连接池
pool = redis.ConnectionPool(host='127.0.0.1', port=6379)
r = redis.Redis(connection_pool=pool)
r.set('foo', 'Bar')
print r.get('foo')
```

### string操作
set(name, value, ex=None, px=None, nx=False, xx=False)
setnx 、 setex 、 psetex
在Redis中设置值，默认，不存在则创建，存在则修改
参数：
     ex，过期时间（秒）
     px，过期时间（毫秒）
     nx，如果设置为True，则只有name不存在时，当前set操作才执行
     xx，如果设置为True，则只有name存在时，当前set操作才执行

批量设置
mset(*args, **kwargs)
批量获取
mget(keys, *args)
设置新值并获取原来的值
getset(name, value)
获取子序列（根据字节获取，非字符）
getrange(key, start, end)
修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）
setrange(name, offset, value)
对name对应值的二进制进行位操作。
setbit(name, offset, value)
获取name对应的值的二进制表示中 1 的个数,应用场景:统计在线用户数有多少
bitcount(key, start=None, end=None)
自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。
incr(self, name, amount=1)
incrbyfloat(self, name, amount=1.0)
自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。
decr(self, name, amount=1)
在redis name对应的值后面追加内容
append(key, value)

### Hash操作
Hash操作，redis中Hash在内存中的存储格式如下图：
```
name                hash
               |````````````|
n1   --------> | k1 --> v1  |
               | k2 --> v2  |
               |____________|
               |````````````|
n2   --------> | k7 --> v7  |
               |____________|
```
name对应的hash中设置一个键值对（不存在，则创建；否则，修改）
hset(name, key, value)
在name对应的hash中批量设置键值对
hmset(name, mapping)
在name对应的hash中获取多个key的值
hmget(name, keys, *args)
获取name对应的hash中键值对的个数
hlen(name)
检查name对应的hash是否存在当前传入的key
hexists(name, key)
将name对应的hash中指定key的键值对删除
hdel(name,*keys)
自增name对应的hash中的指定key的值，不存在则创建key=amount
hincrby(name, key, amount=1)
hincrbyfloat(name, key, amount=1.0) 
过滤,增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆
hscan(name, cursor=0, match=None, count=None) 
利用yield封装hscan创建生成器，实现分批去redis中获取数据
hscan_iter(name, match=None, count=None)

### 列表操作
lpush, lrange, rpush, lpushx, llen, linsert, lset, lrem, lpop, lindex, ltrim, rpoplpush, blpop, brpoplpush


### 集合操作
sadd, scard, sdiff, sdiffstore, sinter, sinterstore, sismenber, smove, spop, srandmenber, srem, sunion, sunionstore

### 有序集合(zset)
zadd, zcount, zincrby, zrank, zrem, zremrangebyrank, zremrankbyscore, zremrangebylex, zscore, zinterstore, zunionstore

```
zunionstore(dest, keys, aggregate=None)
# 获取两个有序集合的并集
# aggregate的值为:  SUM  MIN  MAX
```


### 其他操作
```
del(*names)
# 根据删除redis中的任意数据类型

exists(name)
# 检测redis的name是否存在

keys(pattern='*')
# 根据模型获取redis的name
# 更多：
    # KEYS * 匹配数据库中所有 key 。
    # KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。
    # KEYS h*llo 匹配 hllo 和 heeeeello 等。
    # KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo

expire(name ,time)
# 为某个redis的某个name设置超时时间

rename(src, dst)
# 对redis的name重命名

move(name, db))
# 将redis的某个值移动到指定的db下，若有则不移动

select db_name
# 切换到其他db，redis有16个db

randomkey()
# 随机获取一个redis的name（不删除）

type(name)
# 获取name对应值的类型

scan(cursor=0, match=None, count=None)
scan_iter(match=None, count=None)
# 同字符串操作，用于增量迭代获取key
```

### 管道
redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，
如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。

```
import redis
import time

pool = redis.ConnectionPool(host='10.211.55.4', port=6379, db=5)
r = redis.Redis(connection_pool=pool)
# pipe = r.pipeline(transaction=False)
pipe = r.pipeline(transaction=True)

pipe.set('name', 'alex')
time.sleep(60)
pipe.set('role', 'sb')

pipe.execute()
```

### 发布订阅
收音机举例发布订阅
```
import redis

class RedisHelper:

    def __init__(self):
        self.__conn = redis.Redis(host='10.211.55.4')
        self.chan_sub = 'fm104.5'
        self.chan_pub = 'fm104.5'

    def public(self, msg):
        self.__conn.publish(self.chan_pub, msg)
        return True

    def subscribe(self):
        pub = self.__conn.pubsub()  # 打开收音机
        pub.subscribe(self.chan_sub) # 调频道
        pub.parse_response()  # 准备接收
        return pub
```

订阅方
```
from RedisHelper import RedisHelper

obj = RedisHelper()
redis_sub = obj.subscribe()

while True:
    msg= redis_sub.parse_response()
    print (msg)
```

发布方
```
from RedisHelper import RedisHelper

obj = RedisHelper()
obj.public('hello')
```


### 参考
* ![http://blog.csdn.net/fgf00/article/details/52917154](http://blog.csdn.net/fgf00/article/details/52917154)