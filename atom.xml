<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simple &amp; Freedom</title>
  
  <subtitle>Learn and live.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arvin-he.github.io/"/>
  <updated>2018-01-25T06:23:55.933Z</updated>
  <id>http://arvin-he.github.io/</id>
  
  <author>
    <name>Arvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux之crontab使用</title>
    <link href="http://arvin-he.github.io/2018/01/25/linux-crontab-2018-01-25/"/>
    <id>http://arvin-he.github.io/2018/01/25/linux-crontab-2018-01-25/</id>
    <published>2018-01-25T05:43:48.000Z</published>
    <updated>2018-01-25T06:23:55.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="crond简介"><a href="#crond简介" class="headerlink" title="crond简介"></a>crond简介</h2><p>linux 系统则是由 cron (crond) 这个系统服务来控制的, 这个系统服务是默认启动的。<br>另外, 用户也可以设置计划任务，Linux 系统提供了用户控制计划任务的命令 :crontab 命令。</p><p>crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，<br>当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，<br>如果有要执行的任务，则自动执行该任务。</p><p>Linux下的任务调度分为两类:系统任务调度和用户任务调度。</p><h3 id="系统任务调度"><a href="#系统任务调度" class="headerlink" title="系统任务调度"></a>系统任务调度</h3><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># /etc/crontab文件包括下面几行：</span></div><div class="line">cat /etc/crontab</div><div class="line">SHELL=/bin/bash</div><div class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</div><div class="line">MAILTO=HOME=/</div><div class="line"><span class="comment"># run-parts</span></div><div class="line">51 * * * * root run-parts /etc/cron.hourly</div><div class="line">24 7 * * * root run-parts /etc/cron.daily</div><div class="line">22 4 * * 0 root run-parts /etc/cron.weekly</div><div class="line">42 4 1 * * root run-parts /etc/cron.monthly</div></pre></td></tr></table></figure></p><p>前四行是用来配置crond任务运行的环境变量，<br>第一行SHELL变量指定了系统要使用哪个shell，这里是bash，<br>第二行PATH变量指定了系统执行 命令的路径，<br>第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户，<br>第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。</p><h3 id="用户任务调度"><a href="#用户任务调度" class="headerlink" title="用户任务调度"></a>用户任务调度</h3><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。<br>用户可以使用 crontab 工具来定制自己的计划任务。<br>所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p><p>使用者权限文件：<br>文件：/etc/cron.deny<br>说明：该文件中所列用户不允许使用crontab命令<br>文件：/etc/cron.allow<br>说明：该文件中所列用户允许使用crontab命令<br>文件：/var/spool/cron/<br>说明：所有用户crontab文件存放的目录,以用户名命名</p><p>crontab文件的含义：<br>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<code>minute hour day month week command</code><br>其中：<br>minute： 表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件,如python脚本。<br><img src="/2018/01/25/linux-crontab-2018-01-25/1.png" alt=""></p><p>在以上各个字段中，还可以使用以下特殊字符：<br>星号（<em>）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如</em>/10，如果用在minute字段，表示每十分钟执行一次。</p><h2 id="crond服务"><a href="#crond服务" class="headerlink" title="crond服务"></a>crond服务</h2><p>安装crontab：<code>yum install crontabs</code><br>服务操作说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/sbin/service crond start //启动服务</div><div class="line">/sbin/service crond stop //关闭服务</div><div class="line">/sbin/service crond restart //重启服务</div><div class="line">/sbin/service crond reload //重新载入配置</div><div class="line">/sbin/service crond status //启动服务</div></pre></td></tr></table></figure></p><p>查看crontab服务是否已设置为开机启动，执行命令：<code>ntsysv</code><br>加入开机自动启动：<code>chkconfig –level 35 crond on</code></p><h2 id="crontab命令详解"><a href="#crontab命令详解" class="headerlink" title="crontab命令详解"></a>crontab命令详解</h2><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">crontab [-u user] file</div><div class="line">crontab [-u user] [ -e | -l | -r ]</div></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。<br>时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br>这个命令非常设合周期性的日志分析或数据备份等工作。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p><code>-u user</code>：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。<br><code>file</code>：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。<br>如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。<br>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。<br>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。<br>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。<br>-i：在删除用户的crontab文件时给确认提示。</p><h3 id="4．常用方法："><a href="#4．常用方法：" class="headerlink" title="4．常用方法："></a>4．常用方法：</h3><h3 id="1-创建一个新的crontab文件"><a href="#1-创建一个新的crontab文件" class="headerlink" title="1). 创建一个新的crontab文件"></a>1). 创建一个新的crontab文件</h3><p>在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑 crontab文件。99%的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑<code>$HOME</code>目录下的<code>.profile</code>文件，在其 中加入这样一行：<code>EDITOR=vi; export EDITOR</code>, 然后保存并退出。不妨创建一个名为<code>&lt;user&gt;</code> cron的文件，其中<code>&lt;user&gt;</code>是用户名，例如，davecron。在该文件中加入如下的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># (put your own initials here)echo the date to the console every</div><div class="line"># 15minutes between 6pm and 6am</div><div class="line">0,15,30,45 18-06 * * * /bin/echo ‘date’ &gt; /dev/console</div></pre></td></tr></table></figure></p><p>保存并退出。确信前面5个域用空格分隔。<br>在上面的例子中，系统将每隔15分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些 系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为 cron命令的参数：<code>$ crontab davecron</code>, 现在该文件已经提交给cron进程，它将每隔15分钟运行一次。同时，新创建文件的一个副本已经被放在<code>/var/spool/cron</code>目录中，文件名就是用户名(即dave)。</p><h3 id="2-列出crontab文件"><a href="#2-列出crontab文件" class="headerlink" title="2). 列出crontab文件"></a>2). 列出crontab文件</h3><p>为了列出crontab文件，可以用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ crontab -l</div><div class="line">0,15,30,45,18-06 * * * /bin/echo `date` &gt; dev/tty1</div></pre></td></tr></table></figure></p><p>你将会看到和上面类似的内容。可以使用这种方法在<code>$HOME</code>目录中对crontab文件做一备份：<br><code>$ crontab -l &gt; $HOME/mycron</code>,这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p><h3 id="3-编辑crontab文件"><a href="#3-编辑crontab文件" class="headerlink" title="3). 编辑crontab文件"></a>3). 编辑crontab文件</h3><p>如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件，相应的命令为：<code>$ crontab -e</code><br>可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时，cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。<br>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</div><div class="line">30 3 1,7,14,21,26 * * /bin/find -name “core’ -exec rm &#123;&#125; \;</div></pre></td></tr></table></figure></p><p>现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。</p><p>现在让我们使用前面讲过的crontab -l命令列出它的全部信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ crontab -l</div><div class="line"># (crondave installed on Tue May 4 13:07:43 1999)</div><div class="line"># DT:ech the date to the console every 30 minites</div><div class="line">0,15,30,45 18-06 * * * /bin/echo `date` &gt; /dev/tty1</div><div class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</div><div class="line">30 3 1,7,14,21,26 * * /bin/find -name “core’ -exec rm &#123;&#125; \;</div></pre></td></tr></table></figure></p><h3 id="4-删除crontab文件"><a href="#4-删除crontab文件" class="headerlink" title="4). 删除crontab文件"></a>4). 删除crontab文件</h3><p>要删除crontab文件，可以用：<code>$ crontab -r</code></p><h3 id="5-恢复丢失的crontab文件"><a href="#5-恢复丢失的crontab文件" class="headerlink" title="5). 恢复丢失的crontab文件"></a>5). 恢复丢失的crontab文件</h3><p>如果不小心误删了crontab文件，假设你在自己的<code>$HOME</code>目录下还有一个备份，那么可以将其拷贝到<code>/var/spool/cron/&lt;username&gt;</code>，其中<code>&lt;username&gt;</code>是用户名。如果由于权限问题无法完成拷贝，可以用：<code>$ crontab &lt;filename&gt;</code>.其中，<code>&lt;filename&gt;</code>是你在$HOME目录中副本的文件名。</p><p>我建议你在自己的<code>$HOME</code>目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。</p><p>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<ctrl-d>，否则你将丢失crontab文件。</ctrl-d></p><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>实例1：每1分钟执行一次command<br>命令：<code>* * * * * command</code><br>实例2：每小时的第3和第15分钟执行<br>命令：<code>3,15 * * * * command</code><br>实例3：在上午8点到11点的第3和第15分钟执行<br>命令：<code>3,15 8-11 * * * command</code><br>实例4：每隔两天的上午8点到11点的第3和第15分钟执行<br>命令：<code>3,15 8-11 */2 * * command</code><br>实例5：每个星期一的上午8点到11点的第3和第15分钟执行<br>命令：<code>3,15 8-11 * * 1 command</code><br>实例6：每晚的21:30重启smb<br>命令：<code>30 21 * * * /etc/init.d/smb restart</code><br>实例7：每月1、10、22日的4 : 45重启smb<br>命令：<code>45 4 1,10,22 * * /etc/init.d/smb restart</code><br>实例8：每周六、周日的1 : 10重启smb<br>命令：<code>10 1 * * 6,0 /etc/init.d/smb restart</code><br>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb<br>命令：<code>0,30 18-23 * * * /etc/init.d/smb restart</code><br>实例10：每星期六的晚上11 : 00 pm重启smb<br>命令：<code>0 23 * * 6 /etc/init.d/smb restart</code><br>实例11：每一小时重启smb<br>命令：<code>* */1 * * * /etc/init.d/smb restart</code><br>实例12：晚上11点到早上7点之间，每隔一小时重启smb<br>命令：<code>* 23-7/1 * * * /etc/init.d/smb restart</code><br>实例13：每月的4号与每周一到周三的11点重启smb<br>命令：<code>0 11 4 * mon-wed /etc/init.d/smb restart</code><br>实例14：一月一号的4点重启smb<br>命令：<code>0 4 1 jan * /etc/init.d/smb restart</code><br>实例15：每小时执行/etc/cron.hourly目录内的脚本<br>命令：<code>01 * * * * root run-parts /etc/cron.hourly</code><br>说明：run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</p><h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><ul><li><p>注意环境变量问题, 有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p></li><li><p>在 crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程 序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这 样，系统执行任务调度时就没有问题了。</p></li><li><p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p><ol><li>脚本中涉及文件路径时写全局路径；</li><li>脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cat start_cbp.sh</span></div><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">source</span> /etc/profile</div><div class="line"><span class="built_in">export</span> RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</div><div class="line">/usr/<span class="built_in">local</span>/jboss-4.0.5/bin/run.sh -c mev &amp;</div></pre></td></tr></table></figure></li></ol></li><li><p>当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</div></pre></td></tr></table></figure></li><li><p>注意清理系统用户的邮件日志,每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。例如，可以在crontab文件中设置如下形式，忽略日志输出：<code>0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</code>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p></li><li><p>系统级任务调度与用户级任务调度,系 统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么 做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc /crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个 定时重启系统的任务也是无效的。</p></li></ul><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ol><li><p>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p></li><li><p>当crontab突然失效时，可以尝试<code>/etc/init.d/crond restart</code>解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p></li><li><p>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+\%Y\%m\%d’。</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/intval/p/5763929.html" target="_blank" rel="external">Linux定时任务Crontab命令详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;crond简介&quot;&gt;&lt;a href=&quot;#crond简介&quot; class=&quot;headerlink&quot; title=&quot;crond简介&quot;&gt;&lt;/a&gt;crond简介&lt;/h2&gt;&lt;p&gt;linux 系统则是由 cron (crond) 这个系统服务来控制的, 这个系统服务是默认启动的。
      
    
    </summary>
    
      <category term="linux" scheme="http://arvin-he.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://arvin-he.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>scrapy笔记</title>
    <link href="http://arvin-he.github.io/2018/01/16/py-scrapy2-2018-01-16/"/>
    <id>http://arvin-he.github.io/2018/01/16/py-scrapy2-2018-01-16/</id>
    <published>2018-01-16T08:01:23.000Z</published>
    <updated>2018-01-16T09:51:54.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scrapy命令行工具-command-line-tools"><a href="#scrapy命令行工具-command-line-tools" class="headerlink" title="scrapy命令行工具(command line tools)"></a>scrapy命令行工具(command line tools)</h2><h3 id="查看scrapy所有可用的命令"><a href="#查看scrapy所有可用的命令" class="headerlink" title="查看scrapy所有可用的命令"></a>查看scrapy所有可用的命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy -h</div></pre></td></tr></table></figure><h3 id="查看某个命令具体用法-以startproject为例子"><a href="#查看某个命令具体用法-以startproject为例子" class="headerlink" title="查看某个命令具体用法,以startproject为例子"></a>查看某个命令具体用法,以startproject为例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject -h</div></pre></td></tr></table></figure><h3 id="创建爬虫项目"><a href="#创建爬虫项目" class="headerlink" title="创建爬虫项目"></a>创建爬虫项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject myproject</div></pre></td></tr></table></figure><h3 id="创建一个新的spider"><a href="#创建一个新的spider" class="headerlink" title="创建一个新的spider"></a>创建一个新的spider</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy genspider mydomain mydomain.com</div></pre></td></tr></table></figure><h3 id="启动终端"><a href="#启动终端" class="headerlink" title="启动终端"></a>启动终端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scrapy shell &lt;url&gt;</div><div class="line">如: scrapy shell https://www.baidu.com</div></pre></td></tr></table></figure><h3 id="针对通用爬虫设定的一些建议"><a href="#针对通用爬虫设定的一些建议" class="headerlink" title="针对通用爬虫设定的一些建议"></a>针对通用爬虫设定的一些建议</h3><p>增加并发<br>并发是指同时处理的 request 的数量。其有全局限制和局部(每个网站)的限制。<br>Scrapy 默认的全局并发限制对同时爬取大量网站的情况并不适用，因此需要增加这个值。<br>增加全局并发数<br>CONCURRENT_REQUESTS = 100<br>设置 Log 级别：<br>LOG_LEVEL = ‘INFO’<br>禁止 cookies,禁止 cookies 能减少 CPU 使用率及 Scrapy 爬虫在内存中记录的踪迹，提高性能。<br>COOKIES_ENABLED = False<br>禁止重试,当站点响应很慢(甚至失败)时， 访问这样的站点会造成超时并重试多次。这是不必要的，同时也占用了爬虫爬取其他站点的能力。<br>RETRY_ENABLED = False<br>减小下载超时,减小下载超时能让卡住的连接能被快速的放弃并解放处理其他站点的能力。<br>DOWNLOAD_TIMEOUT = 15<br>禁止重定向,当进行通用爬取时，一般的做法是保存重定向的地址，并在之后的爬取进行解析。否则重定向循环可能会导致爬虫在某个站点耗费过多资源。<br>REDIRECT_ENABLED = False<br>启用 “Ajax Crawlable Pages” 爬取,有些站点声明其为 ajax crawlabl。这意味着该网站提供了原本只有 ajax 获取到的数据的纯 HTML 版本。网站通过两种方法声明：<br>(1)在 url 中使用#! - 这是默认的方式;<br>(2)使用特殊的 meta 标签 - 这在”main”, “index” 页面中使用。<br>Scrapy 自动解决(1)；解决(2)您需要启用 AjaxCrawlMiddleware：<br>AJAXCRAWL_ENABLED = True</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scrapy命令行工具-command-line-tools&quot;&gt;&lt;a href=&quot;#scrapy命令行工具-command-line-tools&quot; class=&quot;headerlink&quot; title=&quot;scrapy命令行工具(command line tools)&quot;
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="scrapy" scheme="http://arvin-he.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>scrapy笔记-安装</title>
    <link href="http://arvin-he.github.io/2018/01/15/py-scrapy1-2018-01-15/"/>
    <id>http://arvin-he.github.io/2018/01/15/py-scrapy1-2018-01-15/</id>
    <published>2018-01-15T09:32:19.000Z</published>
    <updated>2018-01-16T08:01:57.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="windows下scrapy安装"><a href="#windows下scrapy安装" class="headerlink" title="windows下scrapy安装"></a>windows下scrapy安装</h2><h3 id="下载依赖的第三方离线包"><a href="#下载依赖的第三方离线包" class="headerlink" title="下载依赖的第三方离线包"></a>下载依赖的第三方离线包</h3><p>到 <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted" target="_blank" rel="external">这个地址</a>下载一些在windows平台编译的第三方库.</p><ol><li>pywin32</li><li>twisted<br><strong>注意:</strong> 根据python的版本下载对应的离线包.</li></ol><h3 id="安装或更新依赖的第三方离线包"><a href="#安装或更新依赖的第三方离线包" class="headerlink" title="安装或更新依赖的第三方离线包"></a>安装或更新依赖的第三方离线包</h3><p>下载好后就安装</p><ol><li>在控制台切换目录到离线包所在的目录</li><li>安装离线包<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install pywin32</div><div class="line">pip install twisted</div></pre></td></tr></table></figure></li></ol><p>如果是更新包则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install pywin32 -U</div><div class="line">pip install twisted -U</div></pre></td></tr></table></figure></p><h3 id="安装或更新scrapy"><a href="#安装或更新scrapy" class="headerlink" title="安装或更新scrapy"></a>安装或更新scrapy</h3><p>下载安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install scrapy</div></pre></td></tr></table></figure></p><p>下载更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install scrapy -U</div></pre></td></tr></table></figure></p><h3 id="import-win32api-出现ImportError-DLL-load-failed-错误的解决方法"><a href="#import-win32api-出现ImportError-DLL-load-failed-错误的解决方法" class="headerlink" title="import win32api 出现ImportError: DLL load failed 错误的解决方法"></a>import win32api 出现ImportError: DLL load failed 错误的解决方法</h3><p>windows下使用scrapy,出现出现ImportError: DLL load failed 错误,网上解决方法大多是安装pywin32,可是安装后还是会出错.<br>之后又试了一下网上的方法:将\Lib\site-packages\pywin32_system32*拷贝至C:\Windows\System32目录下,仍然出错.<br>最后,找到一个好方法:安装pypiwin32<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pypiwin32</div></pre></td></tr></table></figure></p><p>然后再开始执行scrapy就顺利运行了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;windows下scrapy安装&quot;&gt;&lt;a href=&quot;#windows下scrapy安装&quot; class=&quot;headerlink&quot; title=&quot;windows下scrapy安装&quot;&gt;&lt;/a&gt;windows下scrapy安装&lt;/h2&gt;&lt;h3 id=&quot;下载依赖的第三方离
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="scrapy" scheme="http://arvin-he.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>python之pip常用命令</title>
    <link href="http://arvin-he.github.io/2018/01/15/py-pipcmds-2018-01-15/"/>
    <id>http://arvin-he.github.io/2018/01/15/py-pipcmds-2018-01-15/</id>
    <published>2018-01-15T09:08:06.000Z</published>
    <updated>2018-01-15T09:15:40.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pip常用命令"><a href="#pip常用命令" class="headerlink" title="pip常用命令"></a>pip常用命令</h2><h3 id="1-安装第三方库"><a href="#1-安装第三方库" class="headerlink" title="1. 安装第三方库"></a>1. 安装第三方库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install scrapy</div><div class="line">python -m pip install scrapy</div></pre></td></tr></table></figure><h3 id="2-更新第三方库"><a href="#2-更新第三方库" class="headerlink" title="2. 更新第三方库"></a>2. 更新第三方库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install scrapy -U</div></pre></td></tr></table></figure><h3 id="3-制作本地-whl安装离线包"><a href="#3-制作本地-whl安装离线包" class="headerlink" title="3. 制作本地*.whl安装离线包"></a>3. 制作本地*.whl安装离线包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip wheel pycrpyo</div></pre></td></tr></table></figure><h3 id="4-导出pip-list列表到requirements-txt"><a href="#4-导出pip-list列表到requirements-txt" class="headerlink" title="4. 导出pip list列表到requirements.txt"></a>4. 导出pip list列表到requirements.txt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip freeze &gt; requirements.txt</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pip常用命令&quot;&gt;&lt;a href=&quot;#pip常用命令&quot; class=&quot;headerlink&quot; title=&quot;pip常用命令&quot;&gt;&lt;/a&gt;pip常用命令&lt;/h2&gt;&lt;h3 id=&quot;1-安装第三方库&quot;&gt;&lt;a href=&quot;#1-安装第三方库&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>css笔记1</title>
    <link href="http://arvin-he.github.io/2018/01/11/css-note1-2018-01-11/"/>
    <id>http://arvin-he.github.io/2018/01/11/css-note1-2018-01-11/</id>
    <published>2018-01-11T13:19:50.000Z</published>
    <updated>2018-01-15T09:47:58.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS样式优先级"><a href="#CSS样式优先级" class="headerlink" title="CSS样式优先级"></a>CSS样式优先级</h3><p>*(通配符) &lt; tag(标签) &lt; class &lt; 行间<br>style与class<br>元素.style.属性 = xxx 是修改行间样式<br>之后再修改className不会有效果</p><p>建议:<br>要么统一用style,要么统一用className,混用则容易产生错乱,也很难排查问题.</p><p>行为,样式,结构三者分离</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CSS样式优先级&quot;&gt;&lt;a href=&quot;#CSS样式优先级&quot; class=&quot;headerlink&quot; title=&quot;CSS样式优先级&quot;&gt;&lt;/a&gt;CSS样式优先级&lt;/h3&gt;&lt;p&gt;*(通配符) &amp;lt; tag(标签) &amp;lt; class &amp;lt; 行间&lt;br&gt;styl
      
    
    </summary>
    
      <category term="web" scheme="http://arvin-he.github.io/categories/web/"/>
    
    
      <category term="css" scheme="http://arvin-he.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>selenium-phatomjs使用</title>
    <link href="http://arvin-he.github.io/2017/12/11/selenium-phatomjs-2017-12-11/"/>
    <id>http://arvin-he.github.io/2017/12/11/selenium-phatomjs-2017-12-11/</id>
    <published>2017-12-11T12:42:16.000Z</published>
    <updated>2018-01-15T09:47:58.285Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用selenium和phantomjs爬取动态网页"><a href="#使用selenium和phantomjs爬取动态网页" class="headerlink" title="使用selenium和phantomjs爬取动态网页"></a>使用selenium和phantomjs爬取动态网页</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line">url = <span class="string">"http://www.dangniao.com/mh/22996/392953.html"</span></div><div class="line">browser = webdriver.PhantomJS(<span class="string">"/usr/local/mysoft/phantomjs-2.1.1/bin/phantomjs"</span>)</div><div class="line">browser.get(url)</div><div class="line"><span class="comment"># 模拟用户点击</span></div><div class="line">browser.find_element_by_class_name(<span class="string">"zsxiaye"</span>).click()</div><div class="line">src = browser.find_element_by_css_selector(<span class="string">"#wdwailian img"</span>).get_attribute(<span class="string">"src"</span>)</div></pre></td></tr></table></figure><h3 id="常用的phantomJS配置选项"><a href="#常用的phantomJS配置选项" class="headerlink" title="常用的phantomJS配置选项"></a>常用的phantomJS配置选项</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"><span class="comment"># 引入配置对象DesiredCapabilities</span></div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</div><div class="line">dcap = dict(DesiredCapabilities.PHANTOMJS)</div><div class="line"><span class="comment">#从USER_AGENTS列表中随机选一个浏览器头，伪装浏览器</span></div><div class="line">dcap[<span class="string">"phantomjs.page.settings.userAgent"</span>] = (random.choice(USER_AGENTS))</div><div class="line"><span class="comment"># 不载入图片，爬页面速度会快很多</span></div><div class="line">dcap[<span class="string">"phantomjs.page.settings.loadImages"</span>] = <span class="keyword">False</span></div><div class="line"><span class="comment"># 设置代理</span></div><div class="line">service_args = [<span class="string">'--proxy=127.0.0.1:9999'</span>,<span class="string">'--proxy-type=socks5'</span>]</div><div class="line"><span class="comment">#打开带配置信息的phantomJS浏览器</span></div><div class="line">driver = webdriver.PhantomJS(phantomjs_driver_path, desired_capabilities=dcap,service_args=service_args)                </div><div class="line"><span class="comment"># 隐式等待5秒，可以自己调节</span></div><div class="line">driver.implicitly_wait(<span class="number">5</span>)</div><div class="line"><span class="comment"># 设置10秒页面超时返回，类似于requests.get()的timeout选项，driver.get()没有timeout选项</span></div><div class="line"><span class="comment"># 以前遇到过driver.get(url)一直不返回，但也不报错的问题，这时程序会卡住，设置超时选项能解决这个问题。</span></div><div class="line">driver.set_page_load_timeout(<span class="number">10</span>)</div><div class="line"><span class="comment"># 设置10秒脚本超时时间</span></div><div class="line">driver.set_script_timeout(<span class="number">10</span>)</div></pre></td></tr></table></figure><h3 id="phantomJS的并发问题"><a href="#phantomJS的并发问题" class="headerlink" title="phantomJS的并发问题"></a>phantomJS的并发问题</h3><p>phantomJS本身在多线程方面还有很多bug，建议使用多进程,关于多进程，推荐使用multiprocessing库，简洁、高效.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line">pool = Pool(<span class="number">8</span>)</div><div class="line">data_list = pool.map(get, url_list)</div><div class="line">pool.close()</div><div class="line">pool.join()</div></pre></td></tr></table></figure></p><h3 id="phantomJS进程不自动退出问题"><a href="#phantomJS进程不自动退出问题" class="headerlink" title="phantomJS进程不自动退出问题"></a>phantomJS进程不自动退出问题</h3><p>主程序退出后，selenium不保证phantomJS也成功退出，最好手动关闭phantomJS进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    self.driver.get(url)</div><div class="line">    self.wait_()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">    <span class="comment"># 手动关闭phantomjs进程</span></div><div class="line">    self.driver.quit()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用selenium和phantomjs爬取动态网页&quot;&gt;&lt;a href=&quot;#使用selenium和phantomjs爬取动态网页&quot; class=&quot;headerlink&quot; title=&quot;使用selenium和phantomjs爬取动态网页&quot;&gt;&lt;/a&gt;使用seleni
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>jQuery笔记</title>
    <link href="http://arvin-he.github.io/2017/12/08/jQuery-notes1-2017-12-08/"/>
    <id>http://arvin-he.github.io/2017/12/08/jQuery-notes1-2017-12-08/</id>
    <published>2017-12-08T09:31:58.000Z</published>
    <updated>2017-12-08T09:59:27.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h3><p>jQuery是JavaScript世界中使用最广泛的一个库。<br>jQuery能帮我们干这些事情：</p><ul><li>消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；</li><li>简洁的操作DOM的方法：写$(‘#test’)肯定比document.getElementById(‘test’)来得简洁；</li><li>轻松实现动画、修改CSS等各种操作。<br>jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！</li></ul><p>目前jQuery有1.x和2.x两个主要版本，区别在于2.x移除了对古老的IE 6、7、8的支持，<br>因此2.x的代码更精简。选择哪个版本主要取决于你是否想支持IE 6~8。<br>jQuery只是一个jquery-xxx.js文件，但你会看到有compressed（已压缩）和uncompressed（未压缩）两种版本，使用时完全一样，<br>但如果你想深入研究jQuery源码，那就用uncompressed版本。</p><h3 id="jQuery使用"><a href="#jQuery使用" class="headerlink" title="jQuery使用"></a>jQuery使用</h3><p>$是著名的jQuery符号。jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.jQuery; <span class="comment">// jQuery(selector, context)</span></div><div class="line"><span class="built_in">window</span>.$; <span class="comment">// jQuery(selector, context)</span></div><div class="line">$ === jQuery; <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span>($); <span class="comment">// 'function'</span></div></pre></td></tr></table></figure></p><p>$本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性。</p><p><strong>注意:</strong> 你看到的$函数名可能不是jQuery(selector, context)，因为很多JavaScript压缩工具可以对函数名和参数改名，<br>压缩过的jQuery源码$函数可能变成a(b, c)。这也被叫做代码混淆,也起到一定的安全作用.</p><p>绝大多数时候，直接用$,但是，如果$这个变量被占用了，而且还不能改，那我们就只能让jQuery把$变量交出来，然后就只能使用jQuery这个变量.</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>选择器是jQuery的核心。一个选择器写出来类似$(‘#dom-id’)。<br>Query的选择器就是帮助我们快速定位到一个或多个DOM节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按ID查找,注意: #abc以#开头。返回的对象是jQuery对象。</span></div><div class="line"><span class="comment">// 查找&lt;div id="abc"&gt;:</span></div><div class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 按tag查找</span></div><div class="line"><span class="keyword">var</span> ps = $(<span class="string">'p'</span>); <span class="comment">// 返回所有&lt;p&gt;节点</span></div><div class="line">ps.length; <span class="comment">// 数一数页面有多少个&lt;p&gt;节点</span></div><div class="line"></div><div class="line"><span class="comment">// 按class查找, 按class查找注意在class名称前加一个.</span></div><div class="line"><span class="keyword">var</span> a = $(<span class="string">'.red'</span>); <span class="comment">// 所有节点包含`class="red"`都将返回</span></div><div class="line"><span class="comment">// 例如:</span></div><div class="line"><span class="comment">// &lt;div class="red"&gt;...&lt;/div&gt;</span></div><div class="line"><span class="comment">// &lt;p class="green red"&gt;...&lt;/p&gt;</span></div><div class="line"><span class="comment">// 节点有多个class，我们可以查找同时包含red和green的节点：</span></div><div class="line"><span class="keyword">var</span> a = $(<span class="string">'.red.green'</span>); <span class="comment">// 注意没有空格！</span></div><div class="line"><span class="comment">// 符合条件的节点：</span></div><div class="line"><span class="comment">// &lt;div class="red green"&gt;...&lt;/div&gt;</span></div><div class="line"><span class="comment">// &lt;div class="blue green red"&gt;...&lt;/div&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 按属性查找</span></div><div class="line"><span class="keyword">var</span> email = $(<span class="string">'[name=email]'</span>); <span class="comment">// 找出&lt;??? name="email"&gt;</span></div><div class="line"><span class="keyword">var</span> icons = $(<span class="string">'[name^=icon]'</span>); <span class="comment">// 找出所有name属性值以icon开头的DOM</span></div><div class="line"><span class="keyword">var</span> names = $(<span class="string">'[name$=with]'</span>); <span class="comment">// 找出所有name属性值以with结尾的DOM</span></div><div class="line"><span class="keyword">var</span> icons = $(<span class="string">'[class^="icon-"]'</span>); <span class="comment">// 找出所有class包含至少一个以`icon-`开头的DOM</span></div></pre></td></tr></table></figure></p><p>组合查找<br><code>var emailInput = $(&#39;input[name=email]&#39;); // 不会找出&lt;div name=&quot;email&quot;&gt;</code><br><code>var tr = $(&#39;tr.red&#39;); // 找出&lt;tr class=&quot;red ...&quot;&gt;...&lt;/tr&gt;</code></p><p>多项选择器<br>多项选择器就是把多个选择器用,组合起来一块选：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'p,div'</span>); <span class="comment">// 把&lt;p&gt;和&lt;div&gt;都选出来</span></div><div class="line">$(<span class="string">'p.red,p.green'</span>); <span class="comment">// 把&lt;p class="red"&gt;和&lt;p class="green"&gt;都选出来</span></div></pre></td></tr></table></figure></p><p>总之jQuery的选择器不会返回undefined或者null，这样的好处是你不必在下一行判断if (div === undefined)。<br>jQuery对象和DOM对象之间可以互相转化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>); <span class="comment">// jQuery对象</span></div><div class="line"><span class="keyword">var</span> divDom = div.get(<span class="number">0</span>); <span class="comment">// 假设存在div，获取第1个DOM元素</span></div><div class="line"><span class="keyword">var</span> another = $(divDom); <span class="comment">// 重新把DOM包装为jQuery对象</span></div></pre></td></tr></table></figure></p><p>通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。<br>如果你拿到了一个DOM对象，那可以简单地调用$(aDomObject)把它变成jQuery对象，这样就可以方便地使用jQuery的API了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jQuery介绍&quot;&gt;&lt;a href=&quot;#jQuery介绍&quot; class=&quot;headerlink&quot; title=&quot;jQuery介绍&quot;&gt;&lt;/a&gt;jQuery介绍&lt;/h3&gt;&lt;p&gt;jQuery是JavaScript世界中使用最广泛的一个库。&lt;br&gt;jQuery能帮我们干这
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>javascript之DOM操作</title>
    <link href="http://arvin-he.github.io/2017/12/08/js-dom-2017-12-08/"/>
    <id>http://arvin-he.github.io/2017/12/08/js-dom-2017-12-08/</id>
    <published>2017-12-08T08:00:15.000Z</published>
    <updated>2017-12-08T09:30:35.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p>DOM是一个树形结构, 常用操作有:更新, 遍历, 添加, 删除</p><p>获取dom节点的方法:<br>document.getElementById()<br>document.getElementsByTagName()<br>document.getElementsByClassName() //CSS选择器<br>可以连续调用: <code>var trs = document.getElementById(&#39;test-table&#39;).getElementsByTagName(&#39;tr&#39;);</code></p><p>使用selector语法:<br>querySelector()<br>querySelectorAll()<br><strong>注意:</strong> 低版本的IE&lt;8不支持querySelector和querySelectorAll。IE8仅有限支持。</p><p>根节点Document已经自动绑定为全局变量document。<br>严格地讲，我们这里的DOM节点是指Element，但是DOM节点实际上是Node，<br>在HTML中，Node包括Element、Comment、CDATA_SECTION等很多种，以及根节点Document类型，但是，绝大多数时候我们只关心Element.</p><h3 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h3><p>直接修改节点的文本，方法有两种:</p><ol><li><p>修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树.<br><strong>注意:</strong> 在写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。</p></li><li><p>修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签.<br>innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意IE&lt;9不支持textContent。</p></li></ol><p>DOM节点的style属性对应所有的CSS，可以直接获取或设置。<br><strong>注意:</strong>CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，需要在JavaScript中改写为驼峰式命名fontSize.</p><h3 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h3><p>两个办法可以插入新的节点</p><ol><li>使用appendChild，把一个子节点添加到父节点的最后一个子节点</li><li>使用insertBefore, 使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。</li></ol><h3 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h3><ol><li>调用父节点的removeChild把当前节点删掉<br><strong>注意:</strong>删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置</li></ol><p>当遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个<strong>只读</strong>属性，并且它在子节点变化时会实时更新<br>删除多个节点时，要注意children属性时刻都在变化, 容易造成index溢出.</p><h3 id="表单操作"><a href="#表单操作" class="headerlink" title="表单操作"></a>表单操作</h3><p>HTML表单的输入控件主要有以下几种：</p><ul><li>文本框，对应的<input type="text">，用于输入文本；</li><li>口令框，对应的<input type="password">，用于输入口令；</li><li>单选框，对应的<input type="radio">，用于选择一项；</li><li>复选框，对应的<input type="checkbox">，用于选择多项；</li><li>下拉框，对应的<select>，用于选择一项；</select></li><li>隐藏文本，对应的<input type="hidden">，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li></ul><p>直接调用value获得对应的用户输入值, <code>input.value; // &#39;用户输入的值&#39;</code><br>对于单选框和复选框，value属性返回的永远是HTML预设的值，要获得的实际是用户是否“勾上了”选项，应该用checked判断.</p><h3 id="HTML5控件"><a href="#HTML5控件" class="headerlink" title="HTML5控件"></a>HTML5控件</h3><p>HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用<code>&lt;input&gt;</code>标签.<br>不支持HTML5的浏览器无法识别新的控件，会把它们当做type=”text”来显示。支持HTML5的浏览器将获得格式化的字符串</p><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><p>第一种方式:通过<code>&lt;form&gt;</code>元素的submit()方法提交一个表单, 这种方式的缺点是扰乱了浏览器对form的正常提交。<br>浏览器默认点击<code>&lt;button type=&quot;submit&quot;&gt;</code>或用户在最后一个输入框按回车键时提交表单。</p><p>第二种方式:响应<code>&lt;form&gt;</code>本身的onsubmit事件，在提交form时作修改.<br>出于安全考虑，提交表单时不传输明文口令，而是口令的MD5, 口令框的显示会突然从几个<code>*</code>变成32个<code>*</code>,(MD5有32个字符)<br>要想不改变用户的输入，可以利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现.</p><p>注意到id为md5-password的<code>&lt;input&gt;</code>标记了name=”password”，而用户输入的id为input-password的<code>&lt;input&gt;</code>没有name属性。<br>没有name属性的<code>&lt;input&gt;</code>的数据不会被提交。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code><br><strong>注意：</strong> 当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的enctype必须指定为multipart/form-data，method必须指定为post，<br>这样浏览器才能正确编码并以multipart/form-data格式发送表单的数据。<br>出于安全考虑，浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径</p><p>File API<br>随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。<br>HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，<br>也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行.<br>在JavaScript中，执行多任务实际上都是异步调用.</p><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。<br>通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest,<br>不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性.</p><h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><p>由于浏览器的同源策略,默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致,<br>即域名,协议和端口号要一致.有的浏览器可能允许端口不同.<br>那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：<br>一是: 通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。<br>二是:通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器,代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。<br>第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源.JSONP通常以函数调用的形式返回</p><p>CORS(Cross-Origin Resource Sharing): 是HTML5规范定义的如何跨域访问资源<br>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。<br>假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。<br>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了.<br>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。<br><code>job1.then(job2).then(job3).catch(handleError);</code> ,其中，job1、job2和job3都是Promise对象。</p><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。<br>没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。<br>有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DOM操作&quot;&gt;&lt;a href=&quot;#DOM操作&quot; class=&quot;headerlink&quot; title=&quot;DOM操作&quot;&gt;&lt;/a&gt;DOM操作&lt;/h3&gt;&lt;p&gt;DOM是一个树形结构, 常用操作有:更新, 遍历, 添加, 删除&lt;/p&gt;
&lt;p&gt;获取dom节点的方法:&lt;br&gt;doc
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Appium笔记</title>
    <link href="http://arvin-he.github.io/2017/12/08/appium-notes1-2017-12-08/"/>
    <id>http://arvin-he.github.io/2017/12/08/appium-notes1-2017-12-08/</id>
    <published>2017-12-08T06:22:04.000Z</published>
    <updated>2018-01-25T08:15:52.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于appium"><a href="#关于appium" class="headerlink" title="关于appium"></a>关于appium</h3><p>手机app自动化测试，现有支持的app的手机平台（Andriod和IOS）, 选择Appium工具。因为Andriod和IOS，Appium都支持。</p><p>web自动化测试的路线是这样的：<br>编程语言基础—&gt;测试框架—&gt;webdriver API（selenium2）—&gt;开发自动化测试项目。</p><p>移动自动化的测试的路线则是这样的：<br>编程语言基础—&gt;测试框架—&gt;android/IOS开发测试基础—&gt;appium API —&gt;开发移动自动化项目。</p><p>appium就是node的其中一个开源项目，appiun server端是用node实现，遵循了REST架构，所以appium可以用node的包管理工具npm来进行安装。</p><h3 id="安装appium"><a href="#安装appium" class="headerlink" title="安装appium"></a>安装appium</h3><ol><li>使用淘宝镜像安装, 输入”cnpm install -g appium” 即可在线安装.</li><li>安装appium的客户端，基于python的开发环境，可以用pip安装appium客户端, 输入”pip install Appium-Python-Client”，</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于appium&quot;&gt;&lt;a href=&quot;#关于appium&quot; class=&quot;headerlink&quot; title=&quot;关于appium&quot;&gt;&lt;/a&gt;关于appium&lt;/h3&gt;&lt;p&gt;手机app自动化测试，现有支持的app的手机平台（Andriod和IOS）, 选择Appiu
      
    
    </summary>
    
      <category term="node" scheme="http://arvin-he.github.io/categories/node/"/>
    
    
      <category term="node" scheme="http://arvin-he.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>javascript 标准对象</title>
    <link href="http://arvin-he.github.io/2017/12/08/js-object-2017-12-08/"/>
    <id>http://arvin-he.github.io/2017/12/08/js-object-2017-12-08/</id>
    <published>2017-12-08T01:04:29.000Z</published>
    <updated>2017-12-08T01:08:46.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="javascript标准对象"><a href="#javascript标准对象" class="headerlink" title="javascript标准对象"></a>javascript标准对象</h3><ol><li>不要使用new Number()、new Boolean()、new String()创建包装对象；</li><li>用parseInt()或parseFloat()来转换任意类型到number；</li><li>用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；</li><li>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</li><li>typeof操作符可以判断出number、boolean、string、function和undefined；</li><li>判断Array要使用Array.isArray(arr)；</li><li>判断null请使用myVar === null；</li><li>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</li><li>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</li><li>不是任何对象都有toString()方法, null和undefined就没有！这两个特殊值要除外，虽然null还伪装成了object类型。</li><li>number对象调用toString()需要特殊处理,<code>123..toString(); // &#39;123&#39;, 注意是两个点！</code> 或 <code>(123).toString(); // &#39;123&#39;</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;javascript标准对象&quot;&gt;&lt;a href=&quot;#javascript标准对象&quot; class=&quot;headerlink&quot; title=&quot;javascript标准对象&quot;&gt;&lt;/a&gt;javascript标准对象&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;不要使用new Number()
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>selenium笔记</title>
    <link href="http://arvin-he.github.io/2017/12/07/selenium-notes1-2017-12-07/"/>
    <id>http://arvin-he.github.io/2017/12/07/selenium-notes1-2017-12-07/</id>
    <published>2017-12-07T13:39:06.000Z</published>
    <updated>2017-12-08T06:01:11.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="selenium使用"><a href="#selenium使用" class="headerlink" title="selenium使用"></a>selenium使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line">driver = webdriver.Firefox()</div><div class="line">driver.get(<span class="string">"http://www.python.org"</span>)</div><div class="line"><span class="keyword">assert</span> <span class="string">"Python"</span> <span class="keyword">in</span> driver.title</div><div class="line">elem = driver.find_element_by_name(<span class="string">"q"</span>)</div><div class="line">elem.send_keys(<span class="string">"pycon"</span>)</div><div class="line">elem.send_keys(Keys.RETURN)</div><div class="line"><span class="keyword">assert</span> <span class="string">"No results found."</span> <span class="keyword">not</span> <span class="keyword">in</span> driver.page_source</div><div class="line">driver.close()</div></pre></td></tr></table></figure><h3 id="使用selenium登陆淘宝"><a href="#使用selenium登陆淘宝" class="headerlink" title="使用selenium登陆淘宝"></a>使用selenium登陆淘宝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</div><div class="line"></div><div class="line">driver = webdriver.Firefox()</div><div class="line">driver.get(<span class="string">'https://www.taobao.com/'</span>)</div><div class="line"><span class="keyword">assert</span> <span class="string">"淘宝"</span> <span class="keyword">in</span> driver.title</div><div class="line">elem = driver.find_element_by_class_name(<span class="string">'member-ft'</span>)</div><div class="line">tags = elem.find_elements_by_tag_name(<span class="string">'a'</span>)</div><div class="line">login_url = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> tags:</div><div class="line">    <span class="keyword">if</span> <span class="string">'login'</span> <span class="keyword">in</span> tag.get_attribute(<span class="string">'href'</span>):</div><div class="line">        login_url = tag.get_attribute(<span class="string">'href'</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> login_url:</div><div class="line">    driver.get(login_url)</div><div class="line">    driver.find_element_by_id(<span class="string">'J_Quick2Static'</span>).click()</div><div class="line">    elem = driver.find_element_by_id(<span class="string">'TPL_username_1'</span>)</div><div class="line">    elem.send_keys(<span class="string">'淘宝账号'</span>)</div><div class="line">    elem2 = driver.find_element_by_id(<span class="string">'TPL_password_1'</span>)</div><div class="line">    elem2.send_keys(<span class="string">'淘宝账号密码'</span>)</div><div class="line">    driver.find_element_by_id(<span class="string">'J_SubmitStatic'</span>).click()</div><div class="line">    <span class="keyword">assert</span> <span class="string">"No results found."</span> <span class="keyword">not</span> <span class="keyword">in</span> driver.page_source</div><div class="line">    cookies = driver.get_cookies()</div><div class="line">    pprint(cookies)</div><div class="line"><span class="comment"># driver.close()</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;selenium使用&quot;&gt;&lt;a href=&quot;#selenium使用&quot; class=&quot;headerlink&quot; title=&quot;selenium使用&quot;&gt;&lt;/a&gt;selenium使用&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>javascript笔记(二)</title>
    <link href="http://arvin-he.github.io/2017/12/04/js-notes2-2017-12-04/"/>
    <id>http://arvin-he.github.io/2017/12/04/js-notes2-2017-12-04/</id>
    <published>2017-12-04T01:34:52.000Z</published>
    <updated>2017-12-08T07:56:05.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ol><li>局部作用域<br>var 声明局部变量,生命周期在函数内部. 而JavaScript的变量作用域实际上是函数内部，以及变量提升的作用,<br>我们在for循环等语句块中是无法定义具有局部作用域的变量的：<br>为了解决块级作用域，(如for循环), ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：</li></ol><ol><li>全局作用域<br>不在任何函数内定义的变量就具有全局作用域。<br>JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的course属性.<br>以变量方式<code>var foo = function () {}</code>定义的函数实际上也是一个全局变量，<br>因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象.<br>JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。</li></ol><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。<br>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个自定义的全局变量中.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></div><div class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</div><div class="line"><span class="comment">// 其他变量:</span></div><div class="line">MYAPP.name = <span class="string">'myapp'</span>;</div><div class="line">MYAPP.version = <span class="number">1.0</span>;</div><div class="line"><span class="comment">// 其他函数:</span></div><div class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示这是一个常量，不要修改它的值：<br>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。<br>解构赋值在很多时候可以大大简化代码. 但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行<br><strong>注意:</strong></p><ol><li>对数组元素进行解构赋值时，多个变量要用[]括起来。</li><li>如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致</li><li>如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性</li><li>对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的</li><li>使用解构赋值对对象属性进行赋值时，如果要使用的变量名和属性名不一致，可以用下面的语法获取</li><li>解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题</li><li>如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误, 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>];</div><div class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">'hello'</span>, [<span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]];</div><div class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</div><div class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</div><div class="line"><span class="comment">// 把passport属性赋值给变量id:</span></div><div class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person;</div><div class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></div><div class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</div><div class="line"><span class="keyword">var</span> x, y;</div><div class="line"><span class="comment">// 解构赋值:</span></div><div class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;; <span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></div><div class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;); <span class="comment">//正确</span></div></pre></td></tr></table></figure></li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个this怎么理解？<br>在一个方法内部，this是一个特殊变量，它始终指向当前的调用对象.<br>JavaScript的函数内部如果调用了this，那么这个this到底指向谁？<br>答案是，视情况而定,根据当前调用者来确定. 且必须保证this指向正确，必须用obj.xxx()的形式调用！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></div><div class="line">fn(); <span class="comment">// NaN</span></div><div class="line"></div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> fn = xiaoming.age;</div><div class="line">fn(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></div></pre></td></tr></table></figure></p><p>这是一个设计错误，ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误.<br>这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。<br>修复的办法:用一个that变量首先捕获this,用<code>var that = this;</code>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p><p>另一个解决办法:apply<br>指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数:<br>第一个参数就是需要绑定的this变量，<br>第二个参数是Array，表示函数本身的参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    age: getAge</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); <span class="comment">// 25</span></div><div class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure></p><p>另一个与apply()类似的方法是call()，唯一区别是：<br>apply()把参数打包成Array再传入；<br>call()把参数按顺序传入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p><p>对普通函数调用，我们通常把this绑定为null。</p><h3 id="原型链继承方式"><a href="#原型链继承方式" class="headerlink" title="原型链继承方式"></a>原型链继承方式</h3><p>JavaScript的原型继承实现方式就是：</p><ol><li>定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；</li><li>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；</li><li>继续在新的构造函数的原型上定义新方法。</li></ol><h3 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h3><p>从ES6开始新的关键字class正式被引入到JavaScript中,class的目的就是让定义类更简单。<br>类的继承使用通过extends来实现.</p><h3 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h3><p>JavaScript可以获取浏览器提供的很多对象，并进行操作。<br>常用的浏览器对象有: window, navigator, screen, location, document, history</p><p>window对象充当全局作用域，且表示浏览器窗口. 兼容性：IE&lt;=8不支持。<br>有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。<br>内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。<br>outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。</p><p>navigator对象表示浏览器的信息，最常用的属性包括：<br>navigator.appName：浏览器名称；<br>navigator.appVersion：浏览器版本；<br>navigator.language：浏览器设置的语言；<br>navigator.platform：操作系统类型；<br>navigator.userAgent：浏览器设定的User-Agent字符串。<br><strong>注意:</strong> navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的.</p><p>screen对象表示屏幕的信息，常用的属性有：<br>screen.width：屏幕宽度，以像素为单位；<br>screen.height：屏幕高度，以像素为单位；<br>screen.colorDepth：返回颜色位数，如8、16、24。</p><p>location对象表示当前页面的URL信息<br>location.protocol; // ‘http’<br>location.host; // ‘www.example.com’<br>location.port; // ‘8080’<br>location.pathname; // ‘/path/index.html’<br>location.search; // ‘?a=1&amp;b=2’<br>location.hash; // ‘TOP’<br>要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，则调用location.reload()方法.</p><p>document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。<br>document的title属性是从HTML文档中的<code>&lt;title&gt;xxx&lt;/title&gt;</code>读取的，但是可以动态改变.<br>document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点.<br>document对象还有一个cookie属性，通过document.cookie读取到当前页面的Cookie.<br>由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，<br>因为在HTML页面中引入第三方的JavaScript代码是允许的,为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，<br>设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。<br>为确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。</p><p>history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。<br>新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。<br>任何情况，你都不应该使用history这个对象了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><img src="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499832124d97d77b00706461f9daf1a390b75ade1000" alt="廖雪峰官方网站"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量作用域&quot;&gt;&lt;a href=&quot;#变量作用域&quot; class=&quot;headerlink&quot; title=&quot;变量作用域&quot;&gt;&lt;/a&gt;变量作用域&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;局部作用域&lt;br&gt;var 声明局部变量,生命周期在函数内部. 而JavaScript的变量作用域实际上是
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>proxy一些知识</title>
    <link href="http://arvin-he.github.io/2017/11/28/proxy-2017-11-28/"/>
    <id>http://arvin-he.github.io/2017/11/28/proxy-2017-11-28/</id>
    <published>2017-11-28T14:04:44.000Z</published>
    <updated>2017-11-29T01:09:30.919Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理有什么用处"><a href="#代理有什么用处" class="headerlink" title="代理有什么用处"></a>代理有什么用处</h3><ul><li>对游戏，通过第三方代理，可以提高游戏流畅速度</li><li>对师生，通过代理访问国外论文，获取最新研究成果</li><li>对开发者，通过代理爬取采集大数据，防止被屏蔽</li><li>对极客，通过代理(高匿)隐藏访问痕迹，防止被跟踪</li><li>对个人，通过代理自由上网保护隐私，了解外面的世界</li></ul><h3 id="代理应具有哪些信息"><a href="#代理应具有哪些信息" class="headerlink" title="代理应具有哪些信息"></a>代理应具有哪些信息</h3><ul><li>IP：Port（IP和端口号，默认必选）</li><li>类型（协议类型，HTTP/HTTPS/Socks4/Socks5，默认必选）</li><li>国家（例如：中国/美国/日本等）</li><li>响应时间（ping代理服务器的时间，单位秒）</li><li>传输速度（数据请求和返回的时间，单位秒）</li><li>验证日期（验证代理可用的时间）</li><li>检测成功率（成功率 = 代理检测的可用次数 / 检测总数，衡量代理的可靠性）</li></ul><h3 id="什么是代理的类型"><a href="#什么是代理的类型" class="headerlink" title="什么是代理的类型"></a>什么是代理的类型</h3><p>代理的类型，具体是指代理协议类型，常见的有HTTP、HTTPS、Socks4、Socks5等四种协议类型</p><ul><li>HTTP，全称超文本传输协议（HyperText Transfer Protocol)，是互联网数据传输的一种协议；</li><li>HTTPS，是在HTTP协议基础上加入了SSL加密协议，以https开头，确保传输过程的数据安全；</li><li>Socks4，是全能代理，支持HTTP，FTP等多种协议请求，传输层只支持UDP协议，数据可能会丢失；</li><li>Socks5，类似于Socks4，差别是传输层同时支持UDP和TCP协议，支持可靠的身份验证等机制。<br>Socks4和Socks5，都是通过代理IP:Port利用底层传输协议进行网络通信，因此都可视为匿名代理。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>HTTP：适合一般的网页浏览，例如：浏览新闻，观看视频等；</li><li>HTTPS：适合一些需要安全验证的场合，例如：网银登录，购物付款等；</li><li>Socks4：适合一些对数据完整性不高的场合，例如：网络电话，视频聊天等；</li><li>Socks5：适合对数据完整性较高的场合，例如：网络游戏，微信接入，移动支付等。</li></ul><h3 id="HTTP和Socks代理有何区别？"><a href="#HTTP和Socks代理有何区别？" class="headerlink" title="HTTP和Socks代理有何区别？"></a>HTTP和Socks代理有何区别？</h3><p>HTTP和HTTPS，都是基于可靠的TCP/IP协议，对传输数据都有校验，保障数据不丢失。<br>Socks4和Socks5，分别是基于UDP，UDP和TCP传输协议，通过代理IP:Port请求转发数据。<br>HTTP和HTTPS是在Socks基础上，进行了数据封装，只专注业务，不必考虑底层的数据传输。<br>Socks是基于IP:Port套接字进行底层的数据传输，支持多种HTTP、FTP、ICMP等上层协议。<br>适用场景：对于普通用户，一般使用HTTP/HTTPS即可；对于开发者用户，推荐Socks，如微信开发。</p><h3 id="什么是代理的匿名度"><a href="#什么是代理的匿名度" class="headerlink" title="什么是代理的匿名度"></a>什么是代理的匿名度</h3><p>代理的匿名度，一般分为透明，匿名，高匿，其中匿名又分为普通匿名和欺骗匿名。</p><ul><li>透明，代理服务器只是转发请求，并把你的真实IP地址传给服务器，不会隐藏或改变你的IP；</li><li>普通匿名，代理服务器转发请求，并把代理服务器的IP地址传给服务器，隐藏了你的真实IP；</li><li>欺骗匿名，代理服务器转发请求，并编造了一个假的IP地址传给服务器，隐藏了你的真实IP；</li><li>高匿，代理服务器转发请求，并完全隐藏了你的真实IP和其它信息，就像另外一个人在访问。</li></ul><p>代理匿名度优先级： 高匿 &gt; 欺骗代理 &gt; 普通匿名 &gt; 透明 &gt; 不使用代理</p><p>如果不使用代理，你的请求数据，真实IP地址，以及其它信息（如浏览器参数，cookie等），都会毫无保留的暴露给了远程服务器，<br>他人可以利用这些访问痕迹，跟踪你的位置（如城市/地区/街道），以及盗取你请求数据中的敏感信息（如银行卡帐号和密码，QQ号和密码等），以及你的访问喜好和习惯等个人隐私。</p><p>使用代理(高匿)和加密协议(HTTPS)，可以大大提高您访问网络的安全性，有效保护您的个人隐私等敏感信息</p><h3 id="高匿、匿名和透明有何区别？"><a href="#高匿、匿名和透明有何区别？" class="headerlink" title="高匿、匿名和透明有何区别？"></a>高匿、匿名和透明有何区别？</h3><p>高匿，匿名和透明，是针对隐藏用户请求数据而言，例如：隐藏IP地址，隐藏浏览器参数，Cookie等<br>对于一般的访问网络，一共有五种方式：无代理、透明、普通匿名、欺骗匿名、高匿（Elite）<br>五种方式及判断原理如下：</p><ol><li><p>无代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 您的真实IP</div><div class="line">HTTP_VIA = 没数值或不显示</div><div class="line">HTTP_X_FORWARDED_FOR = 没数值或不显示</div></pre></td></tr></table></figure></li><li><p>透明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 最后一个代理服务器IP</div><div class="line">HTTP_VIA = 代理服务器IP</div><div class="line">HTTP_X_FORWARDED_FOR = 您的真实IP，经过多个代理服务器时，这个值类似：123.57.78.101, 120.24.177.48, 47.88.76.11</div></pre></td></tr></table></figure></li><li><p>普通匿名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 最后一个代理服务器IP</div><div class="line">HTTP_VIA = 代理服务器IP</div><div class="line">HTTP_X_FORWARDED_FOR = 代理服务器IP，经过多个代理服务器时，这个值类似：123.57.78.101, 120.24.177.48, 47.88.76.11</div></pre></td></tr></table></figure></li><li><p>欺骗匿名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 最后一个代理服务器IP</div><div class="line">HTTP_VIA = 代理服务器IP</div><div class="line">HTTP_X_FORWARDED_FOR = 随机的IP，经过多个代理服务器时，这个值类似：123.57.78.101, 120.24.177.48, 47.88.76.11</div></pre></td></tr></table></figure></li><li><p>高匿(Elite)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 代理服务器IP</div><div class="line">HTTP_VIA = 没数值或不显示</div><div class="line">HTTP_X_FORWARDED_FOR = 没数值或不显示</div></pre></td></tr></table></figure></li></ol><h3 id="代理的国家-地区"><a href="#代理的国家-地区" class="headerlink" title="代理的国家/地区"></a>代理的国家/地区</h3><p>代理的国家，具体是指代理IP所属的国家，例如：中国，美国，英国，日本，韩国，俄罗斯等<br>代理的地区，具体是指代理IP所属国家的地区，只支持中国34个省市(含港澳台)，例如：中国北京，中国香港</p><h3 id="代理的运营商"><a href="#代理的运营商" class="headerlink" title="代理的运营商"></a>代理的运营商</h3><p>代理的运营商，具体是指提供代理服务器的运营商，因为大部分的的代理IP，是由电信运营商搭建提供。<br>代理的运营商，主要有移动、铁通、联通、网通、电信，以及其它（主要是一些大公司和港澳台电信运营商，例如：阿里巴巴、中华电信、腾讯集团、鹏博士、教育网等）</p><h3 id="代理的响应时间"><a href="#代理的响应时间" class="headerlink" title="代理的响应时间"></a>代理的响应时间</h3><p>代理的响应时间，具体是指代理检测服务器Ping通代理服务器的时间。<br>Ping命令的原理，是发送一个ICMP(因特网控制报文协议)给远程服务器，并回声收到目标ICMP的应答时间。<br>如: 米扑代理的响应时间，分为五个等级，从低到高依次为： 0 ~ 0.1 ~ 0.3 ~ 1 ~ 5 ~ 9，单位秒</p><h3 id="代理的传输速度"><a href="#代理的传输速度" class="headerlink" title="代理的传输速度"></a>代理的传输速度</h3><p>代理的传输速度，具体是指代理检测服务器发送请求到目标服务器并返回数据到本地的总时间。<br>总时间，包括本地发送请求 -&gt; 代理服务器 -&gt; 目标服务器 -&gt; 返回数据到代理服务器 -&gt; 本地的全部时间。<br>如: 米扑代理的传输速度，分为五个等级，从低到高依次为： 0 ~ 0.3 ~ 1 ~ 5 ~ 10 ~ 30，单位秒。</p><h3 id="代理的验证日期"><a href="#代理的验证日期" class="headerlink" title="代理的验证日期"></a>代理的验证日期</h3><p>代理的验证日期，具体是指检测代理可用的最后时间，<br>必须满足:<br>1）代理可用；<br>2）检测为可用的最后时间。<br>例如：代理 100.12.25.10:8080 可用，最后一次检测日期为 2015-05-20 10:12:56，即为验证日期。</p><h3 id="提取的代理都可以用吗？"><a href="#提取的代理都可以用吗？" class="headerlink" title="提取的代理都可以用吗？"></a>提取的代理都可以用吗？</h3><p>代理的实效性很强，当时提取的可用代理可能一会儿就失效了，因此检测代理的最后验证日期，非常重要！</p><h3 id="如何获取高可靠的代理？"><a href="#如何获取高可靠的代理？" class="headerlink" title="如何获取高可靠的代理？"></a>如何获取高可靠的代理？</h3><p>高可靠代理，计算公式：代理的检测可用次数 / 总检测次数 = 可靠率，如:米扑代理独创的检测技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代理有什么用处&quot;&gt;&lt;a href=&quot;#代理有什么用处&quot; class=&quot;headerlink&quot; title=&quot;代理有什么用处&quot;&gt;&lt;/a&gt;代理有什么用处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对游戏，通过第三方代理，可以提高游戏流畅速度&lt;/li&gt;
&lt;li&gt;对师生，通过代理访问国外
      
    
    </summary>
    
      <category term="web" scheme="http://arvin-he.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://arvin-he.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记</title>
    <link href="http://arvin-he.github.io/2017/11/25/redis-note1-2017-11-25/"/>
    <id>http://arvin-he.github.io/2017/11/25/redis-note1-2017-11-25/</id>
    <published>2017-11-25T13:45:48.000Z</published>
    <updated>2017-11-27T01:06:11.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis下载与安装"><a href="#redis下载与安装" class="headerlink" title="redis下载与安装"></a>redis下载与安装</h3><ol><li><p>windows下redis下载地址:<br><img src="https://github.com/MicrosoftArchive/redis/releases" alt="https://github.com/MicrosoftArchive/redis/releases"></p></li><li><p>下载zip版本,在C盘根目录下(或者你想安装的目录下)解压</p></li><li><p>添加redis环境变量</p></li><li><p>注册redis服务<br><code>redis-server.exe --service-install redis.windows.conf --loglevel verbose</code></p></li><li><p>启动redis服务<br><code>redis-server.exe --service-start</code></p></li><li><p>下载redis可视化客户端软件RedisDesktopManager</p></li></ol><p>下载地址:<br><img src="https://redisdesktop.com/download" alt="https://redisdesktop.com/download"></p><h3 id="python下安装redis绑定包"><a href="#python下安装redis绑定包" class="headerlink" title="python下安装redis绑定包"></a>python下安装redis绑定包</h3><p><code>pip install redis</code></p><h3 id="redis-mongodb与memcache对比"><a href="#redis-mongodb与memcache对比" class="headerlink" title="redis, mongodb与memcache对比"></a>redis, mongodb与memcache对比</h3><p>mongodb 直接持久化<br>redis 半持久化<br>memcache 只能在内存，轻量级缓存</p><h3 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h3><p>redis是一个key-value存储系统。和Memcached类似,支持的类型操作有: String操作, Hash操作, List操作, Set操作, Sort Set操作(zset)<br>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的.<br>redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。<br>区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><h3 id="python操作redis"><a href="#python操作redis" class="headerlink" title="python操作redis"></a>python操作redis</h3><p>edis-py提供两个类Redis和StrictRedis用于实现Redis的命令，<br>StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，<br>Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。</p><p>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。<br>默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">r = redis.Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</div><div class="line">r.set(<span class="string">'foo'</span>, <span class="string">'Bar'</span>)</div><div class="line"><span class="keyword">print</span> (r.get(<span class="string">'foo'</span>))</div><div class="line"><span class="comment"># 使用连接池</span></div><div class="line">pool = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</div><div class="line">r = redis.Redis(connection_pool=pool)</div><div class="line">r.set(<span class="string">'foo'</span>, <span class="string">'Bar'</span>)</div><div class="line"><span class="keyword">print</span> r.get(<span class="string">'foo'</span>)</div></pre></td></tr></table></figure></p><h3 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h3><p>set(name, value, ex=None, px=None, nx=False, xx=False)<br>setnx 、 setex 、 psetex<br>在Redis中设置值，默认，不存在则创建，存在则修改<br>参数：<br>     ex，过期时间（秒）<br>     px，过期时间（毫秒）<br>     nx，如果设置为True，则只有name不存在时，当前set操作才执行<br>     xx，如果设置为True，则只有name存在时，当前set操作才执行</p><p>批量设置<br>mset(<em>args, **kwargs)<br>批量获取<br>mget(keys, </em>args)<br>设置新值并获取原来的值<br>getset(name, value)<br>获取子序列（根据字节获取，非字符）<br>getrange(key, start, end)<br>修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）<br>setrange(name, offset, value)<br>对name对应值的二进制进行位操作。<br>setbit(name, offset, value)<br>获取name对应的值的二进制表示中 1 的个数,应用场景:统计在线用户数有多少<br>bitcount(key, start=None, end=None)<br>自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。<br>incr(self, name, amount=1)<br>incrbyfloat(self, name, amount=1.0)<br>自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。<br>decr(self, name, amount=1)<br>在redis name对应的值后面追加内容<br>append(key, value)</p><h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><p>Hash操作，redis中Hash在内存中的存储格式如下图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">name                hash</div><div class="line">               |````````````|</div><div class="line">n1   --------&gt; | k1 --&gt; v1  |</div><div class="line">               | k2 --&gt; v2  |</div><div class="line">               |____________|</div><div class="line">               |````````````|</div><div class="line">n2   --------&gt; | k7 --&gt; v7  |</div><div class="line">               |____________|</div></pre></td></tr></table></figure></p><p>name对应的hash中设置一个键值对（不存在，则创建；否则，修改）<br>hset(name, key, value)<br>在name对应的hash中批量设置键值对<br>hmset(name, mapping)<br>在name对应的hash中获取多个key的值<br>hmget(name, keys, <em>args)<br>获取name对应的hash中键值对的个数<br>hlen(name)<br>检查name对应的hash是否存在当前传入的key<br>hexists(name, key)<br>将name对应的hash中指定key的键值对删除<br>hdel(name,</em>keys)<br>自增name对应的hash中的指定key的值，不存在则创建key=amount<br>hincrby(name, key, amount=1)<br>hincrbyfloat(name, key, amount=1.0)<br>过滤,增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆<br>hscan(name, cursor=0, match=None, count=None)<br>利用yield封装hscan创建生成器，实现分批去redis中获取数据<br>hscan_iter(name, match=None, count=None)</p><h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><p>lpush, lrange, rpush, lpushx, llen, linsert, lset, lrem, lpop, lindex, ltrim, rpoplpush, blpop, brpoplpush</p><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>sadd, scard, sdiff, sdiffstore, sinter, sinterstore, sismenber, smove, spop, srandmenber, srem, sunion, sunionstore</p><h3 id="有序集合-zset"><a href="#有序集合-zset" class="headerlink" title="有序集合(zset)"></a>有序集合(zset)</h3><p>zadd, zcount, zincrby, zrank, zrem, zremrangebyrank, zremrankbyscore, zremrangebylex, zscore, zinterstore, zunionstore</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">zunionstore(dest, keys, aggregate=None)</div><div class="line"># 获取两个有序集合的并集</div><div class="line"># aggregate的值为:  SUM  MIN  MAX</div></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">del(*names)</div><div class="line"># 根据删除redis中的任意数据类型</div><div class="line"></div><div class="line">exists(name)</div><div class="line"># 检测redis的name是否存在</div><div class="line"></div><div class="line">keys(pattern=&apos;*&apos;)</div><div class="line"># 根据模型获取redis的name</div><div class="line"># 更多：</div><div class="line">    # KEYS * 匹配数据库中所有 key 。</div><div class="line">    # KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</div><div class="line">    # KEYS h*llo 匹配 hllo 和 heeeeello 等。</div><div class="line">    # KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo</div><div class="line"></div><div class="line">expire(name ,time)</div><div class="line"># 为某个redis的某个name设置超时时间</div><div class="line"></div><div class="line">rename(src, dst)</div><div class="line"># 对redis的name重命名</div><div class="line"></div><div class="line">move(name, db))</div><div class="line"># 将redis的某个值移动到指定的db下，若有则不移动</div><div class="line"></div><div class="line">select db_name</div><div class="line"># 切换到其他db，redis有16个db</div><div class="line"></div><div class="line">randomkey()</div><div class="line"># 随机获取一个redis的name（不删除）</div><div class="line"></div><div class="line">type(name)</div><div class="line"># 获取name对应值的类型</div><div class="line"></div><div class="line">scan(cursor=0, match=None, count=None)</div><div class="line">scan_iter(match=None, count=None)</div><div class="line"># 同字符串操作，用于增量迭代获取key</div></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，<br>如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import redis</div><div class="line">import time</div><div class="line"></div><div class="line">pool = redis.ConnectionPool(host=&apos;10.211.55.4&apos;, port=6379, db=5)</div><div class="line">r = redis.Redis(connection_pool=pool)</div><div class="line"># pipe = r.pipeline(transaction=False)</div><div class="line">pipe = r.pipeline(transaction=True)</div><div class="line"></div><div class="line">pipe.set(&apos;name&apos;, &apos;alex&apos;)</div><div class="line">time.sleep(60)</div><div class="line">pipe.set(&apos;role&apos;, &apos;sb&apos;)</div><div class="line"></div><div class="line">pipe.execute()</div></pre></td></tr></table></figure><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>收音机举例发布订阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import redis</div><div class="line"></div><div class="line">class RedisHelper:</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.__conn = redis.Redis(host=&apos;10.211.55.4&apos;)</div><div class="line">        self.chan_sub = &apos;fm104.5&apos;</div><div class="line">        self.chan_pub = &apos;fm104.5&apos;</div><div class="line"></div><div class="line">    def public(self, msg):</div><div class="line">        self.__conn.publish(self.chan_pub, msg)</div><div class="line">        return True</div><div class="line"></div><div class="line">    def subscribe(self):</div><div class="line">        pub = self.__conn.pubsub()  # 打开收音机</div><div class="line">        pub.subscribe(self.chan_sub) # 调频道</div><div class="line">        pub.parse_response()  # 准备接收</div><div class="line">        return pub</div></pre></td></tr></table></figure></p><p>订阅方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from RedisHelper import RedisHelper</div><div class="line"></div><div class="line">obj = RedisHelper()</div><div class="line">redis_sub = obj.subscribe()</div><div class="line"></div><div class="line">while True:</div><div class="line">    msg= redis_sub.parse_response()</div><div class="line">    print (msg)</div></pre></td></tr></table></figure></p><p>发布方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from RedisHelper import RedisHelper</div><div class="line"></div><div class="line">obj = RedisHelper()</div><div class="line">obj.public(&apos;hello&apos;)</div></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><img src="http://blog.csdn.net/fgf00/article/details/52917154" alt="http://blog.csdn.net/fgf00/article/details/52917154"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis下载与安装&quot;&gt;&lt;a href=&quot;#redis下载与安装&quot; class=&quot;headerlink&quot; title=&quot;redis下载与安装&quot;&gt;&lt;/a&gt;redis下载与安装&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;windows下redis下载地址:&lt;br&gt;&lt;img sr
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://arvin-he.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>tornado学习笔记(二)</title>
    <link href="http://arvin-he.github.io/2017/11/16/tornado-note2-2017-11-16/"/>
    <id>http://arvin-he.github.io/2017/11/16/tornado-note2-2017-11-16/</id>
    <published>2017-11-16T13:40:47.000Z</published>
    <updated>2017-11-27T01:06:11.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h3><p>ornado 所谓的异步：就是你调用我之后，我发现数据没准备好，那我就不处理，而是跳到程序的其他地方继续执行，等数据准备好之后再切回来继续执行。Tornado 的 IOLoop 就是一个总调度器，汇总了所有的 events 和 callbacks，然后同步执行。这会整体生提升性能，但不会降低单个请求的响应时间。</p><h2 id="一些接口说明"><a href="#一些接口说明" class="headerlink" title="一些接口说明"></a>一些接口说明</h2><h3 id="tornado-web-asynchronous"><a href="#tornado-web-asynchronous" class="headerlink" title="tornado.web.asynchronous"></a>tornado.web.asynchronous</h3><p>其中 tornado.web.asynchronous 装饰器很简单，就是设置 <code>self._auto_finish = False</code>，<br>这样当 AsyncHandler.get() 执行完之后，connection socket 不会被 close，需要主动调用 self.finish()。<br>在保持连接不关闭的情况下，把控制权让出去，等数据就绪之后再切回来，使异步实现成为可能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line"><span class="meta">    @tornado.web.asynchronous</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        http_client = AsyncHTTPClient()</div><div class="line">        http_client.fetch(<span class="string">"http://example.com"</span>,</div><div class="line">                          callback=self.on_fetch)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_fetch</span><span class="params">(self, response)</span>:</span></div><div class="line">        self.write(<span class="string">"Downloaded!"</span>)</div><div class="line">        self.finish()</div></pre></td></tr></table></figure></p><h3 id="SimpleAsyncHTTPClient"><a href="#SimpleAsyncHTTPClient" class="headerlink" title="SimpleAsyncHTTPClient"></a>SimpleAsyncHTTPClient</h3><p>AsyncHTTPClient 的处理流程，简单概括就是：与 HTTP Server 建立连接，等拿到 response 后再来调用回调函数 on_fetch。首先通过创建非阻塞的 socket 连接，然后放入到 ioloop 中，当数据可写/可读之后再接着处理。</p><h3 id="gen-engine-的实现："><a href="#gen-engine-的实现：" class="headerlink" title="gen.engine 的实现："></a>gen.engine 的实现：</h3><p>gen.engine 的作用就是把异步中 callback 的写法通过 yield 替代。<br>以下的代码分析都是基于 Tornado 3.0。<br>tornado.ioloop.IOLoop.current() 创建一个ioloop实例</p><p>###IOLoop 为何没有 <code>__init__</code>函数<br>其实是因为要初始化成为单例，IOLoop 的 new 函数已经被改写了，同时指定了 initialize 做为它的初始化方法，所以没有 <code>__init__</code> 。 </p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future在tornado中是一个很奇妙的对象，它是一个穿梭于协程和调度器之间的信使。提供了回调函数注册(当异步事件完成后，调用注册的回调)、中间结果保存、嵌套协程唤醒父协程(通过Runner实现)等功能。Coroutine和Future是一一对应的，可以从上节gen.coroutine装饰器的实现中看到。每调用一个协程，表达式所返回的就是一个Future对象，它所表达的意义为：这个协程的内部各种异步逻辑执行完毕后，会把结果保存在这个Future中，同时调用这个Future中指定的回调函数，而future中的回调函数是什么时候被注册的呢？那就是当前——你通过调用协程，返回了这个future对象的时候：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一些说明&quot;&gt;&lt;a href=&quot;#一些说明&quot; class=&quot;headerlink&quot; title=&quot;一些说明&quot;&gt;&lt;/a&gt;一些说明&lt;/h3&gt;&lt;p&gt;ornado 所谓的异步：就是你调用我之后，我发现数据没准备好，那我就不处理，而是跳到程序的其他地方继续执行，等数据准备好之
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="tornado" scheme="http://arvin-he.github.io/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>如何去阅读源码</title>
    <link href="http://arvin-he.github.io/2017/11/16/howtoreadsource-2017-11-16/"/>
    <id>http://arvin-he.github.io/2017/11/16/howtoreadsource-2017-11-16/</id>
    <published>2017-11-16T13:34:20.000Z</published>
    <updated>2017-11-27T01:06:11.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阅读源码的方法"><a href="#阅读源码的方法" class="headerlink" title="阅读源码的方法"></a>阅读源码的方法</h3><p>源码分析的时候，一定要有层级和模块的概念，任何一个系统都可以被认为是许多个层级或者模块通过向外界暴露接口或者调用其他层级模块接口的方式连接在一起。所以没有必要上来就把每一个细节的实现搞明白，这是低效不科学的方法。正确的方法是首先从宏观上对整体框架有一个认识，划分出层级和模块，然后再具体把每一个模块搞透彻。</p><h3 id="学习新框架的方法"><a href="#学习新框架的方法" class="headerlink" title="学习新框架的方法"></a>学习新框架的方法</h3><p>学一个新的框架，文档先浏览一下，然后就是照着教程的例子运行，接着弄懂例子的运行原理（看源码）。抓住在使用框架过程中遇到的问题，并以那个问题为切入点深入分析，这样一方面能解决问题；另一方面能借机对框架有更深入的了解，因为框架内容那么多，也不可能面面俱到，但是至少遇到问题的地方你深挖是有价值的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;阅读源码的方法&quot;&gt;&lt;a href=&quot;#阅读源码的方法&quot; class=&quot;headerlink&quot; title=&quot;阅读源码的方法&quot;&gt;&lt;/a&gt;阅读源码的方法&lt;/h3&gt;&lt;p&gt;源码分析的时候，一定要有层级和模块的概念，任何一个系统都可以被认为是许多个层级或者模块通过向外界暴露
      
    
    </summary>
    
      <category term="思想" scheme="http://arvin-he.github.io/categories/%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="方法" scheme="http://arvin-he.github.io/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>tornado学习笔记(一)</title>
    <link href="http://arvin-he.github.io/2017/11/16/tornado-note1-2017-11-16/"/>
    <id>http://arvin-he.github.io/2017/11/16/tornado-note1-2017-11-16/</id>
    <published>2017-11-16T11:42:00.000Z</published>
    <updated>2017-11-27T01:06:11.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>高性能源于Tornado基于Epoll（unix为kqueue）的异步网络IO。因为tornado的单线程机制，一不小心就容易写出阻塞服务（block）的代码。不但没有性能提高，反而会让性能急剧下降。因此，探索tornado的异步使用方式很有必要。<br>tornado虽然以异步非阻塞高性能著称的框架,但默认不是异步非阻塞的,你需要添加两个装饰器@tornado.web.asynchronous和@tornado.gen.coroutine,<br>这样才算是异步非阻塞的.然而当你用tornado作为http服务器,同时用了requests库发送请求后,你会发现请求还是一个一个的处理,根本不是异步非阻塞的.<br>原因是requests库发送请求是阻塞的,它会阻塞整个tornado服务进程,为什么阻塞,原因是用 requests 的话能会 block 其他 http 请求。因为他无法注册到 ioloop 里面。只要这个 requests 请求结束， tornado 才会处理下一个 http 请求。 </p><h3 id="Tornado主要模块"><a href="#Tornado主要模块" class="headerlink" title="Tornado主要模块"></a>Tornado主要模块</h3><p>web - FriendFeed 使用的基础 Web 框架，包含了 Tornado 的大多数重要的功能<br>escape - XHTML, JSON, URL 的编码/解码方法<br>database - 对 MySQLdb 的简单封装，使其更容易使用<br>template - 基于 Python 的 web 模板系统<br>httpclient - 非阻塞式 HTTP 客户端，它被设计用来和 web 及 httpserver 协同工作<br>auth - 第三方认证的实现（包括 Google OpenID/OAuth、Facebook Platform、Yahoo BBAuth、FriendFeed OpenID/OAuth、Twitter OAuth）<br>locale - 针对本地化和翻译的支持<br>options - 命令行和配置文件解析工具，针对服务器环境做了优化</p><p>底层模块<br>httpserver - 服务于 web 模块的一个非常简单的 HTTP 服务器的实现<br>iostream - 对非阻塞式的 socket 的简单封装，以方便常用读写操作<br>ioloop - 核心的 I/O 循环</p><h3 id="Tornado-异步使用方式"><a href="#Tornado-异步使用方式" class="headerlink" title="Tornado 异步使用方式"></a>Tornado 异步使用方式</h3><p>简而言之，Tornado的异步包括两个方面，异步服务端和异步客户端。无论服务端和客户端，具体的异步模型又可以分为回调（callback）和协程（coroutine）。具体应用场景，也没有很明确的界限。往往一个请求服务里还包含对别的服务的客户端异步请求。</p><h3 id="服务端异步方式"><a href="#服务端异步方式" class="headerlink" title="服务端异步方式"></a>服务端异步方式</h3><p>服务端异步，可以理解为一个tornado请求之内，需要做一个耗时的任务。直接写在业务逻辑里可能会block整个服务。因此可以把这个任务放到异步处理，实现异步的方式就有两种，<br>一种是yield挂起函数，另外一种就是使用类线程池的方式。请看一个同步例子：<br>同步代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    <span class="comment"># 耗时的代码</span></div><div class="line">    os.system(<span class="string">"ping -c 2 www.google.com"</span>)</div><div class="line">    self.finish(<span class="string">'It works'</span>)</div></pre></td></tr></table></figure></p><p>测试一下：0.99，姑且当成每秒处理一个请求吧。</p><p>异步代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line"></div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    tornado.ioloop.IOLoop.instance().add_timeout(<span class="number">1</span>, callback=functools.partial(self.ping, <span class="string">'www.google.com'</span>))</div><div class="line">    <span class="comment"># do something others</span></div><div class="line">    self.finish(<span class="string">'It works'</span>)</div><div class="line"></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, url)</span>:</span></div><div class="line">    os.system(<span class="string">"ping -c 2 &#123;&#125;"</span>.format(url))</div><div class="line">    <span class="keyword">return</span> <span class="string">'after'</span></div></pre></td></tr></table></figure></p><p>尽管在执行异步任务的时候选择了timeout 1秒，主线程的返回还是很快的。<br>上述的使用方式，通过tornado的IO循环，把可以把耗时的任务放到后台异步计算，请求可以接着做别的计算。<br>可是，经常有一些耗时的任务完成之后，我们需要其计算的结果。此时这种方式就不行了。车道山前必有路，只需要切换一异步方式即可。下面使用协程来改写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line"></div><div class="line"><span class="meta">    @tornado.web.asynchronous</span></div><div class="line"><span class="meta">    @tornado.gen.coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        <span class="comment"># yield 结果</span></div><div class="line">        response = <span class="keyword">yield</span> tornado.gen.Task(self.ping, <span class="string">' www.google.com'</span>)</div><div class="line">        <span class="keyword">print</span> <span class="string">'response'</span>, response</div><div class="line">        self.finish(<span class="string">'hello'</span>)</div><div class="line"></div><div class="line"><span class="meta">    @tornado.gen.coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, url)</span>:</span></div><div class="line">        os.system(<span class="string">"ping -c 2 &#123;&#125;"</span>.format(url))</div><div class="line">        <span class="keyword">return</span> <span class="string">'after'</span></div><div class="line">```    </div><div class="line">可以看到异步在处理，而结果值也被返回了。有时候这种协程处理，未必就比同步快。在并发量很小的情况下，IO本身拉开的差距并不大。甚至协程和同步性能差不多。</div><div class="line"><span class="keyword">yield</span>挂起函数协程，尽管没有block主线程，因为需要处理返回值，挂起到响应执行还是有时间等待，相对于单个请求而言。另外一种使用异步和协程的方式就是在主线程之外，使用线程池，线程池依赖于futures。Python2需要额外安装。</div><div class="line">```python</div><div class="line">下面使用线程池的方式修改为异步处理：</div><div class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FutureHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  executor = ThreadPoolExecutor(<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    url = <span class="string">'www.google.com'</span></div><div class="line">    tornado.ioloop.IOLoop.instance().add_callback(functools.partial(self.ping, url))</div><div class="line">    self.finish(<span class="string">'It works'</span>)</div><div class="line"></div><div class="line"><span class="meta">  @tornado.concurrent.run_on_executor</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, url)</span>:</span></div><div class="line">    os.system(<span class="string">"ping -c 2 &#123;&#125;"</span>.format(url))</div><div class="line">```    </div><div class="line">再切换一下使用方式接口。使用tornado的gen模块下的with_timeout功能（这个功能必须在tornado&gt;<span class="number">3.2</span>的版本）。</div><div class="line">```python</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Executor</span><span class="params">(ThreadPoolExecutor)</span>:</span></div><div class="line">  _instance = <span class="keyword">None</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> getattr(cls, <span class="string">'_instance'</span>, <span class="keyword">None</span>):</div><div class="line">      cls._instance = ThreadPoolExecutor(max_workers=<span class="number">10</span>)</div><div class="line">    <span class="keyword">return</span> cls._instance</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FutureResponseHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  executor = Executor()</div><div class="line"></div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    future = Executor().submit(self.ping, <span class="string">'www.google.com'</span>)</div><div class="line">    response = <span class="keyword">yield</span> tornado.gen.with_timeout(datetime.timedelta(<span class="number">10</span>), future,</div><div class="line">                         quiet_exceptions=tornado.gen.TimeoutError)</div><div class="line">    <span class="keyword">if</span> response:</div><div class="line">      <span class="keyword">print</span> <span class="string">'response'</span>, response.result()</div><div class="line"></div><div class="line"><span class="meta">  @tornado.concurrent.run_on_executor</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, url)</span>:</span></div><div class="line">    os.system(<span class="string">"ping -c 1 &#123;&#125;"</span>.format(url))</div><div class="line">    <span class="keyword">return</span> <span class="string">'after'</span></div></pre></td></tr></table></figure></p><p>线程池的方式也可以通过使用tornado的yield把函数挂起，实现了协程处理。可以得出耗时任务的result，同时不会block住主线程。</p><p>###异步多样化<br>Tornado异步服务的处理大抵如此。现在异步处理的框架和库也很多，借助redis或者celery等，也可以把tonrado中一些业务异步化，放到后台执行。<br>此外，Tornado还有客户端异步功能。该特性主要是在于 AsyncHTTPClient的使用。此时的应用场景往往是tornado服务内，需要针对另外的IO进行请求和处理。顺便提及，上述的例子中，调用ping其实也算是一种服务内的IO处理。接下来，将会探索一下AsyncHTTPClient的使用，尤其是使用AsyncHTTPClient上传文件与转发请求。</p><h3 id="异步客户端"><a href="#异步客户端" class="headerlink" title="异步客户端"></a>异步客户端</h3><p>前面了解Tornado的异步任务的常用做法，姑且归结为异步服务。通常在我们的服务内，还需要异步的请求第三方服务。针对HTTP请求，Python的库Requests是最好用的库，没有之一。官网宣称：HTTP for Human。然而，在tornado中直接使用requests将会是一场恶梦。requests的请求会block整个服务进程。<br>上帝关上门的时候，往往回打开一扇窗。Tornado提供了一个基于框架本身的异步HTTP客户端（当然也有同步的客户端）— AsyncHTTPClient。</p><h3 id="AsyncHTTPClient-基本用法"><a href="#AsyncHTTPClient-基本用法" class="headerlink" title="AsyncHTTPClient 基本用法"></a>AsyncHTTPClient 基本用法</h3><p>AsyncHTTPClient是 tornado.httpclinet 提供的一个异步http客户端。使用也比较简单。与服务进程一样，AsyncHTTPClient也可以callback和yield两种使用方式。前者不会返回结果，后者则会返回response。如果请求第三方服务是同步方式，同样会杀死性能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    url = <span class="string">'https://api.github.com/'</span></div><div class="line">    resp = requests.get(url)</div><div class="line">    <span class="keyword">print</span> resp.status_code</div><div class="line">    self.finish(<span class="string">'It works'</span>)</div></pre></td></tr></table></figure></p><p>性能相当慢了，换成AsyncHTTPClient再测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  </div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    url = <span class="string">'https://api.github.com/'</span></div><div class="line">    http_client = tornado.httpclient.AsyncHTTPClient()</div><div class="line">    http_client.fetch(url, self.on_response)</div><div class="line">    self.finish(<span class="string">'It works'</span>)</div><div class="line"></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, response)</span>:</span></div><div class="line">    <span class="keyword">print</span> response.code</div></pre></td></tr></table></figure><p>提高了很多,同样，为了获取response的结果，只需要yield函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncResponseHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  </div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    url = <span class="string">'https://api.github.com/'</span></div><div class="line">    http_client = tornado.httpclient.AsyncHTTPClient()</div><div class="line">    response = <span class="keyword">yield</span> tornado.gen.Task(http_client.fetch, url)</div><div class="line">    <span class="keyword">print</span> response.code</div><div class="line">    <span class="keyword">print</span> response.body</div></pre></td></tr></table></figure></p><h3 id="AsyncHTTPClient-转发"><a href="#AsyncHTTPClient-转发" class="headerlink" title="AsyncHTTPClient 转发"></a>AsyncHTTPClient 转发</h3><p>使用Tornado经常需要做一些转发服务，需要借助AsyncHTTPClient。既然是转发，就不可能只有get方法，post，put，delete等方法也会有。此时涉及到一些 headers和body，甚至还有https的waring。</p><p>下面请看一个post的例子， yield结果，通常，使用yield的时候，handler是需要 tornado.gen.coroutine。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">headers = self.request.headers</div><div class="line">body = json.dumps(&#123;<span class="string">'name'</span>: <span class="string">'rsj217'</span>&#125;)</div><div class="line">http_client = tornado.httpclient.AsyncHTTPClient()</div><div class="line"></div><div class="line">resp = <span class="keyword">yield</span> tornado.gen.Task(</div><div class="line">  self.http_client.fetch, </div><div class="line">  url,</div><div class="line">  method=<span class="string">"POST"</span>, </div><div class="line">  headers=headers,</div><div class="line">  body=body, </div><div class="line">  validate_cert=<span class="keyword">False</span>)</div></pre></td></tr></table></figure></p><h3 id="AsyncHTTPClient-构造请求"><a href="#AsyncHTTPClient-构造请求" class="headerlink" title="AsyncHTTPClient 构造请求"></a>AsyncHTTPClient 构造请求</h3><p>如果业务处理并不是在handlers写的，而是在别的地方，当无法直接使用tornado.gen.coroutine的时候，可以构造请求，使用callback的方式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">body = urllib.urlencode(params)</div><div class="line">req = tornado.httpclient.HTTPRequest(</div><div class="line"> url=url, </div><div class="line"> method=<span class="string">'POST'</span>, </div><div class="line"> body=body, </div><div class="line"> validate_cert=<span class="keyword">False</span>) </div><div class="line"></div><div class="line">http_client.fetch(req, self.handler_response)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler_response</span><span class="params">(self, response)</span>:</span></div><div class="line">  <span class="keyword">print</span> response.code</div></pre></td></tr></table></figure></p><p>用法也比较简单，AsyncHTTPClient中的fetch方法，第一个参数其实是一个HTTPRequest实例对象，因此对于一些和http请求有关的参数，例如method和body，可以使用HTTPRequest先构造一个请求，再扔给fetch方法。通常在转发服务的时候，如果开起了validate_cert，有可能会返回599timeout之类，这是一个warning，官方却认为是合理的。</p><h3 id="AsyncHTTPClient-上传图片"><a href="#AsyncHTTPClient-上传图片" class="headerlink" title="AsyncHTTPClient 上传图片"></a>AsyncHTTPClient 上传图片</h3><p>AsyncHTTPClient 更高级的用法就是上传图片。例如服务有一个功能就是请求第三方服务的图片OCR服务。需要把用户上传的图片，再转发给第三方服务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@router.Route('/api/v2/account/upload')</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiAccountUploadHandler</span><span class="params">(helper.BaseHandler)</span>:</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line"><span class="meta">  @helper.token_require</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    upload_type = self.get_argument(<span class="string">'type'</span>, <span class="keyword">None</span>)</div><div class="line">    files_body = self.request.files[<span class="string">'file'</span>]</div><div class="line">    new_file = <span class="string">'upload/new_pic.jpg'</span></div><div class="line">    new_file_name = <span class="string">'new_pic.jpg'</span></div><div class="line"></div><div class="line">    <span class="comment"># 写入文件</span></div><div class="line">    <span class="keyword">with</span> open(new_file, <span class="string">'w'</span>) <span class="keyword">as</span> w:</div><div class="line">      w.write(file_[<span class="string">'body'</span>])</div><div class="line">    logging.info(<span class="string">'user &#123;&#125; upload &#123;&#125;'</span>.format(user_id, new_file_name))</div><div class="line"></div><div class="line">    <span class="comment"># 异步请求 上传图片</span></div><div class="line">    <span class="keyword">with</span> open(new_file, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</div><div class="line">      files = [(<span class="string">'image'</span>, new_file_name, f.read())]</div><div class="line">    fields = ((<span class="string">'api_key'</span>, KEY), (<span class="string">'api_secret'</span>, SECRET))</div><div class="line">    content_type, body = encode_multipart_formdata(fields, files)</div><div class="line">    headers = &#123;<span class="string">"Content-Type"</span>: content_type, <span class="string">'content-length'</span>: str(len(body))&#125;</div><div class="line">    request = tornado.httpclient.HTTPRequest(config.OCR_HOST,</div><div class="line">                         method=<span class="string">"POST"</span>, headers=headers, body=body, validate_cert=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">    response = <span class="keyword">yield</span> tornado.httpclient.AsyncHTTPClient().fetch(request)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_multipart_formdata</span><span class="params">(fields, files)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line"><span class="string">  fields is a sequence of (name, value) elements for regular form fields.</span></div><div class="line"><span class="string">  files is a sequence of (name, filename, value) elements for data to be</span></div><div class="line"><span class="string">  uploaded as files.</span></div><div class="line"><span class="string">  Return (content_type, body) ready for httplib.HTTP instance</span></div><div class="line"><span class="string">  """</span></div><div class="line">  boundary = <span class="string">'----------ThIs_Is_tHe_bouNdaRY_$'</span></div><div class="line">  crlf = <span class="string">'\r\n'</span></div><div class="line">  l = []</div><div class="line">  <span class="keyword">for</span> (key, value) <span class="keyword">in</span> fields:</div><div class="line">    l.append(<span class="string">'--'</span> + boundary)</div><div class="line">    l.append(<span class="string">'Content-Disposition: form-data; name="%s"'</span> % key)</div><div class="line">    l.append(<span class="string">''</span>)</div><div class="line">    l.append(value)</div><div class="line">  <span class="keyword">for</span> (key, filename, value) <span class="keyword">in</span> files:</div><div class="line">    filename = filename.encode(<span class="string">"utf8"</span>)</div><div class="line">    l.append(<span class="string">'--'</span> + boundary)</div><div class="line">    l.append(</div><div class="line">        <span class="string">'Content-Disposition: form-data; name="%s"; filename="%s"'</span> % (</div><div class="line">          key, filename</div><div class="line">        )</div><div class="line">    )</div><div class="line">    l.append(<span class="string">'Content-Type: %s'</span> % get_content_type(filename))</div><div class="line">    l.append(<span class="string">''</span>)</div><div class="line">    l.append(value)</div><div class="line">  l.append(<span class="string">'--'</span> + boundary + <span class="string">'--'</span>)</div><div class="line">  l.append(<span class="string">''</span>)</div><div class="line">  body = crlf.join(l)</div><div class="line">  content_type = <span class="string">'multipart/form-data; boundary=%s'</span> % boundary</div><div class="line">  <span class="keyword">return</span> content_type, body</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_content_type</span><span class="params">(filename)</span>:</span></div><div class="line">  <span class="keyword">import</span> mimetypes</div><div class="line">  <span class="keyword">return</span> mimetypes.guess_type(filename)[<span class="number">0</span>] <span class="keyword">or</span> <span class="string">'application/octet-stream'</span></div></pre></td></tr></table></figure></p><p>对比上述的用法，上传图片仅仅是多了一个图片的编码。将图片的二进制数据按照multipart 方式编码。编码的同时，还需要把传递的相关的字段处理好。相比之下，使用requests 的方式则非常简单：<br>files = {}<br>f = open(‘/Users/ghost/Desktop/id.jpg’)<br>files[‘image’] = f<br>data = dict(api_key=’KEY’, api_secret=’SECRET’)<br>resp = requests.post(url, data=data, files=files)<br>f.close()<br>print resp.status_Code</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过AsyncHTTPClient的使用方式，可以轻松的实现handler对第三方服务的请求。结合前面关于tornado异步的使用方式。无非还是两个key。是否需要返回结果，来确定使用callback的方式还是yield的方式。当然，如果不同的函数都yield，yield也可以一直传递。这个特性，tornado的中的tornado.auth 里面对oauth的认证。<br>大致就是这样的用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h3&gt;&lt;p&gt;高性能源于Tornado基于Epoll（unix为kqueue）的异步网络IO。因为tornado的单线程机制，一不小心就容易写出阻塞服务（
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="tornado" scheme="http://arvin-he.github.io/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB之aggregate, pipeline及map_reduce</title>
    <link href="http://arvin-he.github.io/2017/11/05/mongodb-aggregate-pipeline/"/>
    <id>http://arvin-he.github.io/2017/11/05/mongodb-aggregate-pipeline/</id>
    <published>2017-11-05T08:18:15.000Z</published>
    <updated>2017-11-07T01:17:17.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB聚合"><a href="#MongoDB聚合" class="headerlink" title="MongoDB聚合"></a>MongoDB聚合</h3><p>聚合操作处理数据记录并返回计算结果。 聚合操作将多个文档中的值组合在一起，并可对分组数据执行各种操作，以返回单个结果。<br>在SQL中的 count(*)与group by组合相当于mongodb 中的聚合功能。</p><p>基本语法: <code>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</code></p><h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><p>数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   _id: 100, title: &apos;MongoDB Overview&apos;, description: &apos;MongoDB is no sql database&apos;, by_user: &apos;Maxsu&apos;, </div><div class="line">   url: &apos;http://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">   _id: 101, title: &apos;NoSQL Overview&apos;, description: &apos;No sql database is very fast&apos;, by_user: &apos;Maxsu&apos;,</div><div class="line">   url: &apos;http://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 10</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">   _id: 102, title: &apos;Neo4j Overview&apos;, description: &apos;Neo4j is no sql database&apos;, by_user: &apos;Kuber&apos;,</div><div class="line">   url: &apos;http://www.neo4j.com&apos;, tags: [&apos;neo4j&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 750</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">   _id: 103, title: &apos;MySQL Overview&apos;, description: &apos;MySQL is sql database&apos;, by_user: &apos;Curry&apos;,</div><div class="line">   url: &apos;http://www.yiibai.com/mysql/&apos;, tags: [&apos;MySQL&apos;, &apos;database&apos;, &apos;SQL&apos;], likes: 350</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>聚合字段<code>by_user</code>的总数, 其中<code>by_user</code>作为新集合的<code>_id</code>, 统计的总数放在num_tutorial字段的值中.<br><code>db.article.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}}])</code><br>结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;_id&quot; : &quot;Curry&quot;, &quot;num_tutorial&quot; : 1 &#125;</div><div class="line">&#123; &quot;_id&quot; : &quot;Kuber&quot;, &quot;num_tutorial&quot; : 1 &#125;</div><div class="line">&#123; &quot;_id&quot; : &quot;Maxsu&quot;, &quot;num_tutorial&quot; : 2 &#125;</div></pre></td></tr></table></figure></p><p>上述用例的Sql等效查询<code>select by_user, count(*) as num_tutorial from</code>article<code>group by by_user;</code></p><h3 id="其他用于聚合的表达式"><a href="#其他用于聚合的表达式" class="headerlink" title="其他用于聚合的表达式"></a>其他用于聚合的表达式</h3><p>$sum    从集合中的所有文档中求出定义的值。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])<br>$avg    计算集合中所有文档的所有给定值的平均值。db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])<br>$min    从集合中的所有文档获取相应值的最小值。     db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])<br>$max    从集合中的所有文档获取相应值的最大值。     db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])<br>$push    将值插入到生成的文档中的数组中。       db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])<br>$addToSet    将值插入生成的文档中的数组，但不会创建重复项。    db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])<br>$first    根据分组从源文档获取第一个文档。 通常情况下，这只适用于以前应用的“$sort”阶段。    db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])<br>$last    根据分组从源文档获取最后一个文档。通常情况下，这只适用于以前应用的“$sort”阶段。    db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>在UNIX命令中，shell管道可以对某些输入执行操作，并将输出用作下一个命令的输入。<br>MongoDB也在聚合框架中支持类似的概念。每一组输出可作为另一组文档的输入，并生成一组生成的文档(或最终生成的JSON文档在管道的末尾)。<br>这样就可以再次用于下一阶段等等。</p><p>以下是在聚合框架可能的阶段 -</p><p>$project - 用于从集合中选择一些特定字段。<br>$match - 这是一个过滤操作，因此可以减少作为下一阶段输入的文档数量。<br>$group - 这是上面讨论的实际聚合。<br>$sort - 排序文档。<br>$skip - 通过这种方式，可以在给定数量的文档的文档列表中向前跳过。<br>$limit - 限制从当前位置开始的给定数量的文档数量。<br>$unwind - 用于展开正在使用数组的文档。使用数组时，数据是预先加入的，此操作将被撤销，以便再次单独使用文档。 因此，在这个阶段，将增加下一阶段的文件数量。</p><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map_reduce"></a>map_reduce</h3><p>Map-reduce是将大量数据合并为有用的聚合结果的数据处理范例。 MongoDB使用mapReduce命令进行map-reduce操作。MapReduce通常用于处理大型数据集。<br>MapReduce命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">db.collection.mapReduce(</div><div class="line">   function() &#123;emit(key,value);&#125;,  //map function</div><div class="line">   function(key,values) &#123;return reduceFunction&#125;, //reduce function</div><div class="line">   &#123;</div><div class="line">    query: query,  </div><div class="line">    out: out,    //指定结果集以什么方式存储，可选参数包括：  </div><div class="line">                //replace:如果文档(table)存在，则替换table，  </div><div class="line">                //merge:如果文档中存在记录，则覆盖已存在的文档记录  </div><div class="line">                //reduce: 如果文档中存在相同key的记录了，则先计算两条记录，然后覆盖旧记录  </div><div class="line">                // &#123;inline:1&#125;  在内存中存储记录，不写入磁盘(用户数据量少的计算) </div><div class="line">    sort: sort,  </div><div class="line">    limit: limit,  </div><div class="line">    finalize: function  //这个function主要用来在存入out之前可以修改数据，function(key,values) &#123;   </div><div class="line">                        //return modifiedValues;&#125;  </div><div class="line">    scope: document,    //设置参数值，在这里设置的值在map，reduce，finalize函数中可见</div><div class="line">    jsMode:boolean      //是否减少执行过程中BSON和JS的转换，默认true]</div><div class="line">                        //false时 BSON--&gt;JS--&gt;map--&gt;BSON--&gt;JS--&gt;reduce--&gt;BSON,可处理非常大的mapreduce,</div><div class="line">                        //true时BSON--&gt;js--&gt;map--&gt;reduce--&gt;BSON</div><div class="line">                        </div><div class="line">    verbose:boolean     //是否产生更加详细的服务器日志，默认true</div><div class="line">    keytemp：boolean    //true或false，表明结果输出到的collection是否是临时的，如果为true，则会在客户端连接中断后自动删除，如果你用的是MongoDB的mongo客户端连接，  </div><div class="line">                        //那必须exit后才会删除。如果是脚本执行，脚本退出或调用close会自动删除结果collection    </div><div class="line"></div><div class="line">   &#125;</div><div class="line">)</div><div class="line"></div><div class="line">必备参数：map,reduce, out</div></pre></td></tr></table></figure></p><p><code>map: function() {emit(this.cat_id,this.goods_number); }</code><br>说明: 函数内部要调用内置的emit函数,cat_id代表根据cat_id来进行分组,<br>goods_number代表把文档中的goods_number字段映射到cat_id分组上的数据,<br>其中this是指向向前的文档的,这里的第二个参数可以是一个对象,如果是一个对象的话,也是作为数组的元素压进数组里面;</p><p>reduce: function(cat_id,all_goods_number) {return Array.sum(all_goods_number)},<br>cat_id代表着cat_id当前的这一组,all_goods_number代表当前这一组的goods_number集合,这部分返回的就是结果中的value值;</p><p>out: <output>, // 输出到某一个集合中,注意本属性来还支持如果输出的集合如果已经存在了,那是替换,合并还是继续reduce? 另外还支持输出到其他db的分片中,具体用到时查阅文档,筛选出现的键名分别是_id和value;</output></p><p>query: <document>, // 一个查询表达式,是先查询出来,再进行mapReduce的</document></p><p>sort: <document>, // 发往map函数前先给文档排序</document></p><p>limit: <number>, // 发往map函数的文档数量上限,该参数貌似不能用在分片模式下的mapreduce</number></p><p>finalize: function(key, reducedValue) {return modifiedObject; }, // 从reduce函数中接受的参数key与reducedValue,并且可以访问scope中设定的变量</p><p>scope: <document>, // 指定一个全局变量,能应用于finalize和reduce函数</document></p><p>jsMode: <boolean>, // 布尔值，是否减少执行过程中BSON和JS的转换，默认true,true时BSON–&gt;js–&gt;map–&gt;reduce–&gt;BSON,false时 BSON–&gt;JS–&gt;map–&gt;BSON–&gt;JS–&gt;reduce–&gt;BSON,可处理非常大的mapreduce。</boolean></p><p>verbose: <boolean> // 是否产生更加详细的服务器日志，默认true</boolean></p><p>map-reduce函数首先查询集合，然后将结果文档映射到发出的键值对，然后根据具有多个值的键进行减少。</p><ul><li>map是一个JavaScript函数，它将一个值与一个键映射并发出一个键值对；</li><li>reduce是一个javascript函数，可以减少或分组具有相同键的所有文档；</li><li>out指定map-reduce查询结果的输出位置,一般是输出到另一个新的集合里；</li><li>query指定选择文档的可选选择条件；</li><li>sort指定可选的排序条件；</li><li>limit指定可选的最大文档数；</li></ul><p>MapReduce查询可用于构建大型复杂聚合查询。 使用自定义JavaScript函数可以使用MapReduce，它非常灵活和强大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MongoDB聚合&quot;&gt;&lt;a href=&quot;#MongoDB聚合&quot; class=&quot;headerlink&quot; title=&quot;MongoDB聚合&quot;&gt;&lt;/a&gt;MongoDB聚合&lt;/h3&gt;&lt;p&gt;聚合操作处理数据记录并返回计算结果。 聚合操作将多个文档中的值组合在一起，并可对分组
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MongoDB" scheme="http://arvin-he.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>python中的一些errors</title>
    <link href="http://arvin-he.github.io/2017/10/29/py-errors-2017-10-29/"/>
    <id>http://arvin-he.github.io/2017/10/29/py-errors-2017-10-29/</id>
    <published>2017-10-29T09:22:42.000Z</published>
    <updated>2018-01-25T08:26:46.780Z</updated>
    
    <content type="html"><![CDATA[<ol><li>builtins.ImportError: cannot import name ‘Empty’<br>当运行python脚本程序后,python解析器会自动将当前脚本的路径加到syspath中,<br>如果当前脚本的路径中含有与标准库同名的脚本queue.py,则报上面的错.所以不要有与标准库同名的脚本.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;builtins.ImportError: cannot import name ‘Empty’&lt;br&gt;当运行python脚本程序后,python解析器会自动将当前脚本的路径加到syspath中,&lt;br&gt;如果当前脚本的路径中含有与标准库同名的脚本queue.py
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Python之psutil模块使用</title>
    <link href="http://arvin-he.github.io/2017/10/18/py-psutil-2017-10-18/"/>
    <id>http://arvin-he.github.io/2017/10/18/py-psutil-2017-10-18/</id>
    <published>2017-10-18T06:36:01.000Z</published>
    <updated>2018-01-25T08:26:03.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="psutil模块"><a href="#psutil模块" class="headerlink" title="psutil模块"></a>psutil模块</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;psutil模块&quot;&gt;&lt;a href=&quot;#psutil模块&quot; class=&quot;headerlink&quot; title=&quot;psutil模块&quot;&gt;&lt;/a&gt;psutil模块&lt;/h3&gt;
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
</feed>
