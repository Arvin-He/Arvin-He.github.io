---
title: Python之Pandas入门
date: 2017-06-08 14:41:30
tags: Python
categories: 编程
---
这是一个简短的为新手入门的pandas教程,更高级的用法请查看[ccokbook](http://pandas.pydata.org/pandas-docs/stable/cookbook.html#cookbook)
这里安装numpy, mayplotlit 和 pandas省略.首先导入如下包
```python
In [1]: import pandas as pd

In [2]: import numpy as np

In [3]: import matplotlib.pyplot as plt
```

### 对象创建
传递一个list来创建一个 Series 对象, pandas会自动创建索引
```python
In [4]: s = pd.Series([1,3,5,np.nan, 6, 8])

In [5]: s
Out[5]:
0    1.0
1    3.0
2    5.0
3    NaN
4    6.0
5    8.0
dtype: float64
```

传递一个numpy的array创建一个DataFrame对象, 同时以datetime为索引和带label的列
DataFrame 是有多个列的数据表，每个列拥有一个 label，当然，DataFrame 也有索引
```python
# 创建datetime索引
In [6]: dates = pd.date_range('20170608', periods=6)

In [7]: dates
Out[7]:
DatetimeIndex(['2017-06-08', '2017-06-09', '2017-06-10', '2017-06-11',
               '2017-06-12', '2017-06-13'],
              dtype='datetime64[ns]', freq='D')

In [8]: df = pd.DataFrame(np.random.randn(6,4), index=dates, columns=list('ABCD'))

In [9]: df
Out[9]:
                   A         B         C         D
2017-06-08 -0.561773  0.881191 -2.697783 -0.034672
2017-06-09 -0.053409  0.814811  0.294231 -1.753744
2017-06-10 -1.699722  0.971518 -2.592852  1.088473
2017-06-11 -2.411028  0.312229 -1.879164  1.388484
2017-06-12 -0.173929 -0.572149  2.044024 -0.101223
2017-06-13 -0.906777 -0.207889 -0.776134  2.327599
```

传递一个dict来创建一个DataFrame, 每个 dict 的 value 会被转化成一个 Series,
可以认为，DataFrame 是由多个 Series 组成的
```python
In [10]: df2 = pd.DataFrame({
    ...: 'A': 1.,
    ...: 'B': pd.Timestamp('20170608'),
    ...: 'C': pd.Series(1, index=list(range(4)), dtype='float32'),
    ...: 'D': np.array([3]*4, dtype='int32'),
    ...: 'E': pd.Categorical(['test', 'train', 'test', 'train']),
    ...: 'F': 'foo'})

In [11]: df2
Out[11]:
     A          B    C  D      E    F
0  1.0 2017-06-08  1.0  3   test  foo
1  1.0 2017-06-08  1.0  3  train  foo
2  1.0 2017-06-08  1.0  3   test  foo
3  1.0 2017-06-08  1.0  3  train  foo
```

每列数据的格式用 dtypes 查看
```python
In [12]: df2.dtypes
Out[12]:
A           float64
B    datetime64[ns]
C           float32
D             int32
E          category
F            object
dtype: object
```

### 数据查看

查看指定列的数据
```python
In [15]: df2.A
Out[15]:
0    1.0
1    1.0
2    1.0
3    1.0
Name: A, dtype: float64
```

用 head 和 tail 查看顶端和底端的几列, `head()`和`tail()`函数默认值都是5
```python
In [16]: df.head()                                 
Out[16]:                                           
                   A         B         C         D 
2017-06-08 -0.561773  0.881191 -2.697783 -0.034672 
2017-06-09 -0.053409  0.814811  0.294231 -1.753744 
2017-06-10 -1.699722  0.971518 -2.592852  1.088473 
2017-06-11 -2.411028  0.312229 -1.879164  1.388484 
2017-06-12 -0.173929 -0.572149  2.044024 -0.101223 
                                                   
In [17]: df.tail(3)                                
Out[17]:                                           
                   A         B         C         D 
2017-06-11 -2.411028  0.312229 -1.879164  1.388484 
2017-06-12 -0.173929 -0.572149  2.044024 -0.101223 
2017-06-13 -0.906777 -0.207889 -0.776134  2.327599 
                                                   
In [18]: df.head(2)                                
Out[18]:                                           
                   A         B         C         D 
2017-06-08 -0.561773  0.881191 -2.697783 -0.034672 
2017-06-09 -0.053409  0.814811  0.294231 -1.753744 
                                                   
In [19]: df.tail()                                 
Out[19]:                                           
                   A         B         C         D 
2017-06-09 -0.053409  0.814811  0.294231 -1.753744 
2017-06-10 -1.699722  0.971518 -2.592852  1.088473 
2017-06-11 -2.411028  0.312229 -1.879164  1.388484 
2017-06-12 -0.173929 -0.572149  2.044024 -0.101223 
2017-06-13 -0.906777 -0.207889 -0.776134  2.327599 
```

单独查看 index 和 columns 和 数据, DataFrame 内部用 numpy 格式存储数据
```python
In [20]: df.index
Out[20]:
DatetimeIndex(['2017-06-08', '2017-06-09', '2017-06-10', '2017-06-11',
               '2017-06-12', '2017-06-13'],
              dtype='datetime64[ns]', freq='D')

In [21]: df.columns
Out[21]: Index(['A', 'B', 'C', 'D'], dtype='object')

In [22]: df.values
Out[22]:
array([[-0.56177253,  0.88119144, -2.6977834 , -0.03467225],
       [-0.05340873,  0.81481114,  0.29423114, -1.75374372],
       [-1.69972161,  0.97151768, -2.59285248,  1.08847275],
       [-2.41102846,  0.3122287 , -1.87916396,  1.38848363],
       [-0.17392908, -0.57214913,  2.04402398, -0.10122313],
       [-0.90677665, -0.20788934, -0.77613381,  2.32759919]])
```

describe() 显示数据的概要。
```python
In [23]: df.describe()
Out[23]:
              A         B         C         D
count  6.000000  6.000000  6.000000  6.000000
mean  -0.967773  0.366618 -0.934613  0.485819
std    0.922339  0.639667  1.852466  1.428378
min   -2.411028 -0.572149 -2.697783 -1.753744
25%   -1.501485 -0.077860 -2.414430 -0.084585
50%   -0.734275  0.563520 -1.327649  0.526900
75%   -0.270890  0.864596  0.026640  1.313481
max   -0.053409  0.971518  2.044024  2.327599
```

和 numpy 一样，可以方便的得到转置,就是行列转换 
```python
In [24]: df.T
Out[24]:
   2017-06-08  2017-06-09  2017-06-10  2017-06-11  2017-06-12  2017-06-13
A   -0.561773   -0.053409   -1.699722   -2.411028   -0.173929   -0.906777
B    0.881191    0.814811    0.971518    0.312229   -0.572149   -0.207889
C   -2.697783    0.294231   -2.592852   -1.879164    2.044024   -0.776134
D   -0.034672   -1.753744    1.088473    1.388484   -0.101223    2.327599
```

对 axis 按照 index 排序（axis=1 是指根据列名来排序, axis=0 是根据行名来排序）
```python
In [26]: df.sort_index(axis=1, ascending=False)
Out[26]:
                   D         C         B         A
2017-06-08 -0.034672 -2.697783  0.881191 -0.561773
2017-06-09 -1.753744  0.294231  0.814811 -0.053409
2017-06-10  1.088473 -2.592852  0.971518 -1.699722
2017-06-11  1.388484 -1.879164  0.312229 -2.411028
2017-06-12 -0.101223  2.044024 -0.572149 -0.173929
2017-06-13  2.327599 -0.776134 -0.207889 -0.906777
```

按值排序
```python
In [30]: df.sort_values(by='B')
Out[30]:
                   A         B         C         D
2017-06-12 -0.173929 -0.572149  2.044024 -0.101223
2017-06-13 -0.906777 -0.207889 -0.776134  2.327599
2017-06-11 -2.411028  0.312229 -1.879164  1.388484
2017-06-09 -0.053409  0.814811  0.294231 -1.753744
2017-06-08 -0.561773  0.881191 -2.697783 -0.034672
2017-06-10 -1.699722  0.971518 -2.592852  1.088473
```

### 选择
**注意:** 以下这些对交互式环境很友好，但是作为 production code 请用优化过的 `.at, .iat, .loc, .iloc, .ix`等.

获取行/列
从 DataFrame 选择一个列，就得到了 Series
```python
In [31]: df['A']
Out[31]:
2017-06-08   -0.561773
2017-06-09   -0.053409
2017-06-10   -1.699722
2017-06-11   -2.411028
2017-06-12   -0.173929
2017-06-13   -0.906777
Freq: D, Name: A, dtype: float64
```

使用[] 对行切片
```python
In [35]: df[0:3]
Out[35]:
                   A         B         C         D
2017-06-08 -0.561773  0.881191 -2.697783 -0.034672
2017-06-09 -0.053409  0.814811  0.294231 -1.753744
2017-06-10 -1.699722  0.971518 -2.592852  1.088473
```

通过标签选择
通过时间戳的下标（dates[0] = Timestamp('20130101')）来访问
```python
In [36]: df.loc[dates[1]]
Out[36]:
A   -0.053409
B    0.814811
C    0.294231
D   -1.753744
Name: 2017-06-09 00:00:00, dtype: float64
```

选择多个标签
```python
In [38]: df.loc[:,['A', 'B']]
Out[38]:
                   A         B
2017-06-08 -0.561773  0.881191
2017-06-09 -0.053409  0.814811
2017-06-10 -1.699722  0.971518
2017-06-11 -2.411028  0.312229
2017-06-12 -0.173929 -0.572149
2017-06-13 -0.906777 -0.207889
```

注意那个冒号，用法和 MATLAB 或 NumPy 是一样的！所以也可以这样
```python
In [39]: df.loc[dates[0]:dates[2], ['A', 'B']]
Out[39]:
                   A         B
2017-06-08 -0.561773  0.881191
2017-06-09 -0.053409  0.814811
2017-06-10 -1.699722  0.971518
```

依旧和 MATLAB 一样，当有一个维度是标量（而不是范围或序列）的时候，选择出的矩阵维度会减少
```python
In [40]: df.loc[dates[0], ['A', 'B']]
Out[40]:
A   -0.561773
B    0.881191
Name: 2017-06-08 00:00:00, dtype: float64
```

如果对所有的维度都写了标量，不就是选出一个元素吗？
```python
In [41]: df.loc[dates[0], 'A']
Out[41]: -0.56177252662051747
```

这种情况通常用 at ，速度更快
```python
In [42]: df.at[dates[0], 'A']
Out[42]: -0.56177252662051747
```

通过位置选择,即整数下标选择, 和 MATLAB 完全一样
这个就和数组类似啦，直接看例子。选出第4行：
```python
In [43]: df.iloc[3]
Out[43]:
A   -2.411028
B    0.312229
C   -1.879164
D    1.388484
Name: 2017-06-11 00:00:00, dtype: float64
```

选出3~4行，0~1列：
```python
In [45]: df.iloc[3:5, 0:2]
Out[45]:
                   A         B
2017-06-11 -2.411028  0.312229
2017-06-12 -0.173929 -0.572149
```

也能用 list 选择, 挑出指定行和列
```python
In [46]: df.iloc[[1, 2, 4], [0, 3]]
Out[46]:
                   A         D
2017-06-09 -0.053409 -1.753744
2017-06-10 -1.699722  1.088473
2017-06-12 -0.173929 -0.101223
```

也可以用slice
```python
In [47]: df.iloc[1:3, 1:3]
Out[47]:
                   B         C
2017-06-09  0.814811  0.294231
2017-06-10  0.971518 -2.592852
```

选择单个元素
```python
In [48]: df.iloc[0,0]
Out[48]: -0.56177252662051747

In [49]: df.iat[0,0]
Out[49]: -0.56177252662051747
```

### 布尔值索引
根据单列的值来选择数据



### 参考
* [pandas十分钟入门](http://pandas.pydata.org/pandas-docs/stable/10min.html)