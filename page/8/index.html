<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Simple & Freedom" type="application/atom+xml" />






<meta name="description" content="Learn and live.">
<meta property="og:type" content="website">
<meta property="og:title" content="Simple &amp; Freedom">
<meta property="og:url" content="http://arvin-he.github.io/page/8/index.html">
<meta property="og:site_name" content="Simple &amp; Freedom">
<meta property="og:description" content="Learn and live.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple &amp; Freedom">
<meta name="twitter:description" content="Learn and live.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://arvin-he.github.io/page/8/"/>





  <title>Simple & Freedom</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Simple & Freedom</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Learn and live.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/07/27/py-pyautogui-2017-07-27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/27/py-pyautogui-2017-07-27/" itemprop="url">pyautogui使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-27T09:24:02+08:00">
                2017-07-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="PyAutoGUI——让所有GUI都自动化"><a href="#PyAutoGUI——让所有GUI都自动化" class="headerlink" title="PyAutoGUI——让所有GUI都自动化"></a>PyAutoGUI——让所有GUI都自动化</h3><p>本教程译自大神Al Sweigart的PyAutoGUI项目，Python自动化工具，更适合处理GUI任务，网页任务推荐：</p>
<ul>
<li>Selenium+Firefox记录（Chromedriver和Phantomjs也很给力，Phantomjs虽然是无头浏览器，但有时定位不准），然后用Python写单元测试</li>
<li>request处理get/post请求写一堆代码自动化处理，都在后台运行，不用运行浏览器，非常适合处理表单</li>
</ul>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>PyAutoGUI是一个纯Python的GUI自动化工具，其目的是可以用程序自动控制鼠标和键盘操作，多平台支持（Windows，OS X，Linux）。可以用pip安装，Github上有<a href="https://github.com/asweigart/pyautogui" target="_blank" rel="external">源代码</a>。</p>
<p>PyAutoGUI可以模拟鼠标的移动、点击、拖拽，键盘按键输入、按住操作，以及鼠标+键盘的热键同时按住等操作，可以说手能动的都可以。</p>
<p>让鼠标移到屏幕中央<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">screenWidth, screenHeight = pyautogui.size()</div><div class="line">pyautogui.moveTo(screenWidth / <span class="number">2</span>, screenHeight / <span class="number">2</span>)</div></pre></td></tr></table></figure></p>
<p>一些例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">screenWidth, screenHeight = pyautogui.size()</div><div class="line">currentMouseX, currentMouseY = pyautogui.position()</div><div class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">150</span>)</div><div class="line">pyautogui.click()</div><div class="line"><span class="comment">#  鼠标向下移动10像素</span></div><div class="line">pyautogui.moveRel(<span class="keyword">None</span>, <span class="number">10</span>)</div><div class="line">pyautogui.doubleClick()</div><div class="line"><span class="comment">#  用缓动/渐变函数让鼠标2秒后移动到(500,500)位置</span></div><div class="line"><span class="comment">#  use tweening/easing function to move mouse over 2 seconds.</span></div><div class="line">pyautogui.moveTo(<span class="number">1800</span>, <span class="number">500</span>, duration=<span class="number">2</span>, tween=pyautogui.easeInOutQuad)</div><div class="line"><span class="comment">#  在每次输入之间暂停0.25秒</span></div><div class="line">pyautogui.typewrite(<span class="string">'Hello world!'</span>, interval=<span class="number">0.25</span>)</div><div class="line">pyautogui.press(<span class="string">'esc'</span>)</div><div class="line">pyautogui.keyDown(<span class="string">'shift'</span>)</div><div class="line">pyautogui.press([<span class="string">'left'</span>, <span class="string">'left'</span>, <span class="string">'left'</span>, <span class="string">'left'</span>, <span class="string">'left'</span>, <span class="string">'left'</span>])</div><div class="line">pyautogui.keyUp(<span class="string">'shift'</span>)</div><div class="line">pyautogui.hotkey(<span class="string">'ctrl'</span>, <span class="string">'c'</span>)</div></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">distance = <span class="number">200</span></div><div class="line"><span class="keyword">while</span> distance &gt; <span class="number">0</span>:</div><div class="line">    pyautogui.dragRel(distance, <span class="number">0</span>, duration=<span class="number">0.5</span>) <span class="comment"># 向右</span></div><div class="line">    distance -= <span class="number">5</span></div><div class="line">    pyautogui.dragRel(<span class="number">0</span>, distance, duration=<span class="number">0.5</span>) <span class="comment"># 向下</span></div><div class="line">    pyautogui.draIn gRel(-distance, <span class="number">0</span>, duration=<span class="number">0.5</span>) <span class="comment"># 向左</span></div><div class="line">    distance -= <span class="number">5</span></div><div class="line">    pyautogui.dragRel(<span class="number">0</span>, -distance, duration=<span class="number">0.5</span>) <span class="comment"># 向上</span></div></pre></td></tr></table></figure>
<h3 id="保护措施"><a href="#保护措施" class="headerlink" title="保护措施"></a>保护措施</h3><p>为了能够及时中断，PyAutoGUI提供了一个保护措施。当pyautogui.FAILSAFE = True时，如果把鼠标光标在屏幕左上角，PyAutoGUI函数就会产生pyautogui.FailSafeException异常。如果失控了，需要中断PyAutoGUI函数，就把鼠标光标在屏幕左上角。要禁用这个特性，就把FAILSAFE设置成False：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">pyautogui.FAILSAFE = <span class="keyword">False</span></div></pre></td></tr></table></figure></p>
<p>通过把pyautogui.PAUSE设置成float或int时间（秒），可以为所有的PyAutoGUI函数增加延迟。默认延迟时间是0.1秒。在函数循环执行的时候，这样做可以让PyAutoGUI运行的慢一点，非常有用。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">pyautogui.PAUSE = <span class="number">2.5</span></div><div class="line">pyautogui.moveTo(<span class="number">100</span>,<span class="number">100</span>); pyautogui.click()</div></pre></td></tr></table></figure></p>
<p>所有的PyAutoGUI函数在延迟完成前都处于阻塞状态（block）。（未来计划增加一个可选的非阻塞模式来调用函数。）建议PAUSE和FAILSAFE一起使用。</p>
<h3 id="Cheat-Sheet"><a href="#Cheat-Sheet" class="headerlink" title="Cheat Sheet"></a>Cheat Sheet</h3><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line"><span class="comment">#  当前鼠标的坐标</span></div><div class="line">pyautogui.position() <span class="comment"># (123, 372)</span></div><div class="line"><span class="comment">#  当前屏幕的分辨率（宽度和高度）</span></div><div class="line">pyautogui.size()  <span class="comment"># (1920, 1080)</span></div><div class="line"><span class="comment">#  (x,y)是否在屏幕上</span></div><div class="line">x, y = <span class="number">122</span>, <span class="number">244</span></div><div class="line">pyautogui.onScreen(x, y)  <span class="comment"># True</span></div></pre></td></tr></table></figure>
<h4 id="保护措施-1"><a href="#保护措施-1" class="headerlink" title="保护措施"></a>保护措施</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># PyAutoGUI函数增加延迟为2.5秒：</span></div><div class="line">pyautogui.PAUSE = <span class="number">2.5</span></div><div class="line"><span class="comment"># 当pyautogui.FAILSAFE = True时，如果把鼠标光标在屏幕左上角，PyAutoGUI函数就会产生pyautogui.FailSafeException异常。</span></div><div class="line">pyautogui.FAILSAFE = <span class="keyword">True</span></div></pre></td></tr></table></figure>
<h4 id="鼠标函数"><a href="#鼠标函数" class="headerlink" title="鼠标函数"></a>鼠标函数</h4><p>坐标系的原点是左上角。X轴（水平）坐标向右增大，Y轴（竖直）坐标向下增大。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">num_seconds = <span class="number">1.2</span></div><div class="line"><span class="comment">#  用num_seconds秒的时间把光标移动到(x, y)位置</span></div><div class="line">pyautogui.moveTo(x, y, duration=num_seconds)</div><div class="line"><span class="comment">#  用num_seconds秒的时间把光标的X轴（水平）坐标移动xOffset，</span></div><div class="line"><span class="comment">#  Y轴（竖直）坐标向下移动yOffset。</span></div><div class="line">xOffset, yOffset = <span class="number">50</span>, <span class="number">100</span></div><div class="line">pyautogui.moveRel(xOffset, yOffset, duration=num_seconds)</div></pre></td></tr></table></figure></p>
<p>click()函数就是让鼠标点击，默认是单击左键，参数可以设置,其中，button属性可以设置成left，middle和right。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyautogui.click(x=moveToX, y=moveToY, clicks=num_of_clicks, interval=secs_between_clicks, button=<span class="string">'left'</span>)</div></pre></td></tr></table></figure></p>
<p>所有的点击都可以用这个函数，不过下面的函数可读性更好：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pyautogui.rightClick(x=moveToX, y=moveToY)</div><div class="line">pyautogui.middleClick(x=moveToX, y=moveToY)</div><div class="line">pyautogui.doubleClick(x=moveToX, y=moveToY)</div><div class="line">pyautogui.tripleClick(x=moveToX, y=moveToY)</div></pre></td></tr></table></figure></p>
<p>scroll函数控制鼠标滚轮的滚动，<code>amount_to_scroll</code>参数表示滚动的格数。正数则页面向上滚动，负数则向下滚动：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyautogui.scroll(clicks=amount_to_scroll, x=moveToX, y=moveToY)</div></pre></td></tr></table></figure></p>
<p>每个按键按下和松开两个事件可以分开处理：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pyautogui.mouseDown(x=moveToX, y=moveToY, button=<span class="string">'left'</span>)</div><div class="line">pyautogui.mouseUp(x=moveToX, y=moveToY, button=<span class="string">'left'</span>)</div></pre></td></tr></table></figure></p>
<h3 id="键盘函数"><a href="#键盘函数" class="headerlink" title="键盘函数"></a>键盘函数</h3><p>键盘上可以按的键都可以调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  每次键入的时间间隔</span></div><div class="line">secs_between_keys = <span class="number">0.1</span></div><div class="line">pyautogui.typewrite(<span class="string">'Hello world!\n'</span>, interval=secs_between_keys)</div></pre></td></tr></table></figure></p>
<p>多个键也可以：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pyautogui.typewrite([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'left'</span>, <span class="string">'backspace'</span>, <span class="string">'enter'</span>, <span class="string">'f1'</span>], interval=secs_between_keys)</div></pre></td></tr></table></figure></p>
<p>按键名称列表：<code>pyautogui.KEYBOARD_KEYS[:10]</code><br>[‘\t’, ‘\n’, ‘\r’, ‘ ‘, ‘!’, ‘“‘, ‘#’, ‘$’, ‘%’, ‘&amp;’]</p>
<p>键盘的一些热键像Ctrl-S或Ctrl-Shift-1都可以用hotkey()函数来实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pyautogui.hotkey(<span class="string">'ctrl'</span>, <span class="string">'a'</span>) <span class="comment"># 全选</span></div><div class="line">pyautogui.hotkey(<span class="string">'ctrl'</span>, <span class="string">'c'</span>) <span class="comment"># 复制</span></div><div class="line">pyautogui.hotkey(<span class="string">'ctrl'</span>, <span class="string">'v'</span>) <span class="comment"># 粘贴</span></div></pre></td></tr></table></figure></p>
<p>每个按键的按下和松开也可以单独调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pyautogui.keyDown(key_name)</div><div class="line">pyautogui.keyUp(key_name)</div></pre></td></tr></table></figure></p>
<h3 id="消息弹窗函数"><a href="#消息弹窗函数" class="headerlink" title="消息弹窗函数"></a>消息弹窗函数</h3><p>如果你需要消息弹窗，通过单击OK暂停程序，或者向用户显示一些信息，消息弹窗函数就会有类似JavaScript的功能：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pyautogui.alert(<span class="string">'这个消息弹窗是文字+OK按钮'</span>)</div><div class="line">pyautogui.confirm(<span class="string">'这个消息弹窗是文字+OK+Cancel按钮'</span>)</div><div class="line">pyautogui.prompt(<span class="string">'这个消息弹窗是让用户输入字符串，单击OK'</span>)</div><div class="line"><span class="comment"># 在prompt()函数中，如果用户什么都不输入，就会返回None。</span></div></pre></td></tr></table></figure></p>
<h3 id="截屏函数"><a href="#截屏函数" class="headerlink" title="截屏函数"></a>截屏函数</h3><p>PyAutoGUI用Pillow/PIL库实现图片相关的识别和操作。<br>在Linux里面，你必须执行<code>sudo apt-get install scrot</code>来使用截屏特性。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  返回一个Pillow/PIL的Image对象</span></div><div class="line">pyautogui.screenshot()</div><div class="line">pyautogui.screenshot(<span class="string">'foo.png'</span>)</div></pre></td></tr></table></figure></p>
<p>如果你有一个图片文件想在上面做点击操作，你可以用locateOnScreen()函数来定位。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  返回(最左x坐标，最顶y坐标，宽度，高度)</span></div><div class="line">pyautogui.locateOnScreen(<span class="string">'pyautogui/looks.png'</span>)</div><div class="line"><span class="comment"># (0, 1040, 48, 40)</span></div></pre></td></tr></table></figure></p>
<p>locateAllOnScreen()函数会寻找所有相似图片，返回一个生成器：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pyautogui.locateAllOnScreen(<span class="string">'pyautogui/looks.png'</span>):</div><div class="line">    print(i)</div><div class="line"><span class="comment"># (0, 1040, 48, 40)</span></div><div class="line">list(pyautogui.locateAllOnScreen(<span class="string">'pyautogui/looks.png'</span>))</div><div class="line"><span class="comment"># (0, 1040, 48, 40)</span></div></pre></td></tr></table></figure></p>
<p>locateCenterOnScreen()函数会返回图片在屏幕上的中心XY轴坐标值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pyautogui.locateCenterOnScreen(<span class="string">'pyautogui/looks.png'</span>)</div><div class="line"><span class="comment"># (24, 1060)</span></div></pre></td></tr></table></figure></p>
<p>如果没找到图片会返回None。定位比较慢，一般得用1~2秒.</p>
<h3 id="常用函数-1"><a href="#常用函数-1" class="headerlink" title="常用函数"></a>常用函数</h3><p>position()：返回整数元组(x, y)，分别表示鼠标光标所在位置的XY轴坐标<br>size()：返回显示器的尺寸整数元组(x, y)。未来将加入多屏支持</p>
<h3 id="鼠标控制函数"><a href="#鼠标控制函数" class="headerlink" title="鼠标控制函数"></a>鼠标控制函数</h3><h4 id="屏幕与鼠标位置"><a href="#屏幕与鼠标位置" class="headerlink" title="屏幕与鼠标位置"></a>屏幕与鼠标位置</h4><p>屏幕位置使用X和Y轴的笛卡尔坐标系。原点(0,0)在左上角，分别向右、向下增大。<br>如果屏幕像素是 1920×1080，那么右下角的坐标是(1919, 1079), 左上角是从(0, 0)开始的。<br>分辨率大小可以通过size()函数返回整数元组。光标的位置用position()返回。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pyautogui.size()</div><div class="line"><span class="comment"># (1920, 1080)</span></div><div class="line">pyautogui.position()</div><div class="line"><span class="comment"># (272, 688)</span></div></pre></td></tr></table></figure></p>
<p>下面是Python 3版本的光标位置记录程序：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ! python 3</span></div><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">print(<span class="string">'Press Ctrl-C to quit'</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        x, y = pyautogui.position()</div><div class="line">        positionStr = <span class="string">'X: &#123;&#125; Y: &#123;&#125;'</span>.format(*[str(x).rjust(<span class="number">4</span>) <span class="keyword">for</span> x <span class="keyword">in</span> [x, y]])</div><div class="line">        print(positionStr, end=<span class="string">''</span>)</div><div class="line">        print(<span class="string">'\b'</span> * len(positionStr), end=<span class="string">''</span>, flush=<span class="keyword">True</span>)</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt:</div><div class="line">    print(<span class="string">'\n'</span>)</div></pre></td></tr></table></figure></p>
<p>要检查XY坐标是否在屏幕上，需要用onScreen()函数来检验，如果在屏幕上返回True：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">pyautogui.onScreen(<span class="number">0</span>, <span class="number">0</span>) <span class="comment"># True</span></div><div class="line">pyautogui.onScreen(<span class="number">0</span>, <span class="number">-1</span>) <span class="comment"># False</span></div><div class="line">pyautogui.onScreen(<span class="number">0</span>, <span class="number">2080</span>) <span class="comment"># False</span></div><div class="line">pyautogui.onScreen(<span class="number">1920</span>, <span class="number">1080</span>) <span class="comment"># False</span></div><div class="line">pyautogui.onScreen(<span class="number">1919</span>, <span class="number">1079</span>) <span class="comment"># True</span></div></pre></td></tr></table></figure></p>
<h4 id="鼠标行为"><a href="#鼠标行为" class="headerlink" title="鼠标行为"></a>鼠标行为</h4><p>moveTo()函数会把鼠标光标移动到指定的XY轴坐标处。如果传入None值，则表示使用当前光标的对象轴坐标值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">200</span>)     <span class="comment"># 光标移动到(100, 200)位置</span></div><div class="line">pyautogui.moveTo(<span class="keyword">None</span>, <span class="number">500</span>)   <span class="comment"># 光标移动到(100, 500)位置</span></div><div class="line">pyautogui.moveTo(<span class="number">600</span>, <span class="keyword">None</span>)   <span class="comment"># 光标移动到(600, 500)位置</span></div><div class="line"><span class="comment">#一般鼠标光标都是瞬间移动到指定的位置，如果你想让鼠标移动的慢点，可以设置持续时间：</span></div><div class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">200</span>, duration=<span class="number">2</span>)     <span class="comment"># 用2秒把光标移动到(100, 200)位置</span></div></pre></td></tr></table></figure></p>
<p>默认的持续时间pyautogui.MINIMUM_DURATION是0.1秒，如果你设置的时间比默认值还短，那么就会瞬间执行。</p>
<p>如果你想让光标以当前位置为原点，进行相对移动，就用pyautogui.moveRel()函数。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">200</span>) <span class="comment">#把光标移动到(100, 200)位置</span></div><div class="line">pyautogui.moveRel(<span class="number">0</span>, <span class="number">50</span>)   <span class="comment">#向下移动50</span></div><div class="line">pyautogui.moveRel(<span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>)   <span class="comment">#向右移动30</span></div><div class="line">pyautogui.moveRel(<span class="number">30</span>, <span class="keyword">None</span>)   <span class="comment">#向右移动30</span></div></pre></td></tr></table></figure></p>
<h4 id="鼠标拖拽"><a href="#鼠标拖拽" class="headerlink" title="鼠标拖拽"></a>鼠标拖拽</h4><p>PyAutoGUI的dragTo()和dragRel()函数与moveTo()和moveRel()函数类似。另外，他们有一个button参数可以设置成left，middle和right三个键。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  按住鼠标左键，把鼠标拖拽到(100, 200)位置</span></div><div class="line">pyautogui.dragTo(<span class="number">100</span>, <span class="number">200</span>, button=<span class="string">'left'</span>)</div><div class="line"><span class="comment">#  按住鼠标左键，用2秒钟把鼠标拖拽到(300, 400)位置</span></div><div class="line">pyautogui.dragTo(<span class="number">300</span>, <span class="number">400</span>, <span class="number">2</span>, button=<span class="string">'left'</span>)</div><div class="line"><span class="comment">#  按住鼠标右键，用2秒钟把鼠标拖拽到(30,0)位置</span></div><div class="line">pyautogui.dragTo(<span class="number">30</span>, <span class="number">0</span>, <span class="number">2</span>, button=<span class="string">'right'</span>)</div></pre></td></tr></table></figure></p>
<h4 id="缓动-渐变（Tween-Easing）函数"><a href="#缓动-渐变（Tween-Easing）函数" class="headerlink" title="缓动/渐变（Tween / Easing）函数"></a>缓动/渐变（Tween / Easing）函数</h4><p>缓动/渐变函数的作用是让光标的移动更炫。如果你不需要用到的话，你可以忽略这些。</p>
<p>缓动/渐变函数可以改变光标移动过程的速度和方向。通常鼠标是匀速直线运动，这就是线性缓动/渐变函数。PyAutoGUI有30种缓动/渐变函数，可以通过<code>pyautogui.ease*?</code>查看。其中，pyautogui.easeInQuad()函数可以用于moveTo()，moveRel()，dragTo()和dragRel()函数，光标移动呈现先慢后快的效果，整个过程的时间还是和原来一样。而pyautogui.easeOutQuad函数的效果相反：光标开始移动很快，然后慢慢减速。pyautogui.easeOutElastic是弹簧效果，首先越过终点，然后再反弹回来。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  开始很慢，不断加速</span></div><div class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">100</span>, <span class="number">2</span>, pyautogui.easeInQuad)</div><div class="line"><span class="comment">#  开始很快，不断减速</span></div><div class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">100</span>, <span class="number">2</span>, pyautogui.easeOutQuad)</div><div class="line"><span class="comment">#  开始和结束都快，中间比较慢</span></div><div class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">100</span>, <span class="number">2</span>, pyautogui.easeInOutQuad)</div><div class="line"><span class="comment">#  一步一徘徊前进</span></div><div class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">100</span>, <span class="number">2</span>, pyautogui.easeInBounce)</div><div class="line"><span class="comment">#  徘徊幅度更大，甚至超过起点和终点</span></div><div class="line">pyautogui.moveTo(<span class="number">100</span>, <span class="number">100</span>, <span class="number">2</span>, pyautogui.easeInElastic)</div></pre></td></tr></table></figure></p>
<p>这些效果函数是模仿Al Sweigart的PyTweening模块，可以直接使用，不需要额外安装。<br>如果你想创建自己的效果，也可以定义一个函数，其参数是(0.0,1.0)，表示起点和终点，返回值是介于[0.0,1.0]之间的数。</p>
<h4 id="鼠标单击"><a href="#鼠标单击" class="headerlink" title="鼠标单击"></a>鼠标单击</h4><p>click()函数模拟单击鼠标左键一次的行为。例如：<code>pyautogui.click()</code><br>如果单击之前要先移动，可以把目标的XY坐标值传入函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  先移动到(100, 200)再单击</span></div><div class="line">pyautogui.click(x=<span class="number">100</span>, y=<span class="number">200</span>, duration=<span class="number">2</span>)</div><div class="line"><span class="comment"># 可以通过button参数设置left，middle和right三个键。例如：</span></div><div class="line">pyautogui.click(button=<span class="string">'right'</span>)</div></pre></td></tr></table></figure></p>
<p>要做多次单击可以设置clicks参数，还有interval参数可以设置每次单击之间的时间间隔。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  双击左键</span></div><div class="line">pyautogui.click(clicks=<span class="number">2</span>)</div><div class="line"><span class="comment">#  两次单击之间停留0.25秒</span></div><div class="line">pyautogui.click(clicks=<span class="number">2</span>, interval=<span class="number">0.25</span>)</div><div class="line"><span class="comment">#  三击右键</span></div><div class="line">pyautogui.click(button=<span class="string">'right'</span>, clicks=<span class="number">2</span>, interval=<span class="number">0.25</span>)</div></pre></td></tr></table></figure></p>
<p>为了操作方便，PyAutoGUI提供了doubleClick()，tripleClick()和rightClick()来实现双击、三击和右击操作。</p>
<h4 id="鼠标按下和松开函数"><a href="#鼠标按下和松开函数" class="headerlink" title="鼠标按下和松开函数"></a>鼠标按下和松开函数</h4><p>mouseDown()和mouseUp()函数可以实现鼠标按下和鼠标松开的操作。两者参数相同，有x，y和button。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  鼠标左键按下再松开</span></div><div class="line">pyautogui.mouseDown(); pyautogui.mouseUp() </div><div class="line"><span class="comment">#  按下鼠标右键</span></div><div class="line">pyautogui.mouseDown(button=<span class="string">'right'</span>) </div><div class="line"><span class="comment">#  移动到(100, 200)位置，然后松开鼠标右键</span></div><div class="line">pyautogui.mouseUp(button=<span class="string">'right'</span>, x=<span class="number">100</span>, y=<span class="number">200</span>)</div></pre></td></tr></table></figure></p>
<h4 id="滚轮滚动函数"><a href="#滚轮滚动函数" class="headerlink" title="滚轮滚动函数"></a>滚轮滚动函数</h4><p>鼠标滚轮滚动可以用scroll()函数和clicks次数参数来模拟。scroll()函数是vscroll()的一个包装（wrapper），执行竖直滚动。<br>不同平台上的clicks次数不太一样。还有x和y参数可以在滚动之前定位到(x, y)位置。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  向上滚动10格</span></div><div class="line">pyautogui.scroll(<span class="number">10</span>)</div><div class="line"><span class="comment">#  向下滚动10格</span></div><div class="line">pyautogui.scroll(<span class="number">-10</span>)</div><div class="line"><span class="comment">#  移动到(100, 100)位置再向上滚动10格</span></div><div class="line">pyautogui.scroll(<span class="number">10</span>, x=<span class="number">100</span>, y=<span class="number">100</span>)</div><div class="line"><span class="comment"># 在OS X和Linux平台上，PyAutoGUI还可以用hscroll()实现水平滚动。例如：</span></div><div class="line"><span class="comment">#  向右滚动10格</span></div><div class="line">pyautogui.hscroll(<span class="number">10</span>)</div><div class="line"><span class="comment">#  向左滚动10格</span></div><div class="line">pyautogui.hscroll(<span class="number">-10</span>)</div></pre></td></tr></table></figure></p>
<h3 id="键盘控制函数"><a href="#键盘控制函数" class="headerlink" title="键盘控制函数"></a>键盘控制函数</h3><h4 id="typewrite-输入函数"><a href="#typewrite-输入函数" class="headerlink" title="typewrite()输入函数"></a>typewrite()输入函数</h4><p>键盘控制的主要函数就是typewrite()。这个函数可以实现字符输入。typewrite()函数只能用于单个字符键，不能按SHITF和F1这些功能键。要在两次输入间增加时间间隔，可以用interval参数。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  输入Hello world!</span></div><div class="line">pyautogui.typewrite(<span class="string">'Hello world!'</span>)</div><div class="line"><span class="comment">#  每次输入间隔0.25秒，输入Hello world!</span></div><div class="line">pyautogui.typewrite(<span class="string">'Hello world!'</span>, interval=<span class="number">0.25</span>)</div></pre></td></tr></table></figure></p>
<h4 id="press-，keyDown-和keyUp-函数"><a href="#press-，keyDown-和keyUp-函数" class="headerlink" title="press()，keyDown()和keyUp()函数"></a>press()，keyDown()和keyUp()函数</h4><p>要按那些功能键，可以用press()函数把<code>pyautogui.KEYBOARD_KEYS</code>里面按键对应的字符串输入进去。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  ENTER键</span></div><div class="line">pyautogui.press(<span class="string">'enter'</span>)</div><div class="line"><span class="comment">#  F1键</span></div><div class="line">pyautogui.press(<span class="string">'f1'</span>)</div><div class="line"><span class="comment">#  左方向键</span></div><div class="line">pyautogui.press(<span class="string">'left'</span>)</div></pre></td></tr></table></figure>
<p>press()函数其实是keyDown()和keyUp()函数的包装，模拟的按下然后松开两个动作。这两个函数可以单独调用。例如，按下shift键的同时按3次左方向键：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  按下`shift`键</span></div><div class="line">pyautogui.keyDown(<span class="string">'shift'</span>)</div><div class="line">pyautogui.press(<span class="string">'left'</span>)</div><div class="line">pyautogui.press(<span class="string">'left'</span>)</div><div class="line">pyautogui.press(<span class="string">'left'</span>)</div><div class="line"><span class="comment">#  松开`shift`键</span></div><div class="line">pyautogui.keyUp(<span class="string">'shift'</span>)</div></pre></td></tr></table></figure></p>
<p>和typewrite()函数一样，可以用数组把一组键传入press()。例如：<br><code>pyautogui.press([&#39;left&#39;, &#39;left&#39;, &#39;left&#39;])</code></p>
<h4 id="hotkey-函数"><a href="#hotkey-函数" class="headerlink" title="hotkey()函数"></a>hotkey()函数</h4><p>为了更高效的输入热键，PyAutoGUI提供了hotkey()函数来绑定若干按键：<br><code>pyautogui.hotkey(&#39;ctrl&#39;, &#39;shift&#39;, &#39;ese&#39;)</code><br>等价于：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pyautogui.keyDown(<span class="string">'ctrl'</span>)</div><div class="line">pyautogui.keyDown(<span class="string">'shift'</span>)</div><div class="line">pyautogui.keyDown(<span class="string">'esc'</span>)</div><div class="line">pyautogui.keyUp(<span class="string">'esc'</span>)</div><div class="line">pyautogui.keyUp(<span class="string">'shift'</span>)</div><div class="line">pyautogui.keyUp(<span class="string">'ctrl'</span>)</div></pre></td></tr></table></figure></p>
<h4 id="KEYBOARD-KEYS"><a href="#KEYBOARD-KEYS" class="headerlink" title="KEYBOARD_KEYS"></a>KEYBOARD_KEYS</h4><p>下面就是press()，keyDown()，keyUp()和hotkey()函数可以输入的按键名称：<br><code>print(pyautogui.KEYBOARD_KEYS)</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&apos;\t&apos;, &apos;\n&apos;, &apos;\r&apos;, &apos; &apos;, &apos;!&apos;, &apos;&quot;&apos;, &apos;#&apos;, &apos;$&apos;, &apos;%&apos;, &apos;&amp;&apos;, &quot;&apos;&quot;, &apos;(&apos;, &apos;)&apos;, &apos;*&apos;, &apos;+&apos;, &apos;,&apos;, &apos;-&apos;, &apos;.&apos;, &apos;/&apos;, &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;:&apos;, &apos;;&apos;, &apos;&lt;&apos;, &apos;=&apos;, &apos;&gt;&apos;, &apos;?&apos;, &apos;@&apos;, &apos;[&apos;, &apos;\\&apos;, &apos;]&apos;, &apos;^&apos;, &apos;_&apos;, &apos;`&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;i&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;, &apos;m&apos;, &apos;n&apos;, &apos;o&apos;, &apos;p&apos;, &apos;q&apos;, &apos;r&apos;, &apos;s&apos;, &apos;t&apos;, &apos;u&apos;, &apos;v&apos;, &apos;w&apos;, &apos;x&apos;, &apos;y&apos;, &apos;z&apos;, &apos;&#123;&apos;, &apos;|&apos;, &apos;&#125;&apos;, &apos;~&apos;, &apos;accept&apos;, &apos;add&apos;, &apos;alt&apos;, &apos;altleft&apos;, &apos;altright&apos;, &apos;apps&apos;, &apos;backspace&apos;, &apos;browserback&apos;, &apos;browserfavorites&apos;, &apos;browserforward&apos;, &apos;browserhome&apos;, &apos;browserrefresh&apos;, &apos;browsersearch&apos;, &apos;browserstop&apos;, &apos;capslock&apos;, &apos;clear&apos;, &apos;convert&apos;, &apos;ctrl&apos;, &apos;ctrlleft&apos;, &apos;ctrlright&apos;, &apos;decimal&apos;, &apos;del&apos;, &apos;delete&apos;, &apos;divide&apos;, &apos;down&apos;, &apos;end&apos;, &apos;enter&apos;, &apos;esc&apos;, &apos;escape&apos;, &apos;execute&apos;, &apos;f1&apos;, &apos;f10&apos;, &apos;f11&apos;, &apos;f12&apos;, &apos;f13&apos;, &apos;f14&apos;, &apos;f15&apos;, &apos;f16&apos;, &apos;f17&apos;, &apos;f18&apos;, &apos;f19&apos;, &apos;f2&apos;, &apos;f20&apos;, &apos;f21&apos;, &apos;f22&apos;, &apos;f23&apos;, &apos;f24&apos;, &apos;f3&apos;, &apos;f4&apos;, &apos;f5&apos;, &apos;f6&apos;, &apos;f7&apos;, &apos;f8&apos;, &apos;f9&apos;, &apos;final&apos;, &apos;fn&apos;, &apos;hanguel&apos;, &apos;hangul&apos;, &apos;hanja&apos;, &apos;help&apos;, &apos;home&apos;, &apos;insert&apos;, &apos;junja&apos;, &apos;kana&apos;, &apos;kanji&apos;, &apos;launchapp1&apos;, &apos;launchapp2&apos;, &apos;launchmail&apos;, &apos;launchmediaselect&apos;, &apos;left&apos;, &apos;modechange&apos;, &apos;multiply&apos;, &apos;nexttrack&apos;, &apos;nonconvert&apos;, &apos;num0&apos;, &apos;num1&apos;, &apos;num2&apos;, &apos;num3&apos;, &apos;num4&apos;, &apos;num5&apos;, &apos;num6&apos;, &apos;num7&apos;, &apos;num8&apos;, &apos;num9&apos;, &apos;numlock&apos;, &apos;pagedown&apos;, &apos;pageup&apos;, &apos;pause&apos;, &apos;pgdn&apos;, &apos;pgup&apos;, &apos;playpause&apos;, &apos;prevtrack&apos;, &apos;print&apos;, &apos;printscreen&apos;, &apos;prntscrn&apos;, &apos;prtsc&apos;, &apos;prtscr&apos;, &apos;return&apos;, &apos;right&apos;, &apos;scrolllock&apos;, &apos;select&apos;, &apos;separator&apos;, &apos;shift&apos;, &apos;shiftleft&apos;, &apos;shiftright&apos;, &apos;sleep&apos;, &apos;stop&apos;, &apos;subtract&apos;, &apos;tab&apos;, &apos;up&apos;, &apos;volumedown&apos;, &apos;volumemute&apos;, &apos;volumeup&apos;, &apos;win&apos;, &apos;winleft&apos;, &apos;winright&apos;, &apos;yen&apos;, &apos;command&apos;, &apos;option&apos;, &apos;optionleft&apos;, &apos;optionright&apos;]</div></pre></td></tr></table></figure></p>
<h3 id="消息弹窗函数-1"><a href="#消息弹窗函数-1" class="headerlink" title="消息弹窗函数"></a>消息弹窗函数</h3><p>PyAutoGUI通过Tkinter实现了4种纯Python的消息弹窗函数，和JavaScript类似。</p>
<h4 id="alert-函数"><a href="#alert-函数" class="headerlink" title="alert()函数"></a>alert()函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pyautogui.alert(text=<span class="string">''</span>, title=<span class="string">''</span>, button=<span class="string">'OK'</span>)</div><div class="line"><span class="comment"># 'OK'</span></div></pre></td></tr></table></figure>
<p>显示一个简单的带文字和OK按钮的消息弹窗。用户点击后返回button的文字。</p>
<h4 id="confirm-函数"><a href="#confirm-函数" class="headerlink" title="confirm() 函数"></a>confirm() 函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#  OK和Cancel按钮的消息弹窗</span></div><div class="line">pyautogui.confirm(text=<span class="string">''</span>, title=<span class="string">''</span>, buttons=[<span class="string">'OK'</span>, <span class="string">'Cancel'</span>])</div><div class="line"><span class="comment">#  10个按键0-9的消息弹窗</span></div><div class="line">pyautogui.confirm(text=<span class="string">''</span>, title=<span class="string">''</span>, buttons=range(<span class="number">10</span>))</div></pre></td></tr></table></figure>
<p>显示一个简单的带文字、OK和Cancel按钮的消息弹窗，用户点击后返回被点击button的文字，支持自定义数字、文字的列表。</p>
<h4 id="prompt-函数"><a href="#prompt-函数" class="headerlink" title="prompt() 函数"></a>prompt() 函数</h4><p><code>pyautogui.prompt(text=&#39;&#39;, title=&#39;&#39; , default=&#39;&#39;)</code><br>可以输入的消息弹窗，带OK和Cancel按钮。用户点击OK按钮返回输入的文字，点击Cancel按钮返回None。</p>
<h4 id="password-函数"><a href="#password-函数" class="headerlink" title="password() 函数"></a>password() 函数</h4><p><code>pyautogui.password(text=&#39;&#39;, title=&#39;&#39;, default=&#39;&#39;, mask=&#39;*&#39;)</code><br>样式同prompt()，用于输入密码，消息用*表示。带OK和Cancel按钮。用户点击OK按钮返回输入的文字，点击Cancel按钮返回None。</p>
<h3 id="截屏函数-1"><a href="#截屏函数-1" class="headerlink" title="截屏函数"></a>截屏函数</h3><p>PyAutoGUI可以截屏并保存为图片文件，然后定位这些截屏在屏幕上的位置。与sikuli类似，把屏幕上的按键截取下来，然后定位，就可以执行点击等操作了。</p>
<p>截屏功能需要安装Pillow模块。OS X用screencapture命令，是系统自带的。Linux用户用scrot命令，可以通过<code>sudo apt-get install scrot</code>安装。</p>
<h4 id="Ubuntu注意事项"><a href="#Ubuntu注意事项" class="headerlink" title="Ubuntu注意事项"></a>Ubuntu注意事项</h4><p>由于Ubuntu上安装Pillow时缺少PNG和JPEG依赖，所以安装比较复杂，具体可以看Ubuntu论坛。不过用miniconda可以解决这些问题，如果Ubuntu或Mint上安装了miniconda，可以直接<code>conda install pillow</code>来安装。</p>
<h4 id="screenshot-函数"><a href="#screenshot-函数" class="headerlink" title="screenshot()函数"></a>screenshot()函数</h4><p>screenshot()函数会返回Image对象（参考Pillow或PIL模块文档），也可以设置文件名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">im1 = pyautogui.screenshot()</div><div class="line">im2 = pyautogui.screenshot(<span class="string">'my_screenshot.png'</span>)</div><div class="line"><span class="comment"># 在一个 1920×10801920×1080 的屏幕上，screenshot()函数要消耗100微秒——不快也不慢。</span></div><div class="line"></div><div class="line"><span class="comment">#如果你不需要截取整个屏幕，还有一个可选的region参数。你可以把截取区域的左上角XY坐标值和宽度、高度传入截取。</span></div><div class="line">im = pyautogui.screenshot(region=(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span> ,<span class="number">400</span>))</div></pre></td></tr></table></figure></p>
<h4 id="定位函数"><a href="#定位函数" class="headerlink" title="定位函数"></a>定位函数</h4><p>可以定位截图在屏幕上的坐标位置。比如，你需要在计算器里输入：</p>
<p><img src="/2017/07/27/py-pyautogui-2017-07-27/1.png" alt=""></p>
<p>如果你不知道按钮的位置，就不能用moveTo()定位和click()点击。而且每次计算器的位置可能会变化，这时即使有来坐标也不好用了。但是如果你有要点击按钮的截图，比如数字7：</p>
<p>你可以调用pyautogui.locateOnScreen(‘calc7key.png’)函数来获得7的屏幕坐标。返回的是一个元组(top, left, width, height)。这个元组可以用pyautogui.center()函数来获取截图屏幕的中心坐标。如果截图没找到，pyautogui.locateOnScreen()函数返回None：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">button7location = pyautogui.locateOnScreen(<span class="string">'pyautogui/calc7key.png'</span>)</div><div class="line">button7location</div><div class="line"><span class="comment"># (1226, 546, 29, 28)</span></div><div class="line">button7x, button7y = pyautogui.center(button7location)</div><div class="line">button7x, button7y</div><div class="line"><span class="comment"># (1240, 560)</span></div><div class="line">pyautogui.click(button7x, button7y)</div></pre></td></tr></table></figure></p>
<p>locateCenterOnScreen()等价于上面的前两布操作，直接获得截屏屏幕中心坐标：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">x, y = pyautogui.locateCenterOnScreen(<span class="string">'pyautogui/calc7key.png'</span>)</div><div class="line">pyautogui.click(x, y)</div></pre></td></tr></table></figure></p>
<p>在 1920×10801920×1080 的屏幕上，定位函数需要1~2秒时间。对视频游戏（LOL、DOTA）来说就太慢了，但是上班干活还是绰绰有余。</p>
<p>还是几个定位函数。都是从左上角原点开始向右向下搜索截图位置：</p>
<ul>
<li>locateOnScreen(image, grayscale=False)：返回找到的第一个截图Image对象在屏幕上的坐标(left, top, width, height)，如果没找到返回None</li>
<li>locateCenterOnScreen(image, grayscale=False)：返回找到的第一个截图Image对象在屏幕上的中心坐标(x, y)，如果没找到返回None</li>
<li>locateAllOnScreen(image, grayscale=False)：返回找到的所有相同截图Image对象在屏幕上的坐标(left, top, width, height)的生成器</li>
<li>locate(needleImage, haystackImage, grayscale=False)：返回找到的第一个截图Image对象在haystackImage里面的坐标(left, top, width, height)，如果没找到返回None</li>
<li>locateAll(needleImage, haystackImage, grayscale=False)：返回找到的所有相同截图Image对象在haystackImage里面的坐标(left, top, width, height)的生成器</li>
</ul>
<p>两个locateAll*函数都可以用for循环和list()输出：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> pos <span class="keyword">in</span> pyautogui.locateAllOnScreen(<span class="string">'pyautogui/calc7key.png'</span>):</div><div class="line">    print(pos)</div><div class="line"><span class="comment"># (1227, 546, 29, 28)</span></div><div class="line">list(pyautogui.locateAllOnScreen(<span class="string">'pyautogui/calc7key.png'</span>))</div><div class="line"><span class="comment"># [(1227, 546, 29, 28)]</span></div></pre></td></tr></table></figure></p>
<h4 id="灰度值匹配"><a href="#灰度值匹配" class="headerlink" title="灰度值匹配"></a>灰度值匹配</h4><p>可以把grayscale参数设置为True来加速定位（大约提升30%），默认为False。这种去色（desaturate）方法可以加速定位，但是也可能导致假阳性（false-positive）匹配：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">button7location = pyautogui.locateOnScreen(<span class="string">'pyautogui/calc7key.png'</span>, grayscale=<span class="keyword">True</span>)</div><div class="line">button7location</div><div class="line"><span class="comment"># (1227, 546, 29, 28)</span></div></pre></td></tr></table></figure></p>
<h4 id="像素匹配"><a href="#像素匹配" class="headerlink" title="像素匹配"></a>像素匹配</h4><p>要获取截屏某个位置的RGB像素值，可以用Image对象的getpixel()方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pyautogui</div><div class="line">im = pyautogui.screenshot()</div><div class="line">im.getpixel((<span class="number">100</span>, <span class="number">200</span>))</div><div class="line"><span class="comment"># (255, 255, 255)</span></div><div class="line"><span class="comment"># 也可以用PyAutoGUI的pixel()函数，是之前调用的包装：</span></div><div class="line">pyautogui.pixel(<span class="number">100</span>, <span class="number">200</span>)</div><div class="line"><span class="comment"># (255, 255, 255)</span></div></pre></td></tr></table></figure></p>
<p>如果你只是要检验一下指定位置的像素值，可以用pixelMatchesColor()函数，把X、Y和RGB元组值穿入即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">pyautogui.pixelMatchesColor(<span class="number">100</span>, <span class="number">200</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>))</div><div class="line"><span class="comment"># True</span></div><div class="line">pyautogui.pixelMatchesColor(<span class="number">100</span>, <span class="number">200</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">245</span>))</div><div class="line"><span class="comment"># False</span></div><div class="line"></div><div class="line"><span class="comment"># tolerance参数可以指定红、绿、蓝3种颜色误差范围：</span></div><div class="line">pyautogui.pixelMatchesColor(<span class="number">100</span>, <span class="number">200</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">245</span>), tolerance=<span class="number">10</span>)</div><div class="line"><span class="comment"># True</span></div><div class="line">pyautogui.pixelMatchesColor(<span class="number">100</span>, <span class="number">200</span>, (<span class="number">248</span>, <span class="number">250</span>, <span class="number">245</span>), tolerance=<span class="number">10</span>)</div><div class="line"><span class="comment"># True</span></div><div class="line">pyautogui.pixelMatchesColor(<span class="number">100</span>, <span class="number">200</span>, (<span class="number">205</span>, <span class="number">255</span>, <span class="number">245</span>), tolerance=<span class="number">10</span>)</div><div class="line"><span class="comment"># False</span></div></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://muxuezi.github.io/posts/doc-pyautogui.html" target="_blank" rel="external">https://muxuezi.github.io/posts/doc-pyautogui.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/07/22/js-this-2017-07-22/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/js-this-2017-07-22/" itemprop="url">Javascript之this用法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T15:23:53+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>this是Javascript语言的一个关键字。随着使用场合的不同，this的值会发生变化。<br>但是有一个总的原则，那就是this始终指的是，调用函数的那个对象。</p>
<h3 id="在全局作用域下"><a href="#在全局作用域下" class="headerlink" title="在全局作用域下"></a>在全局作用域下</h3><p>在浏览器环境下：全局作用域下，this 指向 Window 对象.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line"><span class="comment">// Window &#123; .. &#125;</span></div><div class="line"><span class="keyword">this</span> === <span class="built_in">window</span>;</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>在 node 环境下：全局作用域下，this 指向 global 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line"><span class="comment">// global</span></div><div class="line"><span class="keyword">this</span> === global;</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>严格模式，在 node 环境下：遵循严格模式的规范，this 不再指向全局对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line"><span class="comment">// &#123;&#125;</span></div></pre></td></tr></table></figure></p>
<h3 id="函数对象作用域下"><a href="#函数对象作用域下" class="headerlink" title="函数对象作用域下"></a>函数对象作用域下</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"><span class="comment">// global / Window</span></div></pre></td></tr></table></figure>
<p>严格模式，在 node 环境下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">foo();</div><div class="line"><span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<h3 id="作为对象方法的调用"><a href="#作为对象方法的调用" class="headerlink" title="作为对象方法的调用"></a>作为对象方法的调用</h3><p>作为对象方法时，this 指向该对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">obj.foo();</div><div class="line"><span class="comment">// &#123; foo: [Function] &#125;</span></div><div class="line"><span class="comment">// obj 的值实际上是个匿名类的对象，foo 的值实际上是个匿名函数</span></div></pre></td></tr></table></figure></p>
<p>注意到：在函数体内使用的、在函数体外定义（声明）的变量，是 <strong>传引用</strong> 的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> obj = &#123;</div><div class="line">    foo: func</div><div class="line">&#125;;</div><div class="line">obj.foo();</div><div class="line"><span class="comment">// &#123; foo: [Function func] &#125;</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> foo1 = obj.foo;</div><div class="line">foo1();</div><div class="line"><span class="comment">// global</span></div></pre></td></tr></table></figure></p>
<h3 id="在回调函数里面会遇到一些坑"><a href="#在回调函数里面会遇到一些坑" class="headerlink" title="在回调函数里面会遇到一些坑"></a>在回调函数里面会遇到一些坑</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  foo2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    setTimeout(<span class="keyword">this</span>.foo, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.foo2();</div></pre></td></tr></table></figure>
<p>执行这段代码我们会发现两次打印出来的 <code>this</code> 是不一样的：<br>第一次是 <code>foo2</code> 中直接打印 <code>this</code>，这里指向 <code>obj</code> 这个对象,<br>但是在 <code>setTimeout</code> 中执行的 <code>this.foo</code> ，却指向了全局对象.<br>把 <code>this.foo</code> 当作一个参数传给 <code>setTimeout</code> 这个函数，就像它需要一个 <code>fun</code> 参数，在传入参数的时候，其实做了个这样的操作 <code>fun = this.foo</code>，这里我们直接把 <code>fun</code> 指向 <code>this.foo</code> 的引用；执行的时候其实是执行了 <code>fun()</code> 所以已经和 <code>obj</code> 无关了，它是被当作普通函数直接调用的，因此 <code>this</code> 指向全局对象。</p>
<p>解决:<br>为了解决这个问题，我们可以利用 <strong>闭包</strong> 的特性来处理：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'qiutc'</span>,</div><div class="line">    foo2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Window</span></div><div class="line">      <span class="built_in">console</span>.log(_this);  <span class="comment">// Object &#123;name: "qiutc"&#125;</span></div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.foo2();</div></pre></td></tr></table></figure></p>
<p>可以看到直接用 <code>this</code> 仍然是 <code>Window</code>；因为 <code>foo2</code> 中的 <code>this</code> 是指向 <code>obj</code>，我们可以先用一个变量 <code>_this</code> 来储存，然后在回调函数中使用 <code>_this</code>，就可以指向当前的这个对象了；</p>
<p>setTimeout 的另一个坑<br>如果直接执行回调函数而没有绑定作用域，那么它的 <code>this</code> 是指向全局对象(<code>window</code>)，在严格模式下会指向 <code>undefined</code>，然而在 <code>setTimeout</code> 中的回调函数在严格模式下却表现出不同：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">&#125;</div><div class="line">setTimeout(foo, <span class="number">1</span>);</div><div class="line"><span class="comment">// window</span></div></pre></td></tr></table></figure></p>
<p>按理说我们加了严格模式，foo 调用也没有指定 <code>this</code>，应该是出来 <code>undefined</code>，但是这里仍然出现了全局对象，难道是严格模式失效了吗？</p>
<p>并不，即使在严格模式下，<code>setTimeout</code> 方法在调用传入函数的时候，如果这个函数没有指定了的 <code>this</code>，那么它会做一个隐式的操作—-自动地注入全局上下文，等同于调用 <code>foo.apply(window)</code> 而非 <code>foo()</code>；</p>
<p>当然，如果我们在传入函数的时候已经指定 <code>this</code>，那么就不会被注入全局对象，比如： <code>setTimeout(foo.bind(obj), 1);</code>；</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是 <code>this</code> 的指向了，<br>上文我们使用闭包来解决 <code>this</code> 的指向问题，但如果用上了箭头函数就可以更完美的解决了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  name: <span class="string">'qiutc'</span>,</div><div class="line">  foo: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">  &#125;,</div><div class="line">  foo2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);  <span class="comment">// Object &#123;name: "qiutc"&#125;</span></div><div class="line">    &#125;, <span class="number">1000</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">obj.foo2();</div></pre></td></tr></table></figure></p>
<p>可以看到，在 <code>setTimeout</code> 执行的函数中，本应该打印出在 <code>Window</code>，但是在这里 <code>this</code> 却指向了 <code>obj</code>，原因就在于，给 <code>setTimeout</code> 传入的函数（参数）是一个箭头函数：</p>
<p>函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。<br>关键点就是，箭头函数内的 <code>this</code> 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 <code>this</code>，也就是 <code>obj.foo2</code> 中的 <code>this</code>，即 <code>obj</code>；所以在执行箭头函数的时候，它的 <code>this</code> -&gt; <code>obj.foo2 中的 this</code> -&gt; <code>obj</code>；</p>
<p>简单来说， <strong>箭头函数中的 this 只和定义它时候的作用域的 this 有关，而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的</strong>。</p>
<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call / apply / bind"></a>call / apply / bind</h3><p>js 中的函数对象，其 prototype 中定义了如下三个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">func.call(thisArg[, arg1[, arg2[, ...]]]);</div><div class="line"><span class="comment">// 执行函数 func，使用第一个参数作为 this，其他参数作为 func 的实参，一一对应。</span></div><div class="line">func.apply(thisArg[, [arg1, arg2, ...]]);</div><div class="line"><span class="comment">// 执行函数 func，使用第一个参数作为 this，第二个参数为数组，数组中的每个元素作为 func 的实参，一一对应。</span></div><div class="line"><span class="keyword">var</span> foo = func.bind(thisArg[, arg1[, arg2[, ...]]]);</div><div class="line"><span class="comment">// 绑定 func 的 this 和所有参数，返回一个新的函数，但不执行它。</span></div></pre></td></tr></table></figure></p>
<p>bind 的 this 对 new 关键字无效，但其他实参有效：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    name: <span class="string">"obj"</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> B = A.bind(obj, <span class="string">"B"</span>);</div><div class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> B(<span class="string">'b'</span>);</div><div class="line"><span class="comment">// undefined B</span></div><div class="line"><span class="built_in">console</span>.log(obj.name);</div><div class="line"><span class="comment">// obj</span></div></pre></td></tr></table></figure></p>
<p>要注意，=&gt; 语法下的 this 不受影响，该语法下 this 视为 const 变量，不接受修改。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/07/21/cpp-map-2017-07-21/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/21/cpp-map-2017-07-21/" itemprop="url">C++之Map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-21T15:45:25+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="map说明"><a href="#map说明" class="headerlink" title="map说明"></a>map说明</h3><p>Map是STL的一个关联容器，它提供一对一的数据处理能力，map内部自建一颗红黑树(一种非严格意义上的平衡二叉树)，这颗树具有对数据自动排序的功能，所以在map内部所有的数据都是有序的.搜索效率是O(lgN). C++中的map类似python中的dict, 只不过python中的dict使用散列表实现的, 用时(N).<br>它的特点是增加和删除节点对迭代器的影响很小，除了那个操作节点，对其他的节点都没有什么影响。对于迭代器来说，可以修改实值，而不能修改key。<br>C++ STL中的标准规定：</p>
<ul>
<li>map  有序, 用红黑树实现</li>
<li>unordered_map，无序，用散列表实现</li>
</ul>
<h3 id="关于has-map"><a href="#关于has-map" class="headerlink" title="关于has_map"></a>关于has_map</h3><p>hash_map 其实就是使用 hash 表来实现的 map。<br>注意，二叉树，哈希表仅仅是 dictionary 的实现方式，不能说 hash 就等于 dictionary，实现方式可以有多种多样。</p>
<h3 id="map的功能"><a href="#map的功能" class="headerlink" title="map的功能"></a>map的功能</h3><ul>
<li>自动建立Key － value的对应。key 和 value可以是任意你需要的类型</li>
<li>根据key值快速查找记录，查找的复杂度基本是Log(N)，如果有1000个记录，最多查找10次，1,000,000个记录，最多查找20次</li>
<li>快速插入Key - Value 记录</li>
<li>快速删除记录 </li>
<li>根据Key 修改value记录</li>
<li>遍历所有记录</li>
</ul>
<h3 id="map使用"><a href="#map使用" class="headerlink" title="map使用"></a>map使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">     <span class="comment">//定义map对象，当前没有任何元素</span></div><div class="line">     <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; m;</div><div class="line">     </div><div class="line">     <span class="comment">//插入元素，按键值的由小到大放入黑白树中</span></div><div class="line">     m[<span class="string">"Jack"</span>] = <span class="number">98.5</span> ;</div><div class="line">     m[<span class="string">"Bomi"</span>] = <span class="number">96.0</span> ;</div><div class="line">     m[<span class="string">"Kate"</span>] = <span class="number">97.5</span> ;</div><div class="line">     </div><div class="line">     <span class="comment">//删除键值为"Jack"的元素</span></div><div class="line">     m.erase(<span class="string">"Jack"</span>) ;</div><div class="line">     <span class="comment">//先前遍历元素</span></div><div class="line">     <span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">float</span>&gt; :: iterator it ;</div><div class="line">     <span class="keyword">for</span>(it = m.begin(); it != m.end(); it ++)</div><div class="line">     &#123;</div><div class="line">          <span class="built_in">cout</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">" : "</span> &lt;&lt; (*it).second &lt;&lt; <span class="built_in">endl</span> ;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">//反向遍历元素</span></div><div class="line">     <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; :: reverse_iterator rit ;</div><div class="line">     <span class="keyword">for</span>( rit = m.rbegin() ; rit != m.rend() ; rit ++)</div><div class="line">     &#123;</div><div class="line">         <span class="comment">//输入键值与映照数据</span></div><div class="line">         <span class="built_in">cout</span> &lt;&lt; (*rit).first &lt;&lt; <span class="string">" : "</span> &lt;&lt; (*rit).second &lt;&lt; <span class="built_in">endl</span> ;</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// 元素搜索</span></div><div class="line">     <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; :: iterator it ;</div><div class="line">     it = m.find(<span class="string">"Bomi"</span>) ;</div><div class="line">     <span class="keyword">if</span>(it != m.end())  <span class="comment">//搜索到该键值</span></div><div class="line">         <span class="built_in">cout</span> &lt;&lt; (*it).first &lt;&lt; <span class="string">" : "</span> &lt;&lt; ( *it ).second &lt;&lt; <span class="built_in">endl</span> ;</div><div class="line">     <span class="keyword">else</span></div><div class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">"not found it"</span> &lt;&lt; <span class="built_in">endl</span> ;</div><div class="line">     <span class="keyword">return</span> <span class="number">0</span> ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://my.oschina.net/gddyl/blog/113744" target="_blank" rel="external">https://my.oschina.net/gddyl/blog/113744</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/07/20/linux-iomodel-2017-07-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/20/linux-iomodel-2017-07-20/" itemprop="url">Linux之IO网络模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-20T16:26:21+08:00">
                2017-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者.<br>Linux的内核将所有外部设备都看做一个文件来操作，对一个文件的读写操作会调用内核提供的系统命令，返回一个file descriptor（fd，文件描述符 ）。而对一个socket的读写也会有相应的描述符，称为socketfd（socket描述符），描述符就是一个数字，它指向内核中的一个结构体（文件路径，数据区等一些属性）。</p>
<h3 id="IO模型分类"><a href="#IO模型分类" class="headerlink" title="IO模型分类"></a>IO模型分类</h3><p>在Unix(Linux)下，可用的I/O模型有五种：</p>
<ul>
<li>阻塞I/O</li>
<li>非阻塞I/O</li>
<li>I/O多路复用：select和poll是属于这种I/O模型。</li>
<li>信号（或事件）驱动I/O</li>
<li>异步I/O</li>
</ul>
<p>网络IO的本质就是socket流的读取，通常一次IO读操作会涉及到两个对象和两个阶段。<br>两个对象分别是：<br>用户进程（线程）Process（Thread）<br>内核对象 Kernel</p>
<p>两个阶段：<br>等待流数据准备（wating for the data to be ready）;<br>从内核向进程复制数据（copying the data from the kernel to the process）;</p>
<p>对于socket流而已：</p>
<p>第一步通常涉及等待网络上的数据分组到达，然后被复制到内核的某个缓冲区。<br>第二步把数据从内核缓冲区复制到应用进程缓冲区。</p>
<p>对于网络数据的接收操作而言，五种I/O模型都是分为两个阶段：</p>
<ol>
<li>等待数据准备好。</li>
<li>将准备好的数据，从内核空间考到进程空间。</li>
</ol>
<p>对于第一步，就是等待数据到达，到达之后，数据就被复制到内核缓冲区；<br>对于第二步，将数据从内核缓冲区复制到进程缓冲区中。</p>
<p><img src="/2017/07/20/linux-iomodel-2017-07-20/6.png" alt=""></p>
<h3 id="阻塞I-O模型"><a href="#阻塞I-O模型" class="headerlink" title="阻塞I/O模型"></a>阻塞I/O模型</h3><p>阻塞I/O模型属于最常见的I/O模型，在这五种I/O模型中都可以看到阻塞I/O的身影。默认情况下，所有的网络socket都是阻塞的。下面，我们就演示一下具体的数据处理过程：</p>
<p><img src="/2017/07/20/linux-iomodel-2017-07-20/1.png" alt=""></p>
<p>进程对内核发起系统调用（recvfrom），当数据到达网卡并最终被复制到进程空间（或中途发生错误，比如对进程发送一个中断信号等）后，系统调用（recvfrom）就会返回信息给进程，之后，进程再根据返回的信息来进行相应的处理。而进程在收到recvfrom返回信息之前的整个时间段内，我们称，进程被阻塞。当recvfrom返回成功信息时，进程就开始对数据进行处理。</p>
<h3 id="非阻塞I-O模型"><a href="#非阻塞I-O模型" class="headerlink" title="非阻塞I/O模型"></a>非阻塞I/O模型</h3><p>当I/O模型为非阻塞I/O时，那么就相当于告诉内核，当进程请求的数据没完成时，这个进程就不会进入睡眠状态，而是返回一个错误信息。</p>
<p><img src="/2017/07/20/linux-iomodel-2017-07-20/2.png" alt=""></p>
<p>在此，对上图的流程做简单的介绍:前三次调用recvfrom，数据都未准备就绪，因此内核会立即返回一个EWOULDBLOCK的错误信息。第四次调用recvfrom时，数据已经准备就绪。然后数据被复制到进程缓冲区，并且recvfrom返回成功信息。最后，进程对数据进行处理。像这样，在非阻塞模型中一个进程反复调用recvfrom的过程，我们将它称为polling。此时，进程会不断的询问内核：是否某个操作已经准备就绪。而通常这又会浪费CPU时间片，所以，使用这种模型的很少见。</p>
<h3 id="I-O多路复用模型"><a href="#I-O多路复用模型" class="headerlink" title="I/O多路复用模型"></a>I/O多路复用模型</h3><p>在I/O多路复用模型下，我们可以使用select或poll系统调用，而此时发生的阻塞是由select或poll产生的，而不是在真正的I/O系统调用上。Linux提供select/poll（I/O复用模型会用到select或者poll函数，这两个函数也会使进程阻塞，但是和阻塞I/O所不同的是，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数），进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮我们侦测多fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约。Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback。</p>
<p><img src="/2017/07/20/linux-iomodel-2017-07-20/3.png" alt=""></p>
<p>在此，对上图的流程做简单的介绍:在调用select，进程的一个请求就阻塞了，直到数据准备就绪。当select返回数据就绪信息（readable）时，然后，在调用recvfrom将数据复制到进程缓冲区。通过与第一张阻塞I/O模型的图的比较，我们并没有发现多路复用I/O模型有什么优点，并且事实上，还有一个小的缺点，因为使用select时需要两种不同的系统调用。但是使用select的好处是，我们可以同时等待多个I/O的完成。</p>
<h3 id="信号驱动I-O模型"><a href="#信号驱动I-O模型" class="headerlink" title="信号驱动I/O模型"></a>信号驱动I/O模型</h3><p>我们可以使用信号，来告诉内核当数据准备就绪的时候，使用SIGIO信号来通知我们。我们将此称为信号驱动的I/O。</p>
<p><img src="/2017/07/20/linux-iomodel-2017-07-20/4.png" alt=""></p>
<p>在此，对上图的流程做简单的介绍:<br>首先，使用sigaction系统调用安装信号处理器。然后，立即从系统调用中返回，从而进程在继续执行，而不会被阻塞。当数据准备就绪的时候，就会生成SIGIO信号并发送给进程的信号处理器，然后再通过调用recvfrom来读取数据，并最终返回OK由进程对数据进行处理。</p>
<h3 id="异步I-O模型："><a href="#异步I-O模型：" class="headerlink" title="异步I/O模型："></a>异步I/O模型：</h3><p>一般来说，异步I/O模型的实现是从操作步骤的开始到通知整个操作完成（包括将数据从内核复制到进程缓冲区中）。它和信号驱动I/O的主要不同是：信号I/O是在I/O操作正要开始的时候通知我们的，而异步I/O是当I/O操作完成时通知我们的。</p>
<p><img src="/2017/07/20/linux-iomodel-2017-07-20/5.png" alt=""></p>
<p>在此，对上图的流程做简单的介绍:<br>当调用aio_read时，会同时向内核传递描述符，缓冲区指针，缓冲区大小，文件偏移量和当整个操作完成时该如何通知我们等信息。然后，系统调用立即返回，并且进程在等待I/O完成的时候，不会发生阻塞。直到当操作完成的时候内核就会产生相应的信号，并通知给进程。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol>
<li>程序空间与内核空间<br>在Linux中，对于一次读取IO的操作，数据并不会直接拷贝到程序的程序缓冲区。它首先会被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的缓冲区。p.s: 最后一句话非常重要，重复一遍。</li>
</ol>
<p>Waiting for the data to be ready(等待数据到达内核缓冲区)<br>Copying the data from the kernel to the process(从内核缓冲区拷贝数据到程序缓冲区)</p>
<ol>
<li><p>阻塞与非阻塞区别<br>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。<br>区分阻塞和非阻塞只要区分函数调用之后是否挂起返回就可以了</p>
</li>
<li><p>synchronous IO和asynchronous IO区别<br>区分异步和同步，则是函数调用之后，数据或条件满足之后如何通知函数。等待数据返回则是同步，通过回调则是异步。</p>
</li>
<li><p>select/poll/epoll<br>即使现在的各个Linux版本普遍引入了copy on write和线程，但实际上进程/线程之间的切换依然还是一笔很大的开销，这个时候我们可以考虑使用上面提到到多路IO复用，回顾一下我们上面提到的多路IO复用模型的基本原理：一个进程可以监视多个文件描述符，一旦某个文件描述符就绪（读/写准备就绪），能够信号通知程序进行相应的读写操作。下面我们就来简单的看一下多路IO复用的三种方式。</p>
</li>
</ol>
<ul>
<li>select<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,</span></span></div><div class="line"><span class="function"><span class="params">            <span class="keyword">const</span> struct timeval *timeout)</span></span>;</div><div class="line">```            </div><div class="line"></div><div class="line">如上面的方法声明所示, select监听三类描述符: readset(读), writeset(写), exceptset(异常), 我们编程的时候可以制定这三个参数监听对应的文件描述符。正如前面提到的,select调用后进程会阻塞, 当select返回后，可以通过遍历fdset，来找到就绪的描述符。</div><div class="line">select优点在于它的跨平台，但是也有显著的缺点单个进程能够监视的文件描述符的数量存在最大限制，默认设置为<span class="number">1024</span>/<span class="number">2048</span>，虽然设置可以超过这一限制，但是这样也可能会造成效率的降低。而且select扫描的时候也是采用的轮循，算法复杂度为O(n)，这在fdset很多时效率会较低。</div><div class="line"></div><div class="line">* poll</div><div class="line">```cpp</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fdarray, <span class="keyword">unsigned</span> <span class="keyword">long</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>poll和select并没有太大的区别，但是它是基于链表实现的所以并没有最大数量限制，它将用户传入的数据拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次的遍历。算法复杂度也是O(n)。</p>
<ul>
<li>epoll<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>select和poll都只提供了一个函数。而epoll提供了三个函数: <code>epoll_create</code>是创建一个epoll句柄, <code>epoll_ctl</code>是注册要监听的事件类型, <code>epoll_wait</code>则是等待事件的产生。与select相比，epoll几乎没有描述符限制(cat /proc/sys/fs/file-max可查看)。它采用一个文件描述符管理多个描述符，将用户的文件描述符的事件存放到kernel的一个事件表中，这样在程序空间和内核空间的只要做一次拷贝。它去掉了遍历文件描述符这一步骤，采用更加先进的回调(callback)机制，算法复杂度降到了O(1)。p.s: 虽然表面看起来epoll非常好，但是对于连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，因为epoll是建立在大量的函数回调的基础之上。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://noican.blog.51cto.com/4081966/1354950" target="_blank" rel="external">linux中的“5种网络 IO 模型”</a></li>
<li><a href="https://www.ziwenxie.site/2017/01/02/unix-network-programming-asynchronous/" target="_blank" rel="external">https://www.ziwenxie.site/2017/01/02/unix-network-programming-asynchronous/</a></li>
<li><a href="http://blog.leanote.com/post/joesay/Concurrency-Model-Part-1-IO-Concurrency" target="_blank" rel="external">http://blog.leanote.com/post/joesay/Concurrency-Model-Part-1-IO-Concurrency</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/07/20/cpp-vector-2017-07-20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/20/cpp-vector-2017-07-20/" itemprop="url">C++的vertor实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-20T15:01:28+08:00">
                2017-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="C-的vector实现"><a href="#C-的vector实现" class="headerlink" title="C++的vector实现"></a>C++的vector实现</h3><p>新增元素：Vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，在插入新增的元素。<br>插入元素: 插入新的数据分在最后插入push_back和通过迭代器在任何位置插入，<br>这里说一下通过迭代器插入，通过迭代器与第一个元素的距离知道要插入的位置，即int index=iter-begin()。这个元素后面的所有元素都向后移动一个位置，在空出来的位置上存入新增的元素。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(const_iterator iter,<span class="keyword">const</span> T&amp; t )</span></span></div><div class="line"><span class="function"></span>&#123;  </div><div class="line">    <span class="keyword">int</span> index=iter-begin();</div><div class="line">    <span class="keyword">if</span> (index&lt;size_)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">if</span> (size_==capacity_)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">int</span> capa=calculateCapacity();</div><div class="line">            newCapacity(capa);</div><div class="line">        &#125;</div><div class="line">        memmove(buf+index+<span class="number">1</span>,buf+index,(size_-index)*<span class="keyword">sizeof</span>(T)); </div><div class="line">        buf[index]=t;</div><div class="line">        size_++;</div><div class="line">    &#125; </div><div class="line">&#125;</div><div class="line">```        </div><div class="line"></div><div class="line">删除元素：删除和新增差不多，也分两种，删除最后一个元素pop_back和通过迭代器删除任意一个元素erase(iter)。通过迭代器删除还是先找到要删除元素的位置，即<span class="keyword">int</span> index=iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道erase不释放内存只初始化成默认值。</div><div class="line"></div><div class="line">删除全部元素clear：只是循环调用了erase，所以删除全部元素的时候，不释放内存。内存是在析构函数中释放的。</div><div class="line">```cpp</div><div class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator iter)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> index=iter-begin(); </div><div class="line">    <span class="keyword">if</span> (index&lt;size_ &amp;&amp; size_&gt;<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        memmove(buf+index ,buf+index+<span class="number">1</span>,(size_-index)*<span class="keyword">sizeof</span>(T)); </div><div class="line">        buf[--size_]=T();</div><div class="line">    &#125; </div><div class="line">    <span class="keyword">return</span> iterator(iter); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器iteraotr是STL的一个重要组成部分,通过iterator可以很方便的存储集合中的元素.STL为每个集合都写了一个迭代器, 迭代器其实是对一个指针的包装,实现一些常用的方法,如<code>++</code>,<code>--</code>,<code>!=</code>,<code>==</code>,<code>*</code>,<code>-&gt;</code>等, 通过这些方法可以找到当前元素或是别的元素. </p>
<p>vector是STL集合中比较特殊的一个,因为vector中的每个元素都是连续的,所以在自己实现vector的时候可以用指针代替,如<code>typedef T* iterator;typedef const T* const_iterator</code>，如果STL中的函数能方便的操作自己写的集合，实现的迭代器最好继承<code>std::iterator&lt;std::forward_iterator_tag,T&gt;</code>。<br><code>std::iterator&lt;std::forward_iterator_tag,T&gt;</code>的源码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Category</span>, </span></div><div class="line"><span class="class">         <span class="title">class</span> _<span class="title">Ty</span>, </span></div><div class="line"><span class="class">         <span class="title">class</span> _<span class="title">Diff</span> = <span class="title">ptrdiff_t</span>, </span></div><div class="line"><span class="class">         <span class="title">class</span> _<span class="title">Pointer</span> = _<span class="title">Ty</span> *, </span></div><div class="line"><span class="class">         <span class="title">class</span> _<span class="title">Reference</span> = _<span class="title">Ty</span>&amp;&gt;</span></div><div class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator</span></span></div><div class="line"><span class="class">&#123;</span>    </div><div class="line">    <span class="comment">// base type for all iterator classes</span></div><div class="line">    <span class="keyword">typedef</span> _Category iterator_category;</div><div class="line">    <span class="keyword">typedef</span> _Ty value_type;</div><div class="line">    <span class="keyword">typedef</span> _Diff difference_type;</div><div class="line">    <span class="keyword">typedef</span> _Diff distance_type;    <span class="comment">// retained</span></div><div class="line">    <span class="keyword">typedef</span> _Pointer pointer;</div><div class="line">    <span class="keyword">typedef</span> _Reference reference;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>Iterator其中没有任何成员，只是定义了一组类型，所以继承它并不会让你的struct变大，这组类型是STL的内部契约，STL中的函数假设每个迭代器都定义了这些类型，所以只要你的迭代器定义了这些类型，就可以和STL函数集合一起使用。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvin</p>
              <p class="site-description motion-element" itemprop="description">Learn and live.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">141</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arvin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
