<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simple &amp; Freedom</title>
  
  <subtitle>Learn and live.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arvin-he.github.io/"/>
  <updated>2017-09-21T00:45:12.220Z</updated>
  <id>http://arvin-he.github.io/</id>
  
  <author>
    <name>Arvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python定时器</title>
    <link href="http://arvin-he.github.io/2017/09/20/py-timer-2017-09-20/"/>
    <id>http://arvin-he.github.io/2017/09/20/py-timer-2017-09-20/</id>
    <published>2017-09-20T12:15:37.000Z</published>
    <updated>2017-09-21T00:45:12.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python中定时器"><a href="#python中定时器" class="headerlink" title="python中定时器"></a>python中定时器</h3><p>python中的定时器在threading模块中,而且只执行一次, 那么如何定时循环调用呢?<br>Timer:  隔一定时间调用一个函数,如果想实现每隔一段时间就调用一个函数的话，就要在Timer调用的函数中，再次设置Timer。<br>Timer其实是Thread的一个派生类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">"hello %s\n"</span> % name)</div><div class="line">    <span class="keyword">global</span> timer</div><div class="line">    timer = threading.Timer(<span class="number">2.0</span>, hello, [<span class="string">"world"</span>])</div><div class="line">    timer.start()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    timer = threading.Timer(<span class="number">2.0</span>, hello, [<span class="string">"world"</span>])</div><div class="line">    timer.start()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python中定时器&quot;&gt;&lt;a href=&quot;#python中定时器&quot; class=&quot;headerlink&quot; title=&quot;python中定时器&quot;&gt;&lt;/a&gt;python中定时器&lt;/h3&gt;&lt;p&gt;python中的定时器在threading模块中,而且只执行一次, 那么如何
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux一些常用命令</title>
    <link href="http://arvin-he.github.io/2017/09/19/linux-cmds-2017-09-19/"/>
    <id>http://arvin-he.github.io/2017/09/19/linux-cmds-2017-09-19/</id>
    <published>2017-09-19T13:46:02.000Z</published>
    <updated>2017-09-20T00:54:45.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h2><p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件或文件夹.scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p><p>命令格式：<br>scp [参数] [原路径] [目标路径]</p><h3 id="从本地服务器复制到远程服务器："><a href="#从本地服务器复制到远程服务器：" class="headerlink" title="从本地服务器复制到远程服务器："></a>从本地服务器复制到远程服务器：</h3><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">scp local_file remote_username@remote_ip:remote_folder  </div><div class="line">或者  </div><div class="line">scp local_file remote_username@remote_ip:remote_file  </div><div class="line">或者  </div><div class="line">scp local_file remote_ip:remote_folder  </div><div class="line">或者  </div><div class="line">scp local_file remote_ip:remote_file</div></pre></td></tr></table></figure></p><p>第1,2个指定了用户名，命令执行后需要输入用户密码，<br>第1个仅指定了远程的目录，文件名字不变，<br>第2个指定了文件名<br>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，<br>第3个仅指定了远程的目录，文件名字不变，<br>第4个指定了文件名 </p><h3 id="从本地拷贝文件夹到远程服务器："><a href="#从本地拷贝文件夹到远程服务器：" class="headerlink" title="从本地拷贝文件夹到远程服务器："></a>从本地拷贝文件夹到远程服务器：</h3><p>命令格式：<br><code>scp -r local_folder remote_username@remote_ip:remote_folder</code><br>或者<br><code>scp -r local_folder remote_ip:remote_folder</code><br>第1个指定了用户名，命令执行后需要输入用户密码；<br>第2个没有指定用户名，命令执行后需要输入用户名和密码；</p><h3 id="从远程服务器复制到本地服务器："><a href="#从远程服务器复制到本地服务器：" class="headerlink" title="从远程服务器复制到本地服务器："></a>从远程服务器复制到本地服务器：</h3><p>从远程复制到本地的scp命令与上面的命令相似，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。</p><p><code>scp arvin@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scp命令&quot;&gt;&lt;a href=&quot;#scp命令&quot; class=&quot;headerlink&quot; title=&quot;scp命令&quot;&gt;&lt;/a&gt;scp命令&lt;/h2&gt;&lt;p&gt;scp是secure copy的简写，用于在Linux下进行远程拷贝文件或文件夹.scp传输是加密的。可能会稍微影响
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http://arvin-he.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>python之beautifulsoup使用</title>
    <link href="http://arvin-he.github.io/2017/09/18/py-bs4-2017-09-18/"/>
    <id>http://arvin-he.github.io/2017/09/18/py-bs4-2017-09-18/</id>
    <published>2017-09-18T13:20:12.000Z</published>
    <updated>2017-09-20T00:54:45.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="find-find-all"><a href="#find-find-all" class="headerlink" title="find()/find_all()"></a>find()/find_all()</h3><p>find() 返回文档中符合条件的tag，如果没找到符合条件的tag返回Node<br>find_all()返回文档中全部符合条件的tag的列表，如果不存在返回空列表<br>注意find()函数返回的是符合条件的tag，因此可以进行链式调用，如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#先查找class属性为‘post-content’的div标签，然后查找该div标签下的所有的img标签</span></div><div class="line">soup.find(<span class="string">'div'</span>, class_=<span class="string">'post-content'</span>).find_all(<span class="string">'img'</span>)</div></pre></td></tr></table></figure></p><p>而<code>find_all()</code>返回的是列表，列表是不存在find()和find_all()函数的，因此不能进行链式调用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;find-find-all&quot;&gt;&lt;a href=&quot;#find-find-all&quot; class=&quot;headerlink&quot; title=&quot;find()/find_all()&quot;&gt;&lt;/a&gt;find()/find_all()&lt;/h3&gt;&lt;p&gt;find() 返回文档中符合条件的t
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>mongodb笔记(三)</title>
    <link href="http://arvin-he.github.io/2017/09/18/mongodb-note3-2017-09-18/"/>
    <id>http://arvin-he.github.io/2017/09/18/mongodb-note3-2017-09-18/</id>
    <published>2017-09-18T13:05:16.000Z</published>
    <updated>2017-09-20T02:20:22.606Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mongodb突然无法打开"><a href="#mongodb突然无法打开" class="headerlink" title="mongodb突然无法打开"></a>mongodb突然无法打开</h3><p>检查mongodb数据所在的文件夹下是否有一个类似”locked file”,删掉这个文件,然后再开启mongodb</p><h3 id="再说插入操作"><a href="#再说插入操作" class="headerlink" title="再说插入操作"></a>再说插入操作</h3><p>单条插入<br>批量插入</p><h3 id="find操作"><a href="#find操作" class="headerlink" title="find操作"></a>find操作</h3><p>查询是用的最多的操作了, 常用的有2类:</p><ol><li><blockquote><p>, &gt;=, &lt;, &lt;=, !=, =</p></blockquote></li><li>And，OR，In，NotIn</li></ol><p>这些操作在mongodb里面都有对应封装.</p><ol><li>“$gt”, “$gte”, “$lt”, “$lte”, “$ne”, “”<br>这些与上面 &gt;, &gt;=, &lt;, &lt;=, !=, = 这6个符号操作一一对应</li><li>“”, “$or”, “$in”，”$nin”<br>与 And，OR，In，NotIn 操作一一对应</li></ol><p>正则表达式匹配<br>在mongodb中还有一个特殊的匹配，那就是支持正则表达式.</p><p>$where操作</p><h3 id="update操作"><a href="#update操作" class="headerlink" title="update操作"></a>update操作</h3><p>整体更新<br>局部更新</p><p>局部更新:<br>mongodb中已经给我们提供了两个修改器： $inc 和 $set。</p><p>$inc修改器<br>$inc也就是increase的缩写，自增$inc指定的值，如果“文档”中没有此key，则会创建key。</p><p>$set修改器</p><h3 id="upsert操作"><a href="#upsert操作" class="headerlink" title="upsert操作"></a>upsert操作</h3><p>upsert操作就是说：如果我没有查到，我就在数据库里面新增一条，其实这样也有好处，就是避免了我在数据库里面判断是update还是add操作，使用起来很简单将update的第三个参数设为true即可。</p><h3 id="批量更新"><a href="#批量更新" class="headerlink" title="批量更新"></a>批量更新</h3><p>在mongodb中如果匹配多条，默认的情况下只更新第一条，那么如果我们有需求必须批量更新，那么在mongodb中实现也是很简单的，在update的第四个参数中设为true即可.</p><h3 id="查询某一字段重复的记录"><a href="#查询某一字段重复的记录" class="headerlink" title="查询某一字段重复的记录"></a>查询某一字段重复的记录</h3><h3 id="查询某一字段重复的记录的数目"><a href="#查询某一字段重复的记录的数目" class="headerlink" title="查询某一字段重复的记录的数目"></a>查询某一字段重复的记录的数目</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mongodb突然无法打开&quot;&gt;&lt;a href=&quot;#mongodb突然无法打开&quot; class=&quot;headerlink&quot; title=&quot;mongodb突然无法打开&quot;&gt;&lt;/a&gt;mongodb突然无法打开&lt;/h3&gt;&lt;p&gt;检查mongodb数据所在的文件夹下是否有一个类似”
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="MongoDB" scheme="http://arvin-he.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记</title>
    <link href="http://arvin-he.github.io/2017/09/18/py-note1-2017-09-18/"/>
    <id>http://arvin-he.github.io/2017/09/18/py-note1-2017-09-18/</id>
    <published>2017-09-18T12:57:31.000Z</published>
    <updated>2017-09-21T00:48:34.399Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python路径操作"><a href="#python路径操作" class="headerlink" title="python路径操作"></a>python路径操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"></div><div class="line"><span class="comment">#创建目录</span></div><div class="line">os.mkdir(<span class="string">"D:\\python\\2"</span>)</div><div class="line"><span class="comment">#删除目录</span></div><div class="line">os.rmdir(<span class="string">"D:\\python\\2"</span>)</div><div class="line"></div><div class="line"><span class="comment">#创建多级目录</span></div><div class="line">os.makedirs(<span class="string">"D:\\python\\oo\\2\\3"</span>)</div><div class="line"><span class="comment">#删除多级目录</span></div><div class="line">os.removedirs(<span class="string">"D:\\python\\oo\\2\\3"</span>)</div><div class="line"></div><div class="line"><span class="comment">#获取目录下文件夹及文件</span></div><div class="line">paths=os.listdir(<span class="string">"D:\\python"</span>)</div><div class="line"><span class="keyword">for</span> path <span class="keyword">in</span> paths:</div><div class="line">    print(path)</div><div class="line"></div><div class="line"><span class="comment">#获取当前目录位置</span></div><div class="line">path1=os.getcwd()</div><div class="line">print(path1)</div><div class="line"></div><div class="line"><span class="comment">#切换目录</span></div><div class="line">os.chdir(<span class="string">"D:\\python\\oo\\3"</span>)</div><div class="line">path2=os.getcwd()</div><div class="line">print(path2)</div><div class="line"></div><div class="line"><span class="comment">#遍历所有子目录及文件</span></div><div class="line"><span class="keyword">for</span> p1,d,filelist <span class="keyword">in</span> os.walk(<span class="string">'D:'</span>+os.sep+<span class="string">'python'</span>):</div><div class="line">    <span class="keyword">for</span> f1 <span class="keyword">in</span> filelist:</div><div class="line">        fp=os.path.join(p1,f1)</div><div class="line">        print(fp)</div></pre></td></tr></table></figure><h3 id="python文件压缩操作"><a href="#python文件压缩操作" class="headerlink" title="python文件压缩操作"></a>python文件压缩操作</h3><h3 id="python数据库连接操作"><a href="#python数据库连接操作" class="headerlink" title="python数据库连接操作"></a>python数据库连接操作</h3><h3 id="python字符串操作"><a href="#python字符串操作" class="headerlink" title="python字符串操作"></a>python字符串操作</h3><h3 id="python异常处理"><a href="#python异常处理" class="headerlink" title="python异常处理"></a>python异常处理</h3><h3 id="python日志操作"><a href="#python日志操作" class="headerlink" title="python日志操作"></a>python日志操作</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python路径操作&quot;&gt;&lt;a href=&quot;#python路径操作&quot; class=&quot;headerlink&quot; title=&quot;python路径操作&quot;&gt;&lt;/a&gt;python路径操作&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>mongodb笔记(二)</title>
    <link href="http://arvin-he.github.io/2017/09/13/mongodb-note2-2017-09-13/"/>
    <id>http://arvin-he.github.io/2017/09/13/mongodb-note2-2017-09-13/</id>
    <published>2017-09-13T13:15:25.000Z</published>
    <updated>2017-09-20T00:54:45.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ol><li>mongoDB三要素: 数据库，集合，文档，其中“集合”就是对应关系数据库中的“表”，“文档”对应“行”。</li><li>mongoDB发布版本: 32bit和64bit<ul><li>根据业界规则，偶数为“稳定版”(如：1.6.X，1.8.X)，奇数为“开发版”(如：1.7.X，1.9.X)</li><li>32bit的mongodb最大只能存放2G的数据，64bit就没有限制</li></ul></li></ol><h3 id="mongoDB安装与启动"><a href="#mongoDB安装与启动" class="headerlink" title="mongoDB安装与启动"></a>mongoDB安装与启动</h3><ol><li>安装: 安装就不多说了,注意安装完将mongodb安装目录下的bin目录(C:\Program Files\MongoDB\Server\3.4\bin)放到环境变量中去,默认是没有放到环境变量中.这样有一些很好用的工具和命令可以在终端使用.</li><li>启动: 启动之前必须给monggodb指定一个文件夹,这里取名为”mongodata”,路径位:C:\mongodata,用来存放mongodb的数据。如果你将mongodb安装在C:/program File目录下,那么这个mongodata文件夹不要放在C:/program File目录下.因为这需要管理员权限才能添加和删除文件夹.</li><li>在终端指定数据存放地点:<br>mongod –dbpath=C:/mongodata</li><li>查看是否成功:<br>最后要看下是否开启成功，从图中的信息中获知，mongodb采用27017端口，那么我们就在浏览器里面键入“<a href="http://localhost:27017/”，" target="_blank" rel="external">http://localhost:27017/”，</a><br>打开后，mongodb告诉我们在27017上Add 1000可以用http模式查看mongodb的管理信息(貌似在新版本3.4.9没有成功)。</li></ol><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>在终端指定数据存放点后,mongod –dbpath=C:/mongodata,不要关闭该终端,再开一个终端，输入mongo命令打开shell，其实这个shell就是mongodb的客户端，同时也是一个js的编译器，默认连接的是“test”数据库。</p><ol><li>insert操作</li></ol><p><img src="/2017/09/13/mongodb-note2-2017-09-13/1.png" alt=""></p><ol><li>find 操作</li></ol><p>这里要注意两点：<br>“_id”： 这个字段是数据库默认给我们加的GUID，目的就是保证数据的唯一性。<br>严格的按照Bson的形式书写文档，不过也没关系，错误提示还是很强大的。</p><p><img src="/2017/09/13/mongodb-note2-2017-09-13/2.png" alt=""></p><ol><li>update操作</li></ol><p>update方法的第一个参数为“查找的条件”，第二个参数为“更新的值”。</p><p><img src="/2017/09/13/mongodb-note2-2017-09-13/3.png" alt=""></p><ol><li>remove操作</li></ol><p>删除指定数据</p><p><img src="/2017/09/13/mongodb-note2-2017-09-13/4.png" alt=""></p><p>删除所有数据</p><p><img src="/2017/09/13/mongodb-note2-2017-09-13/5.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;mongoDB三要素: 数据库，集合，文档，其中“集合”就是对应关系数据库中的“表”，“文档”对应“行”。&lt;/l
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mongoDB" scheme="http://arvin-he.github.io/tags/mongoDB/"/>
    
  </entry>
  
  <entry>
    <title>mongoDB笔记</title>
    <link href="http://arvin-he.github.io/2017/09/12/mongodb-note1-2017-09-12/"/>
    <id>http://arvin-he.github.io/2017/09/12/mongodb-note1-2017-09-12/</id>
    <published>2017-09-12T01:36:54.000Z</published>
    <updated>2017-09-20T00:54:45.820Z</updated>
    
    <content type="html"><![CDATA[<h2 id="常见的关系型数据库"><a href="#常见的关系型数据库" class="headerlink" title="常见的关系型数据库"></a>常见的关系型数据库</h2><p>关系数据库管理系统(Relational DataBase Management System，RDBMS)<br>MySQL、PostgreSQL、SQLite、Oracle、MS SQLServer </p><h3 id="mongoDB简介"><a href="#mongoDB简介" class="headerlink" title="mongoDB简介"></a>mongoDB简介</h3><p>MongoDB(源自单词 humongous)是一种较新的数据库，它没有表、模式、SQL 或行的概念。<br>它没有事务、ACID 兼容性、连接、外键或其他许多容易在凌晨引起问题的特性。</p><p>记住：MongoDB 不会尝试为所有人完成所有事情。但对于许多目的(例如构建 Web 应用)，<br>MongoDB 是一个能够实现解决方案的完美工具。</p><p>MongoDB 以C++编写，因此迁移相对容易，并且可以在任何位置运行该应用。MongoDB 提供了一个功能丰富的面向文档数据库，并且对运行速度和扩展性做了优化。它也几乎可运行在任何目标上。MongoDB的网站上包含了可运行在 Linux、Mac OS、Windows 和 Solaris 中的安装文件。</p><p><strong>警告：</strong><br>32 位版本的 MongoDB 数据库大小被限制为小于等于 2GB，因为 MongoDB 内部使用内存<br>映射文件来实现高性能。在 32 位系统中任何大于 2GB 的文件都需要一些特殊的处理，这样会<br>降低处理速度，也会使应用代码变得复杂。官方关于该限制的观点是：64 位环境很容易获得；<br>因此，增加代码的复杂性并不是很好的权衡之计。64 位版本的 MongoDB 可以实现所有的意图<br>和目的，并且不含任何限制。</p><h3 id="关于BSON"><a href="#关于BSON" class="headerlink" title="关于BSON"></a>关于BSON</h3><p>MongoDB 并未使用 JSON 存储数据，而使用由 MongoDB 团队开发的一种称为<br>BSON(二进制 JSON 的英文简称)的开放数据格式。大多数情况下，使用 BSON 取代 JSON 并不<br>会改变处理数据的方式。BSON 通过使计算机更容易处理和搜索文档的方式，使 MongoDB 处<br>理速度变得更快。BSON 还添加了一些标准 JSON 不支持的特性，包括数字数据(例如 int32 和<br>int64)的许多扩展类型，以及支持处理二进制数据。</p><p>BSON 是一个开放标准，在网址 <a href="http://bsonspec.org/上可以找到它的规范。当人们听到" target="_blank" rel="external">http://bsonspec.org/上可以找到它的规范。当人们听到</a> BSON<br>是 JSON 的二进制形式时，他们期望 BSON 占用的空间要比 JSON 少得多。不过，事实并不一<br>定是这样的；许多情况下，BSON 版本与相同的 JSON 相比要占用更多的空间。</p><p>首先，要记住 MongoDB 的设计目标是快速，而不是节省空间。虽然这并不意味着 MongoDB<br>会浪费空间(它不会)；不过，如果处理数据的速度更快(它确实是这样的)，那么存储文档时的一<br>点开销是完全可以接受的。简单地说，BSON 更易于遍历(即浏览)，遍历索引页非常快。</p><p>BSON 支持在一个文档中存储最多 16MB 的二进制数据，</p><h3 id="关于唯一键"><a href="#关于唯一键" class="headerlink" title="关于唯一键"></a>关于唯一键</h3><p>MongoDB 要求每个文档必须有唯一标识符；在 MongoDB 中，该标识符<br>被称为_id。除非为该字段指定某个值，否则 MongoDB 将自动创建唯一值。即使是在已经成熟<br>的 RDBMS 数据库世界中，也存在着是应该自己提供唯一键还是由数据库提供的分歧。最近，<br>由数据库创建唯一键的方式已经变得更加流行。MongoDB 是一个分布式数据库，所以其主要<br>目标之一是消除对共享资源的依赖(例如检查主键是否独一无二)。非分布式的数据库通常使用<br>一个简单的主键，例如自动递增的序列号。MongoDB 的默认_id 格式是一个 ObjectId，它是一<br>个 12 字节的唯一标识符，可以独立地在分布式环境中生成。<br>之前，使用 MongoDB 的大多数开发者似乎更喜欢创建自己的唯一键，由自己来维护键的<br>唯一性。然而，现在人们更愿意使用 MongoDB 创建的默认 ID 值。不过，在使用 RDBMS 数据<br>库时，选择哪种方式更多地取决于个人偏好。我们更愿意使用数据库提供的值，因为这意味着<br>我们可以保证键是唯一的，并且是独立的。<br>最终，你必须决定哪种方式更适合自己。如果有信心保证自己的键一定是唯一的(并且可能<br>不会改变)，那么就可以使用。如果不确定键的唯一性或者不希望担心这件事情，最好还是使用<br>MongoDB 提供的默认键。</p><h3 id="关于集合"><a href="#关于集合" class="headerlink" title="关于集合"></a>关于集合</h3><p>集合有点类似于表，但它们不那么死板。集合非常像一个贴有标签的盒子。<br>最后但并非最不重要的是，集合可以按需求即时创建。尤其是，在第一次尝试保存文档时，<br>MongoDB 将创建引用它的集合。这意味着可以按照需求即时创建集合(但并不是应该这么做)。<br>因为 MongoDB 也允许动态地创建索引，执行其他数据库级别的命令，所以可以利用该特性构<br>建出一些非常动态的应用。</p><p>理解 MongoDB 中数据库的最简单方式就是将它看成一个集合的集合</p><h3 id="存储二进制数据"><a href="#存储二进制数据" class="headerlink" title="存储二进制数据"></a>存储二进制数据</h3><p>GridFS 是 MongoDB 在数据库中存储二进制数据的解决方案。<br>GridFS 通过在 files 集合中存储文件的信息(称为元数据)来实现。数据本身被分成多块(称为<br>信息块)存储在 chunks 集合中。这种方式使数据存储既简单又有扩展性；还使范围操作(例如获<br>取文件的特定部分)变得更简单。</p><h3 id="实施分片"><a href="#实施分片" class="headerlink" title="实施分片"></a>实施分片</h3><p>对于涉及大规模部署的应用，自动分片可能是 MongoDB 最重要和最常用的特性。<br>在自动分片场景中，MongoDB 将处理所有数据的分割和重组。它将保证数据进入正确的<br>服务器，并以最高效的方式运行查询和重组结果。事实上，从开发者的角度看，使用含有数百<br>个分片的 MongoDB 数据库和使用单个 MongoDB 数据库并没有区别。</p><h3 id="使用-map-和-reduce-函数"><a href="#使用-map-和-reduce-函数" class="headerlink" title="使用 map 和 reduce 函数"></a>使用 map 和 reduce 函数</h3><p>MongoDB 并不要求使用 map 和 reduce 函数。事实上，MongoDB 只依赖于简单的查询语法，<br>这种语法与 MySQL 中使用的类似。不过，对于希望使用该功能的人，MongoDB 也提供了对这<br>些函数的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;常见的关系型数据库&quot;&gt;&lt;a href=&quot;#常见的关系型数据库&quot; class=&quot;headerlink&quot; title=&quot;常见的关系型数据库&quot;&gt;&lt;/a&gt;常见的关系型数据库&lt;/h2&gt;&lt;p&gt;关系数据库管理系统(Relational DataBase Management S
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="mongoDB" scheme="http://arvin-he.github.io/tags/mongoDB/"/>
    
  </entry>
  
  <entry>
    <title>怎样避免陷入无止境地看教程的陷阱</title>
    <link href="http://arvin-he.github.io/2017/09/08/learn-minds-2017-06-19/"/>
    <id>http://arvin-he.github.io/2017/09/08/learn-minds-2017-06-19/</id>
    <published>2017-09-08T03:51:39.704Z</published>
    <updated>2017-09-08T03:51:39.707Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/09/08/learn-minds-2017-06-19/1.jpeg" alt=""></p><p>我们可能都曾遇到过这样的情况：学习编程的时候，一个教程接着一个教程地学，但是不清楚自己学到什么了程度。然后你开始自我怀疑：“这太难了。”或“也许编程不适合我。”我知道你懂这种感受。</p><p>我自己在最近就切身体会到了这种感觉。我本身算是个比较自信的PHP攻城狮，打算学习Python—尤其是Django。</p><p>我搜索了一些相关资料并找到了看似完美的教程，足够复杂富有挑战，又足够简单不至于击垮我的兴趣。</p><p>作为一个基于项目实战的教程，我对完成后的项目相当喜欢。我认为将它添加到我的成长作品集会是很酷的一件事。</p><p>跟着教程做到接近80%的时候，我突然产生了一股自我怀疑。我已经看了视频教程并一个个字敲了所有的代码，我已经有了一个简单的项目可以展示给他人，可为什么我感觉反倒没有刚开始那样好？</p><p><img src="/2017/09/08/learn-minds-2017-06-19/2.jpg" alt=""></p><p>跟着这个教程又花了几个星期的晚上，我有了一个漂亮的完工项目。即便如此，我还是觉得在没有指南的情况下我是不具备重新实现这个项目的技能的。所以，将它放到我的作品集里真的好吗？</p><p>将一个在外观和功能上与别人的一模一样的项目展示出来真的说服力吗？而且代码和GitHub教程上的一模一样。</p><p>如你所见，跟着教程学习，接触到新的技能，是很棒的。但是只跟着教程学习，你无法掌握作为一名合格的初级工程师所需的更多技能，我指的是：</p><ul><li>设计和组织项目</li><li>了解哪些工具对于一个具体项目是最佳选择</li><li>尝试通过搜索来解决遇到的一些问题</li><li>解决在实际项目开发中无可避免的一些问题</li></ul><h2 id="教程是快速上手的好办法"><a href="#教程是快速上手的好办法" class="headerlink" title="教程是快速上手的好办法"></a>教程是快速上手的好办法</h2><hr><p>为了避免大家误解，交代一下相关背景，我是一个29岁的初级码农，目前在一家软件开发公司工作。我在一年前转行进入编程行业，</p><p>很多新手码农一样，在开始学习高级教程之前我先完成基础的教程。我主要是学习PHP（因为在我开始学习编程的时候听说PHP是全世界最好的语言），我很快就熟悉了语法和一些基本用法。</p><p>大概花了9个月的时间，我完成了足够多的教程，有了足够的理解，也有了足够的动力去说服一家软件开发公司给我提供一份工作。（你可以通过这篇文章了解到我是如何说服老板给我工作机会的 take a chance on me and pay me to learn to code.）</p><p>让我能在如此短的时间内得到一份编程工作，得益于我创建的可以展示的实际项目。值得注意的是，是<strong>我自己</strong>的项目，而不是跟着教程复制粘贴的那种。</p><h2 id="教程也只能帮你到这里了-之后你需要开发实际项目"><a href="#教程也只能帮你到这里了-之后你需要开发实际项目" class="headerlink" title="教程也只能帮你到这里了 之后你需要开发实际项目"></a>教程也只能帮你到这里了 之后你需要开发实际项目</h2><hr><p><img src="/2017/09/08/learn-minds-2017-06-19/3.jpeg" alt=""></p><p>不要理解错了我的意思–教程是很棒的，尤其是在新手学习基础的情况下。当然，教程的质量是良莠不齐的，解释的详细程度也大相径庭。但是一个教程接着一个教程的学习是无法让你成为一个专业的开发者的。</p><p>你必须开发自己的项目。一旦你对你选择的语言的语法和基本的实现有了一定的认识，你就可以开始开发属于自己的东西了，不再是“手把手”式的学习。</p><p>当我向别人说这些的时候，通常得到的回应是：“开发什么呢？我一点想法都没有。”</p><p>额，实际上没人指望你创造出什么牛逼的东西来，而且你应该不具备这样的技能去做这样的事情，就算你有想法。</p><p>这里有一份清单，列出了你可以开发的500个项目，有例子: <a href="http://rosettacode.org/wiki/Category:Programming_Tasks" target="_blank" rel="external">http://rosettacode.org/wiki/Category:Programming_Tasks</a> 。</p><p>你也可以开发类似博客这样的项目。是的，有无数个教程都是基于构建博客的。你可能还会复制、粘贴一些代码，这也许不是一个令人印象深刻的项目，但是。。。</p><p>开发属于<strong>你自己的博客</strong>。坐下来，在开始之前，制定好每一步的计划和特色功能。搜索并选择一门你想用的语言和框架。了解怎么安装需要的工具，构建开发环境，通过包管理工具安装所需的依赖等。当你卡在某个环节时，Google或者通过可靠的技术社区去解决你遇到的一些问题。</p><p>通过这样的方式你的学习效率可能比跟着任何一个教程学习都快很多,你自己开发的项目的在你作品中的价值也远远大于其他几十个跟着教程做的项目的总和。</p><p>取决于你选择的项目的复杂程度，在你找工作的时候你的个人作品集里可能就不再需要其他的东西了，只是可能。你的代码可能不是非常出色，但这是你自己写的代码。你可以解释每一行代码的意义，你可以解释你是如何实现的和为什么这样做。</p><p>同时，你也证明了你可以管理一个项目，单独完成，学习需要的新技能，并递交最终完成的产品。对于潜在的雇主而言，你现在拥有了几项有价值的技能。</p><p>如果花12到18月的时间去学习，还没有找到一份工作，或者说你总感觉实际尚未成熟，<strong>别灰心，不要放弃</strong>。不要开始有这样的想法：你需要花动辄上万的学费去参加什么牛逼的培训班。只需要开始开发你自己的东西你就会惊讶于你进步的速度！</p><blockquote><p>通过freeCodeCamp找到工作的人数在不断增长可能也是因为它基于项目的学习方式。freeCodeCamp是一个不错的学习平台，不过本文就不替原作者多做宣传了。本文翻译自 <a href="https://medium.freecodecamp.com/how-to-dig-yourself-out-of-the-coding-tutorial-rut-7d3b2232f234" target="_blank" rel="external">https://medium.freecodecamp.com/how-to-dig-yourself-out-of-the-coding-tutorial-rut-7d3b2232f234</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2017/09/08/learn-minds-2017-06-19/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们可能都曾遇到过这样的情况：学习编程的时候，一个教程接着一个教程地学，但是不清楚自己学到什么了程度。然后你开始自我怀疑：“这太难了。”或
      
    
    </summary>
    
      <category term="life" scheme="http://arvin-he.github.io/categories/life/"/>
    
    
      <category term="思想" scheme="http://arvin-he.github.io/tags/%E6%80%9D%E6%83%B3/"/>
    
      <category term="方法" scheme="http://arvin-he.github.io/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python程序打包问题</title>
    <link href="http://arvin-he.github.io/2017/09/01/py-packproblems-2017-09-01/"/>
    <id>http://arvin-he.github.io/2017/09/01/py-packproblems-2017-09-01/</id>
    <published>2017-09-01T06:33:39.000Z</published>
    <updated>2017-09-08T03:51:39.874Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ImportError-DLL-load-failed-The-specified-module-could-not-be-found"><a href="#ImportError-DLL-load-failed-The-specified-module-could-not-be-found" class="headerlink" title="ImportError: DLL load failed: The specified module could not be found."></a>ImportError: DLL load failed: The specified module could not be found.</h3><p>win7-64bit或win10-64bit打包python32位程序在win7-32bit系统上运行报错:ImportError: DLL load failed: The specified module could not be found.</p><p>Finally,I find the solution:<br>Install <a href="https://www.microsoft.com/de-at/download/details.aspx?id=48145" target="_blank" rel="external">Microsoft Visual C++ 2015 Redistributable Update 3 x86</a>.</p><p>注意:</p><ol><li>选择X86版本</li><li>vc_redist.x86.exe 一定要选择update 3版本,之前的版本还是会报错.</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://github.com/tensorflow/tensorflow/issues/7995" target="_blank" rel="external">stackoverflow</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;ImportError-DLL-load-failed-The-specified-module-could-not-be-found&quot;&gt;&lt;a href=&quot;#ImportError-DLL-load-failed-The-specified-module-coul
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python中关于在GUI应用程序读取stdin内容</title>
    <link href="http://arvin-he.github.io/2017/08/30/py-stdin-2017-08-30/"/>
    <id>http://arvin-he.github.io/2017/08/30/py-stdin-2017-08-30/</id>
    <published>2017-08-30T02:11:08.000Z</published>
    <updated>2017-09-08T03:51:39.895Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>键盘输入的字符串是保存在stdin中的,我在程序中如何将stdin中数据拿到并赋给一个变量? 之前我是通过sys.stdin.readline()来读取stdin中的数据的,但是导致界面卡死,我想问一下你有什么办法?我google一下,没有找到我想要的</p><p>data = input()<br>用 sys.stdin.readline 或 input, 都只能读取整行数据. 如果没有按回车键, 调用是阻塞不返回的.</p><p>这就是为什么程序界面被卡死的原因.</p><p>Qt 里还有个键盘事件的钩子. 需要在终端键盘输入时, 可能需要配置一下.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">QtCore.pyqtRemoveInputHook()</div><div class="line">code.InteractiveConsole(_locals).interact()</div><div class="line">QtCore.pyqtRestoreInputHook()</div></pre></td></tr></table></figure></p><p>当QtCore模块第一次导入时，它会安装一个Python输入钩子（即它设置Python的PyOS_InputHook变量的值）。这允许在应用程序运行时在解释器提示符处输入命令。然后可以动态创建新的Qt对象并调用任何现有的Qt对象的方法。输入钩子可能会导致某些类型的应用程序出现问题，特别是那些通过不同手段提供类似设备的应用程序。此功能删除PyQt安装的输入钩。</p><p>对于图形界面程序, 最合理的做法还是只用输入控件, LineEdit 等, 不用控制台, 也就是不用 sys.stdin<br>Qt 处理键盘消息应该用键盘事件</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;键盘输入的字符串是保存在stdin中的,我在程序中如何将stdin中数据拿到并赋给一个变量? 之前我是通过sys.stdin.readlin
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux系统之镜像备份</title>
    <link href="http://arvin-he.github.io/2017/08/28/linux-backup-2017-08-28/"/>
    <id>http://arvin-he.github.io/2017/08/28/linux-backup-2017-08-28/</id>
    <published>2017-08-28T05:51:53.000Z</published>
    <updated>2017-09-08T03:51:39.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算文件拷贝的进度"><a href="#计算文件拷贝的进度" class="headerlink" title="计算文件拷贝的进度"></a>计算文件拷贝的进度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># dd_process.sh</span></div><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"><span class="comment">####dd 命令反映进度####</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne 2 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"需要 盘符名 镜像名"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line">dupath=`du -m --total / --exclude=proc --exclude=media |grep 总用量 |cut -f 1`</div><div class="line"><span class="built_in">echo</span> <span class="string">"根文件大小为<span class="variable">$dupath</span> M"</span></div><div class="line"><span class="built_in">let</span> SIZE=<span class="variable">$dupath</span>+200</div><div class="line">    <span class="keyword">while</span> <span class="literal">true</span></div><div class="line">    <span class="keyword">do</span></div><div class="line">    dusize=`du -hm /media/Lark/<span class="variable">$1</span>/<span class="variable">$2</span> |cut -f 1`</div><div class="line">    <span class="built_in">echo</span> <span class="string">"生成文件大小为 <span class="variable">$dusize</span> M"</span></div><div class="line">    <span class="keyword">if</span> [ <span class="variable">$dusize</span> == <span class="variable">$SIZE</span> ]</div><div class="line">        <span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"文件生成成功！"</span></div><div class="line">        <span class="built_in">exit</span> 0</div><div class="line">    <span class="keyword">fi</span></div><div class="line">    <span class="keyword">done</span></div></pre></td></tr></table></figure><h3 id="将根文件备份到u盘"><a href="#将根文件备份到u盘" class="headerlink" title="将根文件备份到u盘"></a>将根文件备份到u盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"><span class="comment">#################################</span></div><div class="line"><span class="comment">###  get img to u_disk                                 ### </span></div><div class="line"><span class="comment">### 功能：将根文件备份到u盘                      ###  </span></div><div class="line"><span class="comment">#################################</span></div><div class="line"><span class="comment">#卸载备份区，保证/media/Lark下只挂载u盘</span></div><div class="line"><span class="keyword">if</span> [ -d /media/Lark/.linuxroot ];<span class="keyword">then</span></div><div class="line">/bin/umount /media/Lark/.linuxroot</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"请切换root权限执行"</span></div><div class="line"><span class="built_in">exit</span> -5</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$#</span> -ne 2 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"请输入 u盘名 镜像名称!"</span></div><div class="line"><span class="built_in">exit</span> -7</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment">#检测出u盘个数及盘符名</span></div><div class="line"></div><div class="line">LS_MEDIA_LARK=`ls /media/Lark`</div><div class="line">SELECTED_DISK=</div><div class="line">counter=0</div><div class="line"><span class="keyword">for</span> file <span class="keyword">in</span> `ls /media/Lark`</div><div class="line"><span class="keyword">do</span></div><div class="line">counter=`expr <span class="variable">$counter</span> + 1`</div><div class="line"><span class="keyword">done</span></div><div class="line"><span class="comment">#echo $counter</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$counter</span> == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="comment">#没有U盘插入，退出</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"没有插入u盘或者没有挂载盘符！！请检测u盘是否可正常识别!"</span></div><div class="line"><span class="built_in">exit</span> -1</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="comment">#echo "LS_MEDIA_LARK is $LS_MEDIA_LARK "</span></div><div class="line">DISK1=`<span class="built_in">echo</span> <span class="variable">$LS_MEDIA_LARK</span>|awk -F <span class="string">' '</span> <span class="string">'&#123;print $1&#125;'</span>`</div><div class="line">DISK2=`<span class="built_in">echo</span> <span class="variable">$LS_MEDIA_LARK</span>|awk -F <span class="string">' '</span> <span class="string">'&#123;print $2&#125;'</span>`</div><div class="line"><span class="comment">#echo "DISK1 is $DISK1,DISK2 is $DISK2"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"检测目前根文件大小"</span></div><div class="line">dupath=`du -m --total / --exclude=proc --exclude=media |grep 总用量 |cut -f 1`</div><div class="line"><span class="built_in">echo</span> <span class="string">"根文件大小为<span class="variable">$dupath</span> M"</span></div><div class="line"><span class="comment">#size=2700</span></div><div class="line"><span class="comment">#if [ $dupath -gt $size ];then</span></div><div class="line"><span class="comment">#echo "注意：当前系统生成镜像大于3GB，生成镜像文件不可使用Lark升级工具烧写，但可使用原厂工具烧写"</span></div><div class="line"><span class="comment">#exit 0</span></div><div class="line"><span class="comment">#fi</span></div><div class="line"><span class="comment">#TODO :校验U盘可用空间，与根文件做对比</span></div><div class="line">    <span class="built_in">echo</span> <span class="string">"####生成根文件镜像####"</span></div><div class="line"><span class="built_in">let</span> SIZE=<span class="variable">$dupath</span>+10</div><div class="line"><span class="built_in">echo</span> <span class="string">"生成文件大小为<span class="variable">$SIZE</span> M"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"步骤一:选择存放镜像的U盘"</span></div><div class="line"><span class="keyword">if</span> <span class="literal">false</span>;<span class="keyword">then</span></div><div class="line"><span class="keyword">if</span> [ -n <span class="string">"<span class="variable">$DISK2</span>"</span> ] ;<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"共检测出u盘 <span class="variable">$counter</span>个：请选择1.<span class="variable">$DISK1</span> 2.<span class="variable">$DISK2</span>"</span></div><div class="line"><span class="built_in">read</span> CHOICE</div><div class="line"></div><div class="line"><span class="keyword">case</span> <span class="variable">$CHOICE</span> <span class="keyword">in</span></div><div class="line">1) </div><div class="line"><span class="built_in">echo</span> <span class="string">"你选择的u盘为<span class="variable">$DISK1</span>"</span></div><div class="line">SELECTED_DISK=<span class="variable">$DISK1</span></div><div class="line">;;</div><div class="line">2)</div><div class="line"><span class="built_in">echo</span> <span class="string">"你选择的u盘为<span class="variable">$DISK2</span>"</span></div><div class="line">SELECTED_DISK=<span class="variable">$DISK2</span></div><div class="line">;;</div><div class="line">*)</div><div class="line"><span class="built_in">echo</span> <span class="string">"选择错误"</span></div><div class="line"><span class="built_in">exit</span> -2</div><div class="line">;;</div><div class="line"><span class="keyword">esac</span></div><div class="line"><span class="keyword">else</span></div><div class="line">SELECTED_DISK=<span class="variable">$DISK1</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">fi</span></div><div class="line">SELECTED_DISK=<span class="variable">$1</span></div><div class="line"><span class="comment">#检测所选u盘是剩余空间</span></div><div class="line"></div><div class="line">DISK_SPACE=`df -hm /media/Lark/<span class="variable">$SELECTED_DISK</span> | sed -n <span class="string">"2p"</span> | awk <span class="string">'&#123;print $4&#125;'</span>`</div><div class="line"><span class="built_in">echo</span> <span class="string">"剩余空间为 <span class="variable">$DISK_SPACE</span> M"</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$SIZE</span> -gt <span class="variable">$DISK_SPACE</span> ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"根文件大小大于备份区最大空间，请删减可删减的文件进行备份"</span></div><div class="line"><span class="built_in">exit</span> -3</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"步骤二:切换到U盘目录，且创建镜像文件，请耐心等待"</span></div><div class="line"><span class="built_in">cd</span>  /media/Lark/<span class="variable">$SELECTED_DISK</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> <span class="literal">false</span>;<span class="keyword">then</span></div><div class="line"><span class="comment">#后台检测，一旦U盘断开，或者卸载，则退出此次操作</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">while</span> <span class="literal">true</span></div><div class="line"><span class="keyword">do</span></div><div class="line">CHECK_DISK=/media/Lark/<span class="variable">$SELECTED_DISK</span></div><div class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$CHECK_DISK</span> ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"u盘已断开，请检测其连接性并重新执行"</span></div><div class="line"><span class="built_in">echo</span></div><div class="line"><span class="built_in">exit</span> -4</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$FLAGS</span> == 1 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">done</span></div><div class="line">&#125;&amp;</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line">IMAGE_NAME=<span class="variable">$2</span><span class="string">".tmp"</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span>  <span class="string">"步骤三:生成镜像名:<span class="variable">$IMAGE_NAME</span>"</span></div><div class="line">touch <span class="variable">$IMAGE_NAME</span></div><div class="line"><span class="built_in">echo</span>  <span class="string">"步骤四：生成指定大小空文件"</span></div><div class="line">dd <span class="keyword">if</span>=/dev/zero of=<span class="variable">$IMAGE_NAME</span> bs=1M count=<span class="variable">$SIZE</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span>  <span class="string">"步骤五：格式化镜像文件"</span></div><div class="line">mkfs.ext4 -F -L .linuxroot <span class="variable">$IMAGE_NAME</span></div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"dd 操作失误"</span></div><div class="line"><span class="built_in">exit</span> -1;</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"步骤六：挂载镜像文件到mnt目录"</span></div><div class="line">        mount -o loop <span class="variable">$IMAGE_NAME</span> /mnt</div><div class="line"></div><div class="line">    <span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"步骤七：同步根分区到mnt"</span></div><div class="line">rsync -axv / /mnt</div><div class="line"><span class="keyword">fi</span> </div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? == 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步完成"</span></div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步失败，请重新执行"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"><span class="comment">#echo "请卸载U盘"</span></div><div class="line"><span class="built_in">cd</span> /tmp</div><div class="line">umount /mnt</div><div class="line"><span class="keyword">if</span> [ $? == 0 ]</div><div class="line"><span class="keyword">then</span></div><div class="line"> <span class="built_in">echo</span> <span class="string">"挂载点已卸载"</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">echo</span> <span class="string">" 镜像已生成！"</span></div><div class="line">sleep 3</div><div class="line"><span class="comment">#fuser -km /media/Lark/$SELECTED_DISK</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"镜像修正以便烧写"</span></div><div class="line">mv /media/Lark/<span class="variable">$SELECTED_DISK</span>/<span class="variable">$IMAGE_NAME</span> /media/Lark/<span class="variable">$SELECTED_DISK</span>/<span class="variable">$2</span><span class="string">".img"</span></div><div class="line">umount /media/Lark/<span class="variable">$SELECTED_DISK</span></div><div class="line"><span class="keyword">if</span> [ $? == 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"<span class="variable">$SELECTED_DISK</span> 已卸载成功"</span> </div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"请卸载并拔除U盘"</span></div><div class="line"><span class="keyword">fi</span></div></pre></td></tr></table></figure><h3 id="系统备份"><a href="#系统备份" class="headerlink" title="系统备份"></a>系统备份</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#! /bin/bash</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> [ -d /media/Lark/.linuxroot ];<span class="keyword">then</span></div><div class="line">/bin/umount /media/Lark/.linuxroot</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"检测目前根文件大小"</span></div><div class="line">dupath=`du -m --total / --exclude=proc --exclude=media |grep 总用量 |cut -f 1`</div><div class="line">    fssize=<span class="variable">$dupath</span></div><div class="line">size=2500</div><div class="line"><span class="keyword">if</span> [ <span class="variable">$fssize</span> -gt <span class="variable">$size</span> ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"根文件大小大于备份区最大空间，请删减可删减的文件进行备份"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"检测系统一致性"</span></div><div class="line">/sbin/e2fsck -f -y  /dev/mmcblk0p6</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"一致性检测失败，请检测重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"扩展备份区到最大限额2.8G"</span></div><div class="line">/sbin/resize2fs /dev/mmcblk0p6 2600M</div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"扩大分区失败，请重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"挂载系统备份区"</span></div><div class="line"></div><div class="line">/bin/mount -o loop /dev/block/mtd/by-name/linuxfsbk /mnt</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"挂载系统备份区失败，请重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步当前系统"</span></div><div class="line"></div><div class="line">/usr/bin/rsync -axv --delete / /mnt </div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步当前系统失败，请重试"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"卸载系统备份区"</span></div><div class="line">/bin/umount /mnt</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"卸载系统备份区失败，请重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"同步完成"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"卸载系统备份区"</span></div><div class="line">/bin/umount /mnt</div><div class="line"></div><div class="line"><span class="keyword">if</span> [ $? -ne 0 ];<span class="keyword">then</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"卸载系统备份区失败，请重试"</span></div><div class="line"><span class="built_in">exit</span> 0</div><div class="line"><span class="keyword">fi</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"系统备份成功 "</span></div><div class="line"></div><div class="line">sleep 2</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算文件拷贝的进度&quot;&gt;&lt;a href=&quot;#计算文件拷贝的进度&quot; class=&quot;headerlink&quot; title=&quot;计算文件拷贝的进度&quot;&gt;&lt;/a&gt;计算文件拷贝的进度&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http://arvin-he.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Web之REST概念</title>
    <link href="http://arvin-he.github.io/2017/08/25/web-rest-2017-08-25/"/>
    <id>http://arvin-he.github.io/2017/08/25/web-rest-2017-08-25/</id>
    <published>2017-08-25T08:52:13.000Z</published>
    <updated>2017-09-08T03:51:40.204Z</updated>
    
    <content type="html"><![CDATA[<h3 id="REST当中为什么要使用HTTP-PUT"><a href="#REST当中为什么要使用HTTP-PUT" class="headerlink" title="REST当中为什么要使用HTTP PUT"></a>REST当中为什么要使用HTTP PUT</h3><p>REST(Representational State Transfer)是<strong>网络服务接口</strong>的一种<strong>风格</strong>，并不是一个标准，就web service而言，REST要比SOAP（SOAP是标准，不是风格）轻量得多，容易得多。我记得我最初开始接触web service的时候，所有的材料上来就是一大堆的名词，SOAP, WSDL,看得头都要大了，后来提出来的REST就容易理解得多，虽然目前SOAP在企业级的web service中还有一席之地，但是在公共的Internet上，不是REST的服务实在不好意思和人打招呼，我们经常可以看到评价某某服务是RESTful的，但是从来没有听说某某服务是SOAPful的 :-)<br>微软对REST的支持有点晚，自.NET3.5开始，WCF也可以提供RESTful接口。当然，REST不光限于web service，网页服务也可以RESTful，微软的ASP.NET MVC框架提供了直接的REST支持。</p><p>因为REST只是风格，不是标准，所以有的方面容易有误解，比如说创建和更新某个URI代表的资源的时候，是用HTTP的PUT还是POST命令。REST常用的四种HTTP命令，GET、DELETE、PUT和POST，对于GET和DELETE，一个是获取资源，一个是删除资源，没什么异议，问题是PUT和POST，两者都有更改指定URI的语义，那么，究竟是用哪一个呢？</p><p>有的观点认为，应该用POST来创建一个资源，用PUT来更新一个资源；有的观点认为，应该用PUT来创建一个资源，用POST来更新一个资源；还有的观点认为可以用PUT和POST中任何一个来做创建或者更新一个资源。这些观点都只看到了风格，争论起来也只是争论哪种风格更好，其实，用PUT还是POST，不是看这是创建还是更新资源的动作，这不是风格的问题，而是语义的问题。</p><p>REST是一种风格，但是还是依赖于HTTP协议，在HTTP中，PUT被定义为idempotent(幂等)的方法，POST则不是，这是一个很重要的区别。</p><p>“Methods can also have the property of “idempotence” in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request.”</p><p>上面的话就是说，如果一个方法重复执行多次，产生的效果是一样的，那就是idempotent的。</p><p>举一个简单的例子，加入由一个博客系统提供一个Web API，模式是这样<a href="http://superblogging/blogs/post/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP" target="_blank" rel="external">http://superblogging/blogs/post/{blog-name}，很简单，将{blog-name}替换为我们的blog名字，往这个URI发送一个HTTP</a> PUT或者POST请求，HTTP的body部分就是博文，这是一个很简单的REST API例子。我们应该用PUT方法还是POST方法？取决于这个REST服务的行为是否是idempotent的，假如我们发送两个<a href="http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。" target="_blank" rel="external">http://superblogging/blogs/post/Sample请求，服务器端是什么样的行为？如果产生了两个博客帖子，那就说明这个服务不是idempotent的，因为多次使用产生了副作用了嘛；如果后一个请求把第一个请求覆盖掉了，那这个服务就是idempotent的。前一种情况，应该使用POST方法，后一种情况，应该使用PUT方法。</a></p><p>也许你会觉得这个两个方法的差别没什么大不了的，用错了也不会有什么问题，但是你的服务一放到internet上，如果不遵从HTTP协议的规范，就可能给自己带来麻烦。比如，没准Google Crawler也会访问你的服务，如果让一个不是indempotent的服务可以用indempotent的方法访问，那么你服务器的状态可能就会被Crawler修改，这是不应该发生的。</p><h3 id="关于幂等的概念"><a href="#关于幂等的概念" class="headerlink" title="关于幂等的概念"></a>关于幂等的概念</h3><p>根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。</p><p>　　(1).所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。</p><p>　　* 注意：这里安全的含义仅仅是指是非修改信息。</p><p>　　(2).幂等的意味着对同一URL的多个请求应该返回同样的结果。这里我再解释一下幂等这个概念：</p><p>幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。<br>幂等有一下几种定义：<br>对于单目运算，如果一个运算对于在范围内的所有的一个数多次进行该运算所得的结果和进行一次该运算所得的结果是一样的，那么我们就称该运算是幂等的。比如绝对值运算就是一个例子，在实数集中，有abs(a)=abs(abs(a))。</p><p>对于双目运算，则要求当参与运算的两个值是等值的情况下，如果满足运算结果与参与运算的两个值相等，则称该运算幂等，如求两个数的最大值的函数，有在在实数集中幂等，即max(x,x) = x。<br>看完上述解释后，应该可以理解GET幂等的含义了。</p><p>但在实际应用中，以上2条规定并没有这么严格。引用别人文章的例子：比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。从根本上说，如果目标是当用户打开一个链接时，他可以确信从自身的角度来看没有改变资源即可。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.cnblogs.com/shanyou/archive/2011/10/17/2215930.html" target="_blank" rel="external">REST当中为什么要使用HTTP PUT</a></li><li><a href="http://www.cnblogs.com/hyddd/archive/2009/03/31/1426026.html" target="_blank" rel="external">浅谈HTTP中Get与Post的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;REST当中为什么要使用HTTP-PUT&quot;&gt;&lt;a href=&quot;#REST当中为什么要使用HTTP-PUT&quot; class=&quot;headerlink&quot; title=&quot;REST当中为什么要使用HTTP PUT&quot;&gt;&lt;/a&gt;REST当中为什么要使用HTTP PUT&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Web" scheme="http://arvin-he.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Web之Get和Post区别</title>
    <link href="http://arvin-he.github.io/2017/08/25/web-getpost-2017-08-25/"/>
    <id>http://arvin-he.github.io/2017/08/25/web-getpost-2017-08-25/</id>
    <published>2017-08-25T07:22:07.000Z</published>
    <updated>2017-09-08T03:51:40.201Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两种-HTTP-请求方法：GET-和-POST"><a href="#两种-HTTP-请求方法：GET-和-POST" class="headerlink" title="两种 HTTP 请求方法：GET 和 POST"></a>两种 HTTP 请求方法：GET 和 POST</h3><p>在客户机和服务器之间进行请求-响应时，两种最常被用到的方法是：GET 和 POST。</p><p>GET - 从指定的资源请求数据。</p><p>POST - 向指定的资源提交要被处理的数据</p><h3 id="GET-方法"><a href="#GET-方法" class="headerlink" title="GET 方法"></a>GET 方法</h3><p>请注意，查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：<br><code>/test/demo_form.asp?name1=value1&amp;name2=value2</code></p><p>有关 GET 请求的其他一些注释：</p><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制</li><li>GET 请求只应当用于取回数据</li></ul><h3 id="POST-方法"><a href="#POST-方法" class="headerlink" title="POST 方法"></a>POST 方法</h3><p>请注意，查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POST /test/demo_form.asp HTTP/1.1</div><div class="line">Host: w3schools.com</div><div class="line">name1=value1&amp;name2=value2</div></pre></td></tr></table></figure></p><p>有关 POST 请求的其他一些注释：</p><ul><li>OST 请求不会被缓存</li><li>POST 请求不会保留在浏览器历史记录中</li><li>POST 不能被收藏为书签</li><li>POST 请求对数据长度没有要求</li></ul><h3 id="GET-与-POST区别"><a href="#GET-与-POST区别" class="headerlink" title="GET 与 POST区别"></a>GET 与 POST区别</h3><ol><li><p>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.</p></li><li><p>GET提交的数据大小有限制（因为浏览器对URL的长度有限制），而POST方法提交的数据没有限制.</p></li><li><p>GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。</p></li><li><p>GET方式提交数据，会带来安全问题，比如一个登录页面，通过GET方式提交数据时，用户名和密码将出现在URL上，如果页面可以被缓存或者其他人可以访问这台机器，就可以从历史记录获得该用户的账号和密码.</p></li></ol><h3 id="一些误区"><a href="#一些误区" class="headerlink" title="一些误区"></a>一些误区</h3><p>误区一：POST可以比GET提交更多更长的数据？<br>由于使用GET方法提交数据时，以?分割URL和传输数据，参数之间以&amp;相连，在URL后面添加需要提交的参数，有人就会说了，浏览器地址栏输入的参数是有限的，而POST不用再地址栏输入，所以POST就比GET可以提交更多的数据。难道真的是这样的么？<br>而实际上，URL不存在参数上限的问题，HTTP协议规范<strong>没有</strong>对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。<br>同时，POST是没有大小限制的，HTTP协议规范也没有进行大小限制。POST数据是没有限制的，<strong>起限制作用的是服务器的处理程序的处理能力。</strong><br>总归一句话，这个限制是针对所有HTTP请求的，与GET、POST没有多少关系。</p><p>误区二：POST比GET安全？<br>首先，我们要承认安全的概念有很多种，要是从最基本的肉眼看到就不安全，肉眼看不到那就是安全的概念说呢，GET确实没有POST安全，毕竟小白用户确实可以看到在URL中带有的数据信息，这个你无法狡辩。那么要是往严谨了说呢，POST是不是要比GET安全呢？其实不是的。<br>上面也说了，GET将提交到服务器的数据添加到URL中了，可见；虽然POST的数据，你肉眼看不到，你抓个包看看，在HTTP包的包体中，我们提交的数据时仍然可见的.</p><h3 id="比较GET-与-POST"><a href="#比较GET-与-POST" class="headerlink" title="比较GET 与 POST"></a>比较GET 与 POST</h3><p>下面的表格比较了两种 HTTP 方法：GET 和 POST。</p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>后退按钮/刷新</td><td>无害</td><td>数据会被重新提交（浏览器应该告知用户数据会被重新提交）。</td></tr><tr><td>书签</td><td>可收藏为书签</td><td>不可收藏为书签</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能缓存</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。</td></tr><tr><td>历史</td><td>参数保留在浏览器历史中。</td><td>参数不会保存在浏览器历史中。</td></tr><tr><td>对数据长度的限制</td><td>是的。当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。</td><td>无限制。</td></tr><tr><td>对数据类型的限制</td><td>只允许 ASCII 字符。</td><td>没有限制。也允许二进制数据。</td></tr><tr><td>安全性</td><td>与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！</td><td>POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。</td></tr><tr><td>可见性</td><td>数据在 URL 中对所有人都是可见的。</td><td>数据不会显示在 URL 中。</td></tr></tbody></table><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>很多时候，大家都觉的使用GET很方便，毕竟使用POST要用到Form，但是，你要知道，你使用GET方法时，浏览器可能会缓存你的地址等信息，还会留下历史记录，而对于POST方法呢，则不会进行缓存。在开发中，一定要分清楚GET和POST的使用场合，什么时候要使用GET，什么时候要使用POST，自己做到心中有数。</p><p>可能，你在Google类似的文章的时候，可能会看到分析POST和PUT区别的文章，这又是一类纠结的东西，更多的时候，我们分析这种东西都是分实际情景，结合设计者的语义去使用.</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://www.w3school.com.cn/tags/html_ref_httpmethods.asp" target="_blank" rel="external">w3cschool</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;两种-HTTP-请求方法：GET-和-POST&quot;&gt;&lt;a href=&quot;#两种-HTTP-请求方法：GET-和-POST&quot; class=&quot;headerlink&quot; title=&quot;两种 HTTP 请求方法：GET 和 POST&quot;&gt;&lt;/a&gt;两种 HTTP 请求方法：GET 
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Web" scheme="http://arvin-he.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>爬虫基础知识(一)</title>
    <link href="http://arvin-he.github.io/2017/08/25/py-scrapy1-2017-08-25/"/>
    <id>http://arvin-he.github.io/2017/08/25/py-scrapy1-2017-08-25/</id>
    <published>2017-08-25T06:12:06.000Z</published>
    <updated>2017-09-08T03:51:39.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-URL"><a href="#1-URL" class="headerlink" title="1. URL"></a>1. URL</h3><p>URL的格式由三部分组成：<br>第一部分是协议(或称为服务方式)。<br>第二部分是存有该资源的主机IP地址(有时也包括端口号)。<br>第三部分是主机资源的具体地址，如目录和文件名等。</p><p>爬虫爬取数据时必须要有一个目标的URL才可以获取数据，因此，它是爬虫获取数据的基本依据，准确理解它的含义对爬虫学习有很大帮助。</p><h3 id="关于urllib2包"><a href="#关于urllib2包" class="headerlink" title="关于urllib2包"></a>关于urllib2包</h3><p>python 3.X版本是不需要安装urllib2包，urllib和urllib2包集合成在一个包为urllib了.<br>在python3.x版本中，如何使用：urllib2.urlopen()？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"><span class="keyword">import</span> urllib.request</div><div class="line"></div><div class="line">response = urllib.request.urlopen(<span class="string">"http://www.baidu.com"</span>)</div><div class="line">print(response.read())</div><div class="line"></div><div class="line">URL = <span class="string">"http://www.baidu.com"</span></div><div class="line">request = urllib.request.Request(URL)</div><div class="line">response = urllib.request.urlopen(request)</div><div class="line">print(response.read())</div></pre></td></tr></table></figure></p><h3 id="POST和GET数据传送"><a href="#POST和GET数据传送" class="headerlink" title="POST和GET数据传送"></a>POST和GET数据传送</h3><p>大多数网站都是动态网页，需要你动态地传递参数给它，它做出对应的响应。所以，在访问时，我们需要传递数据给它。</p><p>urlopen一般接受三个参数，它的参数如下：<code>urlopen(url, data, timeout)</code><br>第一个参数url即为URL，第二个参数data是访问URL时要传送的数据，第三个timeout是设置超时时间。<br>第二,三个参数是可以不传送的，data默认为空None，timeout默认为 <code>socket._GLOBAL_DEFAULT_TIMEOUT</code></p><h4 id="POST方式："><a href="#POST方式：" class="headerlink" title="POST方式："></a>POST方式：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"> </div><div class="line">values = &#123;<span class="string">"username"</span>:<span class="string">"xxxx@qq.com"</span>,<span class="string">"password"</span>:<span class="string">"XXXX"</span>&#125;</div><div class="line">data = urllib.urlencode(values) </div><div class="line">url = <span class="string">"https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn"</span></div><div class="line">request = urllib.request.Request(url, data)</div><div class="line">response = urllib.request.urlopen(request)</div><div class="line">print(response.read())</div></pre></td></tr></table></figure><h4 id="GET方式："><a href="#GET方式：" class="headerlink" title="GET方式："></a>GET方式：</h4><p>至于GET方式我们可以直接把参数写到网址上面，直接<strong>构建一个带参数的URL</strong>出来即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> urllib</div><div class="line"> </div><div class="line">values=&#123;&#125;</div><div class="line">values[<span class="string">'username'</span>] = <span class="string">"xxxx@qq.com"</span></div><div class="line">values[<span class="string">'password'</span>]=<span class="string">"XXXX"</span></div><div class="line">data = urllib.urlencode(values) </div><div class="line">url = <span class="string">"http://passport.csdn.net/account/login"</span></div><div class="line">geturl = url + <span class="string">"?"</span> + data</div><div class="line">request = urllib.request.Request(geturl)</div><div class="line">response = urllib.request.urlopen(request)</div><div class="line">print(response.read())</div></pre></td></tr></table></figure></p><h3 id="python3中urllib的模块分4个子模块"><a href="#python3中urllib的模块分4个子模块" class="headerlink" title="python3中urllib的模块分4个子模块"></a>python3中urllib的模块分4个子模块</h3><p>urllib.request for opening and reading URLs<br>urllib.error containing the exceptions raised by urllib.request<br>urllib.parse for parsing URLs<br>urllib.robotparser for parsing robots.txt files</p><h3 id="python3中urllib报错"><a href="#python3中urllib报错" class="headerlink" title="python3中urllib报错"></a>python3中urllib报错</h3><p> 爬虫过程报错：http.client.RemoteDisconnected: Remote end closed connection without response<br> 利用 urllib 发起的请求，UA 默认是 Python-urllib/3.5 而在 chrome 中访问则 user_agent = ‘Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.113 Safari/537.36’，因为服务器根据 UA 来判断拒绝了 python 爬虫。</p><p> 在浏览器中可以查看自己浏览器的UA</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-URL&quot;&gt;&lt;a href=&quot;#1-URL&quot; class=&quot;headerlink&quot; title=&quot;1. URL&quot;&gt;&lt;/a&gt;1. URL&lt;/h3&gt;&lt;p&gt;URL的格式由三部分组成：&lt;br&gt;第一部分是协议(或称为服务方式)。&lt;br&gt;第二部分是存有该资源的主机IP地址(
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="爬虫" scheme="http://arvin-he.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python之jsonrpc</title>
    <link href="http://arvin-he.github.io/2017/08/25/py-jsonrpc-2017-08-25/"/>
    <id>http://arvin-he.github.io/2017/08/25/py-jsonrpc-2017-08-25/</id>
    <published>2017-08-25T03:38:39.000Z</published>
    <updated>2017-09-08T03:51:39.871Z</updated>
    
    <content type="html"><![CDATA[<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># server</span></div><div class="line"><span class="keyword">from</span> http.server <span class="keyword">import</span> BaseHTTPRequestHandler, HTTPServer</div><div class="line"><span class="keyword">from</span> jsonrpcserver <span class="keyword">import</span> methods</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@methods.add</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span>(<span class="string">'ping'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@methods.add</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hao</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">return</span>(<span class="string">'hao'</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@methods.add</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    <span class="keyword">return</span>(<span class="string">'Hello, %s'</span> % name)</div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">@methods.add</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Sum</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="keyword">return</span>(a + b)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestHttpServer</span><span class="params">(BaseHTTPRequestHandler)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">do_POST</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># Process request</span></div><div class="line">        request = self.rfile.read(int(self.headers[<span class="string">'Content-Length'</span>])).decode()</div><div class="line">        response = methods.dispatch(request)</div><div class="line">        <span class="comment"># Return response</span></div><div class="line">        self.send_response(response.http_status)</div><div class="line">        self.send_header(<span class="string">'Content-type'</span>, <span class="string">'application/json'</span>)</div><div class="line">        self.end_headers()</div><div class="line">        self.wfile.write(str(response).encode())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    HTTPServer((<span class="string">'localhost'</span>, <span class="number">5000</span>), TestHttpServer).serve_forever()</div></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> jsonrpcclient.http_client <span class="keyword">import</span> HTTPClient</div><div class="line"></div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'ping'</span>)</div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'hao'</span>)</div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'hello'</span>, <span class="string">'Nancy'</span>)</div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'Sum'</span>, <span class="number">5</span>, <span class="number">7</span>)</div><div class="line">HTTPClient(<span class="string">'http://localhost:5000'</span>).request(<span class="string">'lid'</span>)</div></pre></td></tr></table></figure><p>先运行服务端,再运行客户端代码</p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">--&gt; &#123;&quot;id&quot;: 1, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;ping&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: &quot;ping&quot;, &quot;id&quot;: 1&#125; (200 OK)</div><div class="line">--&gt; &#123;&quot;id&quot;: 2, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;hao&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: &quot;hao&quot;, &quot;id&quot;: 2&#125; (200 OK)</div><div class="line">--&gt; &#123;&quot;params&quot;: [&quot;Nancy&quot;], &quot;id&quot;: 3, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;hello&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: &quot;Hello, Nancy&quot;, &quot;id&quot;: 3&#125; (200 OK)</div><div class="line">--&gt; &#123;&quot;params&quot;: [5, 7], &quot;id&quot;: 4, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;Sum&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 12, &quot;id&quot;: 4&#125; (200 OK)</div><div class="line">--&gt; &#123;&quot;id&quot;: 5, &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;lid&quot;&#125;</div><div class="line">&lt;-- &#123;&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;error&quot;: &#123;&quot;code&quot;: -32601, &quot;message&quot;: &quot;Method not found&quot;&#125;, &quot;id&quot;: 5&#125; (404 Not Found)</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;js_client.py&quot;, line 7, in &lt;module&gt;</div><div class="line">    HTTPClient(&apos;http://localhost:5000&apos;).request(&apos;lid&apos;)</div><div class="line">  File &quot;C:\Python34\lib\site-packages\jsonrpcclient\client.py&quot;, line 200, in request</div><div class="line">    return self.send(Request(method_name, *args, **kwargs))</div><div class="line">  File &quot;C:\Python34\lib\site-packages\jsonrpcclient\client.py&quot;, line 171, in send</div><div class="line">    return self._send_message(request, **kwargs)</div><div class="line">  File &quot;C:\Python34\lib\site-packages\jsonrpcclient\http_client.py&quot;, line 82, in _send_message</div><div class="line">    log_format=&apos;&lt;-- %(message)s (%(http_code)s %(http_reason)s)&apos;)</div><div class="line">  File &quot;C:\Python34\lib\site-packages\jsonrpcclient\client.py&quot;, line 114, in _process_response</div><div class="line">    response[&apos;error&apos;].get(&apos;data&apos;))</div><div class="line">jsonrpcclient.exceptions.ReceivedErrorResponse: Method not found</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;服务端&quot;&gt;&lt;a href=&quot;#服务端&quot; class=&quot;headerlink&quot; title=&quot;服务端&quot;&gt;&lt;/a&gt;服务端&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>正向代理和反向代理</title>
    <link href="http://arvin-he.github.io/2017/08/24/web-forwardbackagent-2017-08-24/"/>
    <id>http://arvin-he.github.io/2017/08/24/web-forwardbackagent-2017-08-24/</id>
    <published>2017-08-24T06:56:13.000Z</published>
    <updated>2017-09-08T03:51:40.194Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被代理服务器代替来请求，某些科学上网工具扮演的就是典型的正向代理角色。用浏览器访问 <a href="http://www.google.com" target="_blank" rel="external">http://www.google.com</a> 时，被残忍的block，于是你可以在国外搭建一台代理服务器，让代理帮我去请求<code>google.com</code>，代理把请求返回的相应结构再返回给我.</p><p><img src="/2017/08/24/web-forwardbackagent-2017-08-24/1.png" alt=""></p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理隐藏了真实的服务端，当我们请求 www.baidu.com 的时候，就像拨打10086一样，背后可能有成千上万台服务器为我们服务，但具体是哪一台，你不知道，也不需要知道，你只需要知道反向代理服务器是谁就好了，www.baidu.com 就是我们的反向代理服务器，反向代理服务器会帮我们把请求转发到真实的服务器那里去。Nginx就是性能非常好的反向代理服务器，用来做负载均衡.</p><p><img src="/2017/08/24/web-forwardbackagent-2017-08-24/2.png" alt=""></p><p>两者的区别在于代理的对象不一样：正向代理代理的对象是客户端，反向代理代理的对象是服务端</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.zhihu.com/question/24723688" target="_blank" rel="external">知乎</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h3&gt;&lt;p&gt;我们常说的代理也就是只正向代理，正向代理的过程，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端请求的服务都被
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="web" scheme="http://arvin-he.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>Python爬虫总结</title>
    <link href="http://arvin-he.github.io/2017/08/23/py-scrapysummer-2017-08-23/"/>
    <id>http://arvin-he.github.io/2017/08/23/py-scrapysummer-2017-08-23/</id>
    <published>2017-08-23T03:38:57.000Z</published>
    <updated>2017-09-08T03:51:39.893Z</updated>
    
    <content type="html"><![CDATA[<h3 id="爬虫需要用到的工具"><a href="#爬虫需要用到的工具" class="headerlink" title="爬虫需要用到的工具"></a>爬虫需要用到的工具</h3><p>正则表达式<br>XPATH<br>beautifulsoup<br>requests<br>urllib<br>urllib2<br>scrapy</p><p>分布式爬虫<br>学会怎样维护一个所有集群机器能够有效分享的分布式队列就好。最简单的实现是python-rq: <a href="https://github.com/nvie/rq" target="_blank" rel="external">https://github.com/nvie/rq</a></p><p>Bloom Filter: Bloom Filters by Example<br>Bloom Filter. 简单讲它仍然是一种hash的方法，但是它的特点是，它可以使用固定的内存（不随url的数量而增长）以O(1)的效率判定url是否已经在set中。可惜天下没有白吃的午餐，它的唯一问题在于，如果这个url不在set中，BF可以100%确定这个url没有看过。但是如果这个url在set中，它会告诉你：这个url应该已经出现过，不过我有2%的不确定性。注意这里的不确定性在你分配的内存足够大的时候，可以变得很小很少。一个简单的教程:<a href="https://llimllib.github.io/bloomfilter-tutorial/" target="_blank" rel="external">Bloom Filters by Example</a></p><p>rq和Scrapy的结合：<br>后续处理，网页析取，存储(Mongodb)</p><p>你只有一台机器。不管你的带宽有多大，只要你的机器下载网页的速度是瓶颈的话，那么你只有加快这个速度。用一台机子不够的话——用很多台吧！当然，我们假设每台机子都已经进了最大的效率——使用多线程（python的话，多进程吧）。</p><p>我们把这100台中的99台运算能力较小的机器叫作slave，另外一台较大的机器叫作master，那么回顾上面代码中的url_queue，如果我们能把这个queue放到这台master机器上，所有的slave都可以通过网络跟master联通，每当一个slave完成下载一个网页，就向master请求一个新的网页来抓取。而每次slave新抓到一个网页，就把这个网页上所有的链接送到master的queue里去。同样，bloom filter也放到master上，但是现在master只发送确定没有被访问过的url给slave。Bloom Filter放到master的内存里，而被访问过的url放到运行在master上的Redis里，这样保证所有操作都是O(1)。（至少平摊是O(1)，Redis的访问效率见:LINSERT – Redis)</p><p>考虑如何用python实现：<br>在各台slave上装好scrapy，那么各台机子就变成了一台有抓取能力的slave，在master上装好Redis和rq用作分布式队列。</p><p>chrome浏览器 F12开发者工具</p><p>selenium<br>phantomjs</p><p>PIL<br>opencv<br>pybrain<br>pyspider</p><p>代理IP池</p><p>不要用1个IP狂抓<br>勤换UA<br>爬取间隔自适应</p><p>scrapy/pyspider框架部署</p><ul><li><a href="https://www.zhihu.com/question/20899988" target="_blank" rel="external">https://www.zhihu.com/question/20899988</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;爬虫需要用到的工具&quot;&gt;&lt;a href=&quot;#爬虫需要用到的工具&quot; class=&quot;headerlink&quot; title=&quot;爬虫需要用到的工具&quot;&gt;&lt;/a&gt;爬虫需要用到的工具&lt;/h3&gt;&lt;p&gt;正则表达式&lt;br&gt;XPATH&lt;br&gt;beautifulsoup&lt;br&gt;request
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
      <category term="爬虫" scheme="http://arvin-he.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>linux开机自启</title>
    <link href="http://arvin-he.github.io/2017/08/18/linux-bash1-2017-08-18/"/>
    <id>http://arvin-he.github.io/2017/08/18/linux-bash1-2017-08-18/</id>
    <published>2017-08-18T01:51:19.000Z</published>
    <updated>2017-09-08T03:51:39.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux下终端执行自定义命令启动程序"><a href="#Linux下终端执行自定义命令启动程序" class="headerlink" title="Linux下终端执行自定义命令启动程序"></a>Linux下终端执行自定义命令启动程序</h3><p>在/usr/bin目录下一般会存放一个shell脚本,然后在终端输入该shell脚本的名字,就会在终端执行这个shell脚本.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="comment"># 搜索进程中touchpanel的进程数目,这里是为了保持脚本执行的单个实例</span></div><div class="line">var=`ps -aux |grep <span class="string">"/usr/bin/touchpanel"</span> |wc -l`</div><div class="line"><span class="comment"># 注意空格不能少</span></div><div class="line"><span class="keyword">if</span> [ <span class="variable">$var</span> -gt 3 ];<span class="keyword">then</span></div><div class="line">    <span class="built_in">exit</span></div><div class="line"><span class="keyword">fi</span></div><div class="line"></div><div class="line"><span class="built_in">cd</span> /opt/touchpanel</div><div class="line"></div><div class="line">sudo python3 main.py <span class="variable">$@</span></div></pre></td></tr></table></figure></p><h3 id="Linux下如何开机自启应用程序"><a href="#Linux下如何开机自启应用程序" class="headerlink" title="Linux下如何开机自启应用程序"></a>Linux下如何开机自启应用程序</h3><p>编写一个*.desktop文件,然后将该文件放在/etc/xdg/autostart下,然后就会开机自动启动应用程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[Desktop Entry]</div><div class="line">Type=Application</div><div class="line">Icon=</div><div class="line">Name=TouchPanel</div><div class="line">Comment=xxx</div><div class="line">Categories=GNOME;GTK;System;</div><div class="line">Exec=touchpanel</div><div class="line">StartupNotify=<span class="literal">true</span></div><div class="line">Terminal=<span class="literal">false</span></div></pre></td></tr></table></figure></p><h3 id="制作deb安装包"><a href="#制作deb安装包" class="headerlink" title="制作deb安装包"></a>制作deb安装包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"1. 获取版本号"</span></div><div class="line">version=`awk <span class="string">'NR==2&#123;print $2&#125;'</span> deb/DEBIAN/control`</div><div class="line"><span class="built_in">echo</span> <span class="string">"version = <span class="variable">$&#123;version&#125;</span>"</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"2. 拷贝资源文件"</span></div><div class="line">mkdir -p deb/opt/pun-admin/res</div><div class="line">mkdir -p deb/usr/bin</div><div class="line">mkdir -p deb/usr/share/applications</div><div class="line">mkdir -p deb/usr/share/pixmaps</div><div class="line">cp res/*.ui deb/opt/pun-admin/res/</div><div class="line">cp res/config.ini deb/opt/pun-admin/res/</div><div class="line">cp res/pun.desktop deb/opt/pun-admin/res/</div><div class="line">cp res/pun-admin.desktop deb/usr/share/applications/</div><div class="line">cp res/*.png deb/usr/share/pixmaps/</div><div class="line">cp res/pun-admin deb/usr/bin/</div><div class="line">cp res/touchpanel.desktop deb/opt/pun-admin/res/</div><div class="line">cp res/touchpanel deb/usr/bin/</div><div class="line"><span class="built_in">echo</span> <span class="string">"3. 拷贝程序"</span></div><div class="line">cp *.py deb/opt/pun-admin/</div><div class="line"><span class="built_in">echo</span> <span class="string">"4. 添加可执行权限"</span></div><div class="line">chmod +x deb/usr/bin/pun-admin</div><div class="line">chmod +x deb/usr/bin/touchpanel</div><div class="line"><span class="built_in">echo</span> <span class="string">"5. dpkg打包"</span></div><div class="line">dpkg-deb --build deb pun-admin-<span class="variable">$&#123;version&#125;</span>.deb</div><div class="line"><span class="built_in">echo</span> <span class="string">"6. 打包结束"</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux下终端执行自定义命令启动程序&quot;&gt;&lt;a href=&quot;#Linux下终端执行自定义命令启动程序&quot; class=&quot;headerlink&quot; title=&quot;Linux下终端执行自定义命令启动程序&quot;&gt;&lt;/a&gt;Linux下终端执行自定义命令启动程序&lt;/h3&gt;&lt;p&gt;在/
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http://arvin-he.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python的sys.path, PYTHONPATH, os.environ的作用</title>
    <link href="http://arvin-he.github.io/2017/08/13/py-pyhonpath-2017-08-13/"/>
    <id>http://arvin-he.github.io/2017/08/13/py-pyhonpath-2017-08-13/</id>
    <published>2017-08-13T11:06:37.000Z</published>
    <updated>2017-09-08T03:51:39.881Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python搜索模块的路径："><a href="#Python搜索模块的路径：" class="headerlink" title="Python搜索模块的路径："></a>Python搜索模块的路径：</h3><ol><li>程序的主目录</li><li>PTYHONPATH目录（如果已经进行了设置）</li><li>标准连接库目录（一般在/usr/local/lib/python2.X/）</li><li>任何的.pth文件的内容（如果存在的话）.新功能，允许用户把有效果的目录添加到模块搜索路径中去, <code>.pth</code>后缀的文本文件中一行一行的地列出目录。</li></ol><p>这四个组建组合起来就变成了sys.path了</p><h3 id="关于sys-path"><a href="#关于sys-path" class="headerlink" title="关于sys.path"></a>关于sys.path</h3><p>在python 环境下使用sys.path.append(path)添加相关的路径，但在退出python环境后自己添加的路径就会自动消失.<br>如何将路径“永久”添加到sys.path?</p><ol><li>将自己做的py文件放到 site_packages 目录下,但是这样做会导致一个问题，即各类模块都放到此文件夹的话，会导致乱的问题.</li><li>使用pth文件，在 site-packages 文件中创建 .pth文件，将模块的路径写进去，一行一个路径，但存在管理上的问题，而且不能在不同的python版本中共享。</li><li>使用PYTHONPATH环境变量，在这个环境变量中输入相关的路径，不同的路径之间用逗号（英文的！)分开，如果PYTHONPATH 变量还不存在，可以创建它.路径会自动加入到sys.path中，而且可以在不同的python版本中共享，应该是一样较为方便的方法。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">16</span>]: sys.path</div><div class="line">Out[<span class="number">16</span>]:</div><div class="line">[<span class="string">''</span>,</div><div class="line"> <span class="string">'C:\\Program Files\\Python36\\Scripts\\ipython.exe'</span>,</div><div class="line"> <span class="string">'c:\\program files\\python36\\python36.zip'</span>,</div><div class="line"> <span class="string">'c:\\program files\\python36\\DLLs'</span>,</div><div class="line"> <span class="string">'c:\\program files\\python36\\lib'</span>,</div><div class="line"> <span class="string">'c:\\program files\\python36'</span>,</div><div class="line"> <span class="string">'c:\\program files\\python36\\lib\\site-packages'</span>,</div><div class="line"> <span class="string">'c:\\program files\\python36\\lib\\site-packages\\win32'</span>,</div><div class="line"> <span class="string">'c:\\program files\\python36\\lib\\site-packages\\win32\\lib'</span>,</div><div class="line"> <span class="string">'c:\\program files\\python36\\lib\\site-packages\\Pythonwin'</span>,</div><div class="line"> <span class="string">'c:\\program files\\python36\\lib\\site-packages\\IPython\\extensions'</span>,</div><div class="line"> <span class="string">'C:\\Users\\Arvin\\.ipython'</span>]</div></pre></td></tr></table></figure><h3 id="关于PYTHONPATH"><a href="#关于PYTHONPATH" class="headerlink" title="关于PYTHONPATH"></a>关于PYTHONPATH</h3><h3 id="关于os-environ"><a href="#关于os-environ" class="headerlink" title="关于os.environ"></a>关于os.environ</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">environ是一个字符串对应环境的映像对象</div><div class="line">os.environ.keys() 主目录下所有的key</div><div class="line">os.environ 显示key+内容</div><div class="line"></div><div class="line"># windows：</div><div class="line">· os.environ[&apos;HOMEPATH&apos;]:当前用户主目录。</div><div class="line">os.environ[&apos;TEMP&apos;]:临时目录路径。</div><div class="line">os.environ[PATHEXT&apos;]:可执行文件。</div><div class="line">os.environ[&apos;SYSTEMROOT&apos;]:系统主目录。</div><div class="line">os.environ[&apos;LOGONSERVER&apos;]:机器名。</div><div class="line">os.environ[&apos;PROMPT&apos;]:设置提示符。</div><div class="line"># linux：</div><div class="line">os.environ[&apos;USER&apos;]:当前使用用户。</div><div class="line">os.environ[&apos;LC_COLLATE&apos;]:路径扩展的结果排序时的字母顺序。</div><div class="line">os.environ[&apos;SHELL&apos;]:使用shell的类型。</div><div class="line">os.environ[&apos;LAN&apos;]:使用的语言。</div><div class="line">os.environ[&apos;SSH_AUTH_SOCK&apos;]:ssh的执行路径。</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Python搜索模块的路径：&quot;&gt;&lt;a href=&quot;#Python搜索模块的路径：&quot; class=&quot;headerlink&quot; title=&quot;Python搜索模块的路径：&quot;&gt;&lt;/a&gt;Python搜索模块的路径：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;程序的主目录&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>PyQt5加载ui的几种方式</title>
    <link href="http://arvin-he.github.io/2017/08/12/pyqt-loadui-2017-08-12/"/>
    <id>http://arvin-he.github.io/2017/08/12/pyqt-loadui-2017-08-12/</id>
    <published>2017-08-12T02:52:06.000Z</published>
    <updated>2017-09-08T03:51:39.964Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一般界面的创建有两种方式:</p><ol><li>使用纯代码实现</li><li>使用designer来拖拽控件<br>两种方式各有各自的好处,视具体的使用场景来选择.</li></ol><p>使用纯代码实现时一些属性需要在代码中指定, 或者继承某个控件类并定制添加一些属性和功能.这种方式比较灵活.但是控件太多且是不同种类的控件的话就有点繁琐了.</p><p>使用designer的方式是直观,快速,属性可视化,可添加动态属性,这也是使用比较多的方式.在designer中设计好界面后,保存为一个后缀为ui的文件,用文本编辑器打开是一个xml格式的文件,里面指明控件的各个属性.</p><p>下面就讲述在代码中加载ui的几种方式.</p><h3 id="PyQt5中加载ui的方式"><a href="#PyQt5中加载ui的方式" class="headerlink" title="PyQt5中加载ui的方式"></a>PyQt5中加载ui的方式</h3><p>PyQt5中加载ui的方式主要有3种:</p><ol><li>直接加载ui文件</li><li>将ui文件转成py文件加载</li><li>将所有的资源文件(包括ui,图片等)编译成内容是字节的py文件加载</li></ol><h3 id="直接加载ui文件"><a href="#直接加载ui文件" class="headerlink" title="直接加载ui文件"></a>直接加载ui文件</h3><p>使用uic加载ui文件,看下面代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtWidgets, uic, QtCore</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDialog</span><span class="params">(QtWidgets.QDialog)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(MyDialog, self).__init__()</div><div class="line">        uic.loadUi(os.path.join(os.path.dirname(__file__), <span class="string">"yourDialog.ui"</span>), self)</div><div class="line">        self.initUI()</div></pre></td></tr></table></figure></p><p>ui的控件直接通过<code>self</code>来获取访问,比如<code>self.mylabel.setText(&quot;xxx&quot;)</code>,这是最直接的方式.<br>适用于简单的界面设计.</p><h3 id="将ui文件转成py文件加载"><a href="#将ui文件转成py文件加载" class="headerlink" title="将ui文件转成py文件加载"></a>将ui文件转成py文件加载</h3><p>Qt Designer默认继承的object类，但不提供show()显示方法.<br>如何将ui文件转为py文件?<br>使用pyqt5中自带的工具pyuic5,pyuic5是一个可执行文件,在控制台可作为命令使用,具体使用参考下面的脚本<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"></div><div class="line">inputFile = os.path.abspath(os.path.join(<span class="string">"../res"</span>, <span class="string">"serialCom.ui"</span>))</div><div class="line">print(<span class="string">"input file =&#123;&#125;"</span>.format(inputFile))</div><div class="line">outputFile = os.path.abspath(<span class="string">"../serialCom_ui.py"</span>)</div><div class="line">print(<span class="string">"output file =&#123;&#125;"</span>.format(outputFile))</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="comment"># py3.4.3</span></div><div class="line">    subprocess.call([<span class="string">"pyuic5.bat"</span>, inputFile, <span class="string">"-o"</span>, outputFile])</div><div class="line"><span class="keyword">except</span>:</div><div class="line">    <span class="comment"># py3.6</span></div><div class="line">    subprocess.call([<span class="string">"pyuic5"</span>, inputFile, <span class="string">"-o"</span>, outputFile])</div><div class="line">print(<span class="string">"build ui done."</span>)</div></pre></td></tr></table></figure></p><p>根据上面的脚本会根据ui文件生成一个py文件,那么这个py文件有哪些内容呢?<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore, QtGui, QtWidgets</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ui_serialDlg</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setupUi</span><span class="params">(self, serialDlg)</span>:</span></div><div class="line">        serialDlg.setObjectName(<span class="string">"serialDlg"</span>)</div><div class="line">        serialDlg.resize(<span class="number">1024</span>, <span class="number">768</span>)</div><div class="line">        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)</div><div class="line">        <span class="comment"># 这里省略了ui控件的属性设定</span></div><div class="line">        ...</div><div class="line">        self.retranslateUi(serialDlg)</div><div class="line">        QtCore.QMetaObject.connectSlotsByName(serialDlg)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">retranslateUi</span><span class="params">(self, serialDlg)</span>:</span></div><div class="line">        _translate = QtCore.QCoreApplication.translate</div><div class="line">        <span class="comment"># 这里略去了各种翻译的内容</span></div><div class="line">        ...</div></pre></td></tr></table></figure></p><p>从这个py看出,这个py文件生成了一个类,里面有2个函数,分别是<code>setupUi</code>和<code>retranslateUi</code>.<br>setupUi中主要是控件的各个属性设置, retranslateUi主要是翻译的内容<br>下面如何在你的代码中加载这个py文件呢?<br>有两种方式<br>第一种: 直接继承这个类, python中支持多继承<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> serialCom_ui <span class="keyword">import</span> Ui_serialDlg <span class="keyword">as</span> serialDlg</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QDialog, serialDlg)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(MainWindow, self).__init__()</div><div class="line">        self.setupUi(self)</div></pre></td></tr></table></figure></p><p>第二种: 在你的代码中实例化<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> serialCom_ui <span class="keyword">import</span> Ui_serialDlg <span class="keyword">as</span> serialDlg</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QDialog)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(MainWindow, self).__init__()</div><div class="line">        self.serial_dlg=serialDlg()  </div><div class="line">        self.serial_dlg.setupUi(self)</div></pre></td></tr></table></figure></p><p>为什么要生成py文件呢?主要是为了实现代码与界面分离。<br>缺点:ui文件有了更改,必须要再次生成对应的py文件,如果你忘记生成了,就会造成ui不同步.<br>优点:不再需要这个ui文件了.这就相当于使用纯代码的实现方式了.但这样的方式显然比纯代码要快,而且能做到<br>逻辑代码和界面代码分离.</p><h3 id="生成qrc文件编译资源文件生成py文件加载"><a href="#生成qrc文件编译资源文件生成py文件加载" class="headerlink" title="生成qrc文件编译资源文件生成py文件加载"></a>生成qrc文件编译资源文件生成py文件加载</h3><p>当有ui文件还有图片等资源文件时,怎么办呢?当图片重命名了怎么办? 当然是利用Qt的资源系统来整合这些资源文件了.<br>Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。<br>如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。<br>也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。<br>怎么做呢?<br>一般把用到的资源文件放到一个文件夹中,如res/,然后创建一个资源文件*.qrc,该文件生成在res文件夹中<br>qrc文件的内容有,如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;RCC&gt;&lt;qresource prefix=&quot;..&quot;&gt;</div><div class="line">  &lt;file mtime=&quot;1502414194.7463503&quot;&gt;favor.ico&lt;/file&gt;</div><div class="line">  &lt;file mtime=&quot;1494807198.7998164&quot;&gt;favor.png&lt;/file&gt;</div><div class="line">  &lt;file mtime=&quot;1502505175.56&quot;&gt;serialCom.ui&lt;/file&gt;</div><div class="line">  &lt;file mtime=&quot;1502414207.032053&quot;&gt;uninst.ico&lt;/file&gt;</div><div class="line">&lt;/qresource&gt;&lt;/RCC&gt;</div></pre></td></tr></table></figure></p><p>python中创建qrc文件,然后通过pyrcc5将资源文件编译到py文件中去<br>这里不仅仅生成qrc文件,还对qrc文件记录了资源文件最后的修改时间,并做了修改时间对比,<br>一旦有ui文件被修改了,就会重新编译生成res_rc.py文件.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 自动编译加载资源</span></div><div class="line">_res_path = os.path.abspath(<span class="string">'res'</span>)</div><div class="line">RCC = <span class="string">"""&lt;RCC&gt;&lt;qresource prefix="&#123;&#125;"&gt;\n&#123;&#125;&lt;/qresource&gt;&lt;/RCC&gt;"""</span></div><div class="line">FILE = <span class="string">"""  &lt;file mtime="&#123;&#125;"&gt;&#123;&#125;&lt;/file&gt;\n"""</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">_loadRes</span><span class="params">(res, root)</span>:</span></div><div class="line">    <span class="comment"># res文件夹的路径</span></div><div class="line">    package = os.path.dirname(res)</div><div class="line">    <span class="comment"># 生成资源清单数据</span></div><div class="line">    res_files = []</div><div class="line">    <span class="keyword">for</span> a, _, files <span class="keyword">in</span> os.walk(res):</div><div class="line">        <span class="keyword">for</span> f <span class="keyword">in</span> files:</div><div class="line">            <span class="keyword">if</span> f == <span class="string">"res.qrc"</span> <span class="keyword">or</span> f.endswith(<span class="string">".ts"</span>):</div><div class="line">                <span class="keyword">continue</span></div><div class="line">            ff = os.path.join(a, f)</div><div class="line">            res_files.append((os.path.getmtime(ff), os.path.relpath(</div><div class="line">                ff, res).replace(os.path.sep, <span class="string">"/"</span>)))</div><div class="line"></div><div class="line">    res_qrc_data = RCC.format(</div><div class="line">        os.path.relpath(package, root).replace(os.path.sep, <span class="string">"/"</span>),</div><div class="line">        <span class="string">""</span>.join([FILE.format(*x) <span class="keyword">for</span> x <span class="keyword">in</span> res_files]))</div><div class="line"></div><div class="line">    <span class="comment"># 更新资源清单</span></div><div class="line">    res_qrc = os.path.join(res, <span class="string">"res.qrc"</span>)</div><div class="line">    res_updated = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="comment"># 检查现有资源清单是否已是最新</span></div><div class="line">    <span class="keyword">if</span> os.path.exists(res_qrc):</div><div class="line">        <span class="keyword">with</span> open(res_qrc, <span class="string">"r"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</div><div class="line">            res_updated = f.read() == res_qrc_data</div><div class="line"></div><div class="line">    <span class="comment"># 更新资源清单</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> res_updated:</div><div class="line">        <span class="keyword">with</span> open(res_qrc, <span class="string">"w"</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(res_qrc_data)</div><div class="line"></div><div class="line">    <span class="comment"># 编译资源清单</span></div><div class="line">    res_rc_py = os.path.join(package, <span class="string">"res_rc.py"</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(res_rc_py) <span class="keyword">or</span> \</div><div class="line">            os.path.getmtime(res_rc_py) &lt; os.path.getmtime(res_qrc):</div><div class="line">        <span class="comment"># 通过指定 `cwd` 解决 win32 下 pyrcc5 不支持中文路径的问题</span></div><div class="line">        rel_res_rc_py = os.path.relpath(res_rc_py, package)</div><div class="line">        rel_res_qrc = os.path.relpath(res_qrc, package)</div><div class="line"></div><div class="line">        subprocess.check_call(</div><div class="line">            [<span class="string">"pyrcc5"</span>, <span class="string">"-o"</span>, rel_res_rc_py, rel_res_qrc], cwd=package)</div><div class="line"></div><div class="line"><span class="comment"># 加载资源</span></div><div class="line"><span class="keyword">for</span> path, b, c <span class="keyword">in</span> os.walk(_res_path):</div><div class="line">    <span class="keyword">if</span> path.endswith(os.path.sep + <span class="string">"res"</span>):</div><div class="line">        _loadRes(path, _res_path)</div></pre></td></tr></table></figure></p><p>有了<code>res_rc.py</code>文件,然后将<code>res_rc.py</code>文件import进来,然后让问资源文件通过指定路径访问.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore</div><div class="line"></div><div class="line"><span class="keyword">import</span> res_rc</div><div class="line"><span class="comment"># :不能少, 路径就是qrc里的prefix+资源文件名</span></div><div class="line">pixmap = QPixamp(<span class="string">":/prefix/download.jpeg"</span>)</div></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">loadUi</span><span class="params">(widget, uiFileName)</span>:</span></div><div class="line">    <span class="string">"""加载 ui. 从 uiFileName 指定的 ui 文件加载."""</span></div><div class="line">    f = QtCore.QFile(uiFileName)</div><div class="line">    f.open(QtCore.QFile.ReadOnly | QtCore.QFile.Text)</div><div class="line">    <span class="keyword">assert</span> f.isOpen()</div><div class="line">    ts = QtCore.QTextStream(f)</div><div class="line">    ts.setCodec(<span class="string">"utf-8"</span>)</div><div class="line">    code_string = io.StringIO()</div><div class="line">    winfo = uic.compiler.UICompiler().compileUi(ts, code_string, <span class="keyword">True</span>, <span class="string">"_rc"</span>)</div><div class="line">    ui_globals = &#123;<span class="string">"__name__"</span>: widget.__module__&#125;</div><div class="line">    exec(code_string.getvalue(), ui_globals)</div><div class="line">    Ui = ui_globals[winfo[<span class="string">"uiclass"</span>]]</div><div class="line">    ui = Ui()</div><div class="line">    ui.setupUi(widget)</div><div class="line">    <span class="keyword">return</span> ui</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span><span class="params">(QDialog, serialDlg)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        super(MainWindow, self).__init__()</div><div class="line">        self.ui = loadUi(self, <span class="string">":../serialCom.ui"</span>)</div></pre></td></tr></table></figure></p><p>然后所有ui里的控件对象都可以使用self.ui来访问了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;一般界面的创建有两种方式:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用纯代码实现&lt;/li&gt;
&lt;li&gt;使用designer来拖拽控件&lt;br&gt;两种方式各有各
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="PyQt5" scheme="http://arvin-he.github.io/tags/PyQt5/"/>
    
  </entry>
  
</feed>
