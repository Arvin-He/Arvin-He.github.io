<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simple &amp; Freedom</title>
  
  <subtitle>Learn and live.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arvin-he.github.io/"/>
  <updated>2017-12-08T01:08:46.319Z</updated>
  <id>http://arvin-he.github.io/</id>
  
  <author>
    <name>Arvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>javascript 标准对象</title>
    <link href="http://arvin-he.github.io/2017/12/08/js-object-2017-12-08/"/>
    <id>http://arvin-he.github.io/2017/12/08/js-object-2017-12-08/</id>
    <published>2017-12-08T01:04:29.000Z</published>
    <updated>2017-12-08T01:08:46.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="javascript标准对象"><a href="#javascript标准对象" class="headerlink" title="javascript标准对象"></a>javascript标准对象</h3><ol><li>不要使用new Number()、new Boolean()、new String()创建包装对象；</li><li>用parseInt()或parseFloat()来转换任意类型到number；</li><li>用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；</li><li>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</li><li>typeof操作符可以判断出number、boolean、string、function和undefined；</li><li>判断Array要使用Array.isArray(arr)；</li><li>判断null请使用myVar === null；</li><li>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</li><li>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</li><li>不是任何对象都有toString()方法, null和undefined就没有！这两个特殊值要除外，虽然null还伪装成了object类型。</li><li>number对象调用toString()需要特殊处理,<code>123..toString(); // &#39;123&#39;, 注意是两个点！</code> 或 <code>(123).toString(); // &#39;123&#39;</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;javascript标准对象&quot;&gt;&lt;a href=&quot;#javascript标准对象&quot; class=&quot;headerlink&quot; title=&quot;javascript标准对象&quot;&gt;&lt;/a&gt;javascript标准对象&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;不要使用new Number()
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>selenium笔记</title>
    <link href="http://arvin-he.github.io/2017/12/07/selenium-notes1-2017-12-07/"/>
    <id>http://arvin-he.github.io/2017/12/07/selenium-notes1-2017-12-07/</id>
    <published>2017-12-07T13:39:06.000Z</published>
    <updated>2017-12-08T01:03:55.173Z</updated>
    
    <content type="html"><![CDATA[<h3 id="selenium使用"><a href="#selenium使用" class="headerlink" title="selenium使用"></a>selenium使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line">driver = webdriver.Firefox()</div><div class="line">driver.get(<span class="string">"http://www.python.org"</span>)</div><div class="line"><span class="keyword">assert</span> <span class="string">"Python"</span> <span class="keyword">in</span> driver.title</div><div class="line">elem = driver.find_element_by_name(<span class="string">"q"</span>)</div><div class="line">elem.send_keys(<span class="string">"pycon"</span>)</div><div class="line">elem.send_keys(Keys.RETURN)</div><div class="line"><span class="keyword">assert</span> <span class="string">"No results found."</span> <span class="keyword">not</span> <span class="keyword">in</span> driver.page_source</div><div class="line">driver.close()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;selenium使用&quot;&gt;&lt;a href=&quot;#selenium使用&quot; class=&quot;headerlink&quot; title=&quot;selenium使用&quot;&gt;&lt;/a&gt;selenium使用&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>javascript笔记(二)</title>
    <link href="http://arvin-he.github.io/2017/12/04/js-notes2-2017-12-04/"/>
    <id>http://arvin-he.github.io/2017/12/04/js-notes2-2017-12-04/</id>
    <published>2017-12-04T01:34:52.000Z</published>
    <updated>2017-12-05T00:58:41.578Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ol><li>局部作用域<br>var 声明局部变量,生命周期在函数内部. 而JavaScript的变量作用域实际上是函数内部，以及变量提升的作用,<br>我们在for循环等语句块中是无法定义具有局部作用域的变量的：<br>为了解决块级作用域，(如for循环), ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：</li></ol><ol><li>全局作用域<br>不在任何函数内定义的变量就具有全局作用域。<br>JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的course属性.<br>以变量方式<code>var foo = function () {}</code>定义的函数实际上也是一个全局变量，<br>因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象.<br>JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。</li></ol><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。<br>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个自定义的全局变量中.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></div><div class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</div><div class="line"><span class="comment">// 其他变量:</span></div><div class="line">MYAPP.name = <span class="string">'myapp'</span>;</div><div class="line">MYAPP.version = <span class="number">1.0</span>;</div><div class="line"><span class="comment">// 其他函数:</span></div><div class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示这是一个常量，不要修改它的值：<br>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。<br>解构赋值在很多时候可以大大简化代码. 但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行<br><strong>注意:</strong></p><ol><li>对数组元素进行解构赋值时，多个变量要用[]括起来。</li><li>如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致</li><li>如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性</li><li>对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的</li><li>使用解构赋值对对象属性进行赋值时，如果要使用的变量名和属性名不一致，可以用下面的语法获取</li><li>解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题</li><li>如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误, 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>];</div><div class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">'hello'</span>, [<span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]];</div><div class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</div><div class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</div><div class="line"><span class="comment">// 把passport属性赋值给变量id:</span></div><div class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person;</div><div class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></div><div class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</div><div class="line"><span class="keyword">var</span> x, y;</div><div class="line"><span class="comment">// 解构赋值:</span></div><div class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;; <span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></div><div class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;); <span class="comment">//正确</span></div></pre></td></tr></table></figure></li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个this怎么理解？<br>在一个方法内部，this是一个特殊变量，它始终指向当前的调用对象.<br>JavaScript的函数内部如果调用了this，那么这个this到底指向谁？<br>答案是，视情况而定,根据当前调用者来确定. 且必须保证this指向正确，必须用obj.xxx()的形式调用！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></div><div class="line">fn(); <span class="comment">// NaN</span></div><div class="line"></div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> fn = xiaoming.age;</div><div class="line">fn(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></div></pre></td></tr></table></figure></p><p>这是一个设计错误，ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误.<br>这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。<br>修复的办法:用一个that变量首先捕获this,用<code>var that = this;</code>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p><p>另一个解决办法:apply<br>指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数:<br>第一个参数就是需要绑定的this变量，<br>第二个参数是Array，表示函数本身的参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    age: getAge</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); <span class="comment">// 25</span></div><div class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure></p><p>另一个与apply()类似的方法是call()，唯一区别是：<br>apply()把参数打包成Array再传入；<br>call()把参数按顺序传入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p><p>对普通函数调用，我们通常把this绑定为null。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量作用域&quot;&gt;&lt;a href=&quot;#变量作用域&quot; class=&quot;headerlink&quot; title=&quot;变量作用域&quot;&gt;&lt;/a&gt;变量作用域&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;局部作用域&lt;br&gt;var 声明局部变量,生命周期在函数内部. 而JavaScript的变量作用域实际上是
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>proxy一些知识</title>
    <link href="http://arvin-he.github.io/2017/11/28/proxy-2017-11-28/"/>
    <id>http://arvin-he.github.io/2017/11/28/proxy-2017-11-28/</id>
    <published>2017-11-28T14:04:44.000Z</published>
    <updated>2017-11-29T01:09:30.919Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理有什么用处"><a href="#代理有什么用处" class="headerlink" title="代理有什么用处"></a>代理有什么用处</h3><ul><li>对游戏，通过第三方代理，可以提高游戏流畅速度</li><li>对师生，通过代理访问国外论文，获取最新研究成果</li><li>对开发者，通过代理爬取采集大数据，防止被屏蔽</li><li>对极客，通过代理(高匿)隐藏访问痕迹，防止被跟踪</li><li>对个人，通过代理自由上网保护隐私，了解外面的世界</li></ul><h3 id="代理应具有哪些信息"><a href="#代理应具有哪些信息" class="headerlink" title="代理应具有哪些信息"></a>代理应具有哪些信息</h3><ul><li>IP：Port（IP和端口号，默认必选）</li><li>类型（协议类型，HTTP/HTTPS/Socks4/Socks5，默认必选）</li><li>国家（例如：中国/美国/日本等）</li><li>响应时间（ping代理服务器的时间，单位秒）</li><li>传输速度（数据请求和返回的时间，单位秒）</li><li>验证日期（验证代理可用的时间）</li><li>检测成功率（成功率 = 代理检测的可用次数 / 检测总数，衡量代理的可靠性）</li></ul><h3 id="什么是代理的类型"><a href="#什么是代理的类型" class="headerlink" title="什么是代理的类型"></a>什么是代理的类型</h3><p>代理的类型，具体是指代理协议类型，常见的有HTTP、HTTPS、Socks4、Socks5等四种协议类型</p><ul><li>HTTP，全称超文本传输协议（HyperText Transfer Protocol)，是互联网数据传输的一种协议；</li><li>HTTPS，是在HTTP协议基础上加入了SSL加密协议，以https开头，确保传输过程的数据安全；</li><li>Socks4，是全能代理，支持HTTP，FTP等多种协议请求，传输层只支持UDP协议，数据可能会丢失；</li><li>Socks5，类似于Socks4，差别是传输层同时支持UDP和TCP协议，支持可靠的身份验证等机制。<br>Socks4和Socks5，都是通过代理IP:Port利用底层传输协议进行网络通信，因此都可视为匿名代理。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>HTTP：适合一般的网页浏览，例如：浏览新闻，观看视频等；</li><li>HTTPS：适合一些需要安全验证的场合，例如：网银登录，购物付款等；</li><li>Socks4：适合一些对数据完整性不高的场合，例如：网络电话，视频聊天等；</li><li>Socks5：适合对数据完整性较高的场合，例如：网络游戏，微信接入，移动支付等。</li></ul><h3 id="HTTP和Socks代理有何区别？"><a href="#HTTP和Socks代理有何区别？" class="headerlink" title="HTTP和Socks代理有何区别？"></a>HTTP和Socks代理有何区别？</h3><p>HTTP和HTTPS，都是基于可靠的TCP/IP协议，对传输数据都有校验，保障数据不丢失。<br>Socks4和Socks5，分别是基于UDP，UDP和TCP传输协议，通过代理IP:Port请求转发数据。<br>HTTP和HTTPS是在Socks基础上，进行了数据封装，只专注业务，不必考虑底层的数据传输。<br>Socks是基于IP:Port套接字进行底层的数据传输，支持多种HTTP、FTP、ICMP等上层协议。<br>适用场景：对于普通用户，一般使用HTTP/HTTPS即可；对于开发者用户，推荐Socks，如微信开发。</p><h3 id="什么是代理的匿名度"><a href="#什么是代理的匿名度" class="headerlink" title="什么是代理的匿名度"></a>什么是代理的匿名度</h3><p>代理的匿名度，一般分为透明，匿名，高匿，其中匿名又分为普通匿名和欺骗匿名。</p><ul><li>透明，代理服务器只是转发请求，并把你的真实IP地址传给服务器，不会隐藏或改变你的IP；</li><li>普通匿名，代理服务器转发请求，并把代理服务器的IP地址传给服务器，隐藏了你的真实IP；</li><li>欺骗匿名，代理服务器转发请求，并编造了一个假的IP地址传给服务器，隐藏了你的真实IP；</li><li>高匿，代理服务器转发请求，并完全隐藏了你的真实IP和其它信息，就像另外一个人在访问。</li></ul><p>代理匿名度优先级： 高匿 &gt; 欺骗代理 &gt; 普通匿名 &gt; 透明 &gt; 不使用代理</p><p>如果不使用代理，你的请求数据，真实IP地址，以及其它信息（如浏览器参数，cookie等），都会毫无保留的暴露给了远程服务器，<br>他人可以利用这些访问痕迹，跟踪你的位置（如城市/地区/街道），以及盗取你请求数据中的敏感信息（如银行卡帐号和密码，QQ号和密码等），以及你的访问喜好和习惯等个人隐私。</p><p>使用代理(高匿)和加密协议(HTTPS)，可以大大提高您访问网络的安全性，有效保护您的个人隐私等敏感信息</p><h3 id="高匿、匿名和透明有何区别？"><a href="#高匿、匿名和透明有何区别？" class="headerlink" title="高匿、匿名和透明有何区别？"></a>高匿、匿名和透明有何区别？</h3><p>高匿，匿名和透明，是针对隐藏用户请求数据而言，例如：隐藏IP地址，隐藏浏览器参数，Cookie等<br>对于一般的访问网络，一共有五种方式：无代理、透明、普通匿名、欺骗匿名、高匿（Elite）<br>五种方式及判断原理如下：</p><ol><li><p>无代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 您的真实IP</div><div class="line">HTTP_VIA = 没数值或不显示</div><div class="line">HTTP_X_FORWARDED_FOR = 没数值或不显示</div></pre></td></tr></table></figure></li><li><p>透明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 最后一个代理服务器IP</div><div class="line">HTTP_VIA = 代理服务器IP</div><div class="line">HTTP_X_FORWARDED_FOR = 您的真实IP，经过多个代理服务器时，这个值类似：123.57.78.101, 120.24.177.48, 47.88.76.11</div></pre></td></tr></table></figure></li><li><p>普通匿名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 最后一个代理服务器IP</div><div class="line">HTTP_VIA = 代理服务器IP</div><div class="line">HTTP_X_FORWARDED_FOR = 代理服务器IP，经过多个代理服务器时，这个值类似：123.57.78.101, 120.24.177.48, 47.88.76.11</div></pre></td></tr></table></figure></li><li><p>欺骗匿名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 最后一个代理服务器IP</div><div class="line">HTTP_VIA = 代理服务器IP</div><div class="line">HTTP_X_FORWARDED_FOR = 随机的IP，经过多个代理服务器时，这个值类似：123.57.78.101, 120.24.177.48, 47.88.76.11</div></pre></td></tr></table></figure></li><li><p>高匿(Elite)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 代理服务器IP</div><div class="line">HTTP_VIA = 没数值或不显示</div><div class="line">HTTP_X_FORWARDED_FOR = 没数值或不显示</div></pre></td></tr></table></figure></li></ol><h3 id="代理的国家-地区"><a href="#代理的国家-地区" class="headerlink" title="代理的国家/地区"></a>代理的国家/地区</h3><p>代理的国家，具体是指代理IP所属的国家，例如：中国，美国，英国，日本，韩国，俄罗斯等<br>代理的地区，具体是指代理IP所属国家的地区，只支持中国34个省市(含港澳台)，例如：中国北京，中国香港</p><h3 id="代理的运营商"><a href="#代理的运营商" class="headerlink" title="代理的运营商"></a>代理的运营商</h3><p>代理的运营商，具体是指提供代理服务器的运营商，因为大部分的的代理IP，是由电信运营商搭建提供。<br>代理的运营商，主要有移动、铁通、联通、网通、电信，以及其它（主要是一些大公司和港澳台电信运营商，例如：阿里巴巴、中华电信、腾讯集团、鹏博士、教育网等）</p><h3 id="代理的响应时间"><a href="#代理的响应时间" class="headerlink" title="代理的响应时间"></a>代理的响应时间</h3><p>代理的响应时间，具体是指代理检测服务器Ping通代理服务器的时间。<br>Ping命令的原理，是发送一个ICMP(因特网控制报文协议)给远程服务器，并回声收到目标ICMP的应答时间。<br>如: 米扑代理的响应时间，分为五个等级，从低到高依次为： 0 ~ 0.1 ~ 0.3 ~ 1 ~ 5 ~ 9，单位秒</p><h3 id="代理的传输速度"><a href="#代理的传输速度" class="headerlink" title="代理的传输速度"></a>代理的传输速度</h3><p>代理的传输速度，具体是指代理检测服务器发送请求到目标服务器并返回数据到本地的总时间。<br>总时间，包括本地发送请求 -&gt; 代理服务器 -&gt; 目标服务器 -&gt; 返回数据到代理服务器 -&gt; 本地的全部时间。<br>如: 米扑代理的传输速度，分为五个等级，从低到高依次为： 0 ~ 0.3 ~ 1 ~ 5 ~ 10 ~ 30，单位秒。</p><h3 id="代理的验证日期"><a href="#代理的验证日期" class="headerlink" title="代理的验证日期"></a>代理的验证日期</h3><p>代理的验证日期，具体是指检测代理可用的最后时间，<br>必须满足:<br>1）代理可用；<br>2）检测为可用的最后时间。<br>例如：代理 100.12.25.10:8080 可用，最后一次检测日期为 2015-05-20 10:12:56，即为验证日期。</p><h3 id="提取的代理都可以用吗？"><a href="#提取的代理都可以用吗？" class="headerlink" title="提取的代理都可以用吗？"></a>提取的代理都可以用吗？</h3><p>代理的实效性很强，当时提取的可用代理可能一会儿就失效了，因此检测代理的最后验证日期，非常重要！</p><h3 id="如何获取高可靠的代理？"><a href="#如何获取高可靠的代理？" class="headerlink" title="如何获取高可靠的代理？"></a>如何获取高可靠的代理？</h3><p>高可靠代理，计算公式：代理的检测可用次数 / 总检测次数 = 可靠率，如:米扑代理独创的检测技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代理有什么用处&quot;&gt;&lt;a href=&quot;#代理有什么用处&quot; class=&quot;headerlink&quot; title=&quot;代理有什么用处&quot;&gt;&lt;/a&gt;代理有什么用处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对游戏，通过第三方代理，可以提高游戏流畅速度&lt;/li&gt;
&lt;li&gt;对师生，通过代理访问国外
      
    
    </summary>
    
      <category term="web" scheme="http://arvin-he.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://arvin-he.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记</title>
    <link href="http://arvin-he.github.io/2017/11/25/redis-note1-2017-11-25/"/>
    <id>http://arvin-he.github.io/2017/11/25/redis-note1-2017-11-25/</id>
    <published>2017-11-25T13:45:48.000Z</published>
    <updated>2017-11-27T01:06:11.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis下载与安装"><a href="#redis下载与安装" class="headerlink" title="redis下载与安装"></a>redis下载与安装</h3><ol><li><p>windows下redis下载地址:<br><img src="https://github.com/MicrosoftArchive/redis/releases" alt="https://github.com/MicrosoftArchive/redis/releases"></p></li><li><p>下载zip版本,在C盘根目录下(或者你想安装的目录下)解压</p></li><li><p>添加redis环境变量</p></li><li><p>注册redis服务<br><code>redis-server.exe --service-install redis.windows.conf --loglevel verbose</code></p></li><li><p>启动redis服务<br><code>redis-server.exe --service-start</code></p></li><li><p>下载redis可视化客户端软件RedisDesktopManager</p></li></ol><p>下载地址:<br><img src="https://redisdesktop.com/download" alt="https://redisdesktop.com/download"></p><h3 id="python下安装redis绑定包"><a href="#python下安装redis绑定包" class="headerlink" title="python下安装redis绑定包"></a>python下安装redis绑定包</h3><p><code>pip install redis</code></p><h3 id="redis-mongodb与memcache对比"><a href="#redis-mongodb与memcache对比" class="headerlink" title="redis, mongodb与memcache对比"></a>redis, mongodb与memcache对比</h3><p>mongodb 直接持久化<br>redis 半持久化<br>memcache 只能在内存，轻量级缓存</p><h3 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h3><p>redis是一个key-value存储系统。和Memcached类似,支持的类型操作有: String操作, Hash操作, List操作, Set操作, Sort Set操作(zset)<br>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的.<br>redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。<br>区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><h3 id="python操作redis"><a href="#python操作redis" class="headerlink" title="python操作redis"></a>python操作redis</h3><p>edis-py提供两个类Redis和StrictRedis用于实现Redis的命令，<br>StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，<br>Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。</p><p>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。<br>默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">r = redis.Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</div><div class="line">r.set(<span class="string">'foo'</span>, <span class="string">'Bar'</span>)</div><div class="line"><span class="keyword">print</span> (r.get(<span class="string">'foo'</span>))</div><div class="line"><span class="comment"># 使用连接池</span></div><div class="line">pool = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</div><div class="line">r = redis.Redis(connection_pool=pool)</div><div class="line">r.set(<span class="string">'foo'</span>, <span class="string">'Bar'</span>)</div><div class="line"><span class="keyword">print</span> r.get(<span class="string">'foo'</span>)</div></pre></td></tr></table></figure></p><h3 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h3><p>set(name, value, ex=None, px=None, nx=False, xx=False)<br>setnx 、 setex 、 psetex<br>在Redis中设置值，默认，不存在则创建，存在则修改<br>参数：<br>     ex，过期时间（秒）<br>     px，过期时间（毫秒）<br>     nx，如果设置为True，则只有name不存在时，当前set操作才执行<br>     xx，如果设置为True，则只有name存在时，当前set操作才执行</p><p>批量设置<br>mset(<em>args, **kwargs)<br>批量获取<br>mget(keys, </em>args)<br>设置新值并获取原来的值<br>getset(name, value)<br>获取子序列（根据字节获取，非字符）<br>getrange(key, start, end)<br>修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）<br>setrange(name, offset, value)<br>对name对应值的二进制进行位操作。<br>setbit(name, offset, value)<br>获取name对应的值的二进制表示中 1 的个数,应用场景:统计在线用户数有多少<br>bitcount(key, start=None, end=None)<br>自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。<br>incr(self, name, amount=1)<br>incrbyfloat(self, name, amount=1.0)<br>自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。<br>decr(self, name, amount=1)<br>在redis name对应的值后面追加内容<br>append(key, value)</p><h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><p>Hash操作，redis中Hash在内存中的存储格式如下图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">name                hash</div><div class="line">               |````````````|</div><div class="line">n1   --------&gt; | k1 --&gt; v1  |</div><div class="line">               | k2 --&gt; v2  |</div><div class="line">               |____________|</div><div class="line">               |````````````|</div><div class="line">n2   --------&gt; | k7 --&gt; v7  |</div><div class="line">               |____________|</div></pre></td></tr></table></figure></p><p>name对应的hash中设置一个键值对（不存在，则创建；否则，修改）<br>hset(name, key, value)<br>在name对应的hash中批量设置键值对<br>hmset(name, mapping)<br>在name对应的hash中获取多个key的值<br>hmget(name, keys, <em>args)<br>获取name对应的hash中键值对的个数<br>hlen(name)<br>检查name对应的hash是否存在当前传入的key<br>hexists(name, key)<br>将name对应的hash中指定key的键值对删除<br>hdel(name,</em>keys)<br>自增name对应的hash中的指定key的值，不存在则创建key=amount<br>hincrby(name, key, amount=1)<br>hincrbyfloat(name, key, amount=1.0)<br>过滤,增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆<br>hscan(name, cursor=0, match=None, count=None)<br>利用yield封装hscan创建生成器，实现分批去redis中获取数据<br>hscan_iter(name, match=None, count=None)</p><h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><p>lpush, lrange, rpush, lpushx, llen, linsert, lset, lrem, lpop, lindex, ltrim, rpoplpush, blpop, brpoplpush</p><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>sadd, scard, sdiff, sdiffstore, sinter, sinterstore, sismenber, smove, spop, srandmenber, srem, sunion, sunionstore</p><h3 id="有序集合-zset"><a href="#有序集合-zset" class="headerlink" title="有序集合(zset)"></a>有序集合(zset)</h3><p>zadd, zcount, zincrby, zrank, zrem, zremrangebyrank, zremrankbyscore, zremrangebylex, zscore, zinterstore, zunionstore</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">zunionstore(dest, keys, aggregate=None)</div><div class="line"># 获取两个有序集合的并集</div><div class="line"># aggregate的值为:  SUM  MIN  MAX</div></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">del(*names)</div><div class="line"># 根据删除redis中的任意数据类型</div><div class="line"></div><div class="line">exists(name)</div><div class="line"># 检测redis的name是否存在</div><div class="line"></div><div class="line">keys(pattern=&apos;*&apos;)</div><div class="line"># 根据模型获取redis的name</div><div class="line"># 更多：</div><div class="line">    # KEYS * 匹配数据库中所有 key 。</div><div class="line">    # KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</div><div class="line">    # KEYS h*llo 匹配 hllo 和 heeeeello 等。</div><div class="line">    # KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo</div><div class="line"></div><div class="line">expire(name ,time)</div><div class="line"># 为某个redis的某个name设置超时时间</div><div class="line"></div><div class="line">rename(src, dst)</div><div class="line"># 对redis的name重命名</div><div class="line"></div><div class="line">move(name, db))</div><div class="line"># 将redis的某个值移动到指定的db下，若有则不移动</div><div class="line"></div><div class="line">select db_name</div><div class="line"># 切换到其他db，redis有16个db</div><div class="line"></div><div class="line">randomkey()</div><div class="line"># 随机获取一个redis的name（不删除）</div><div class="line"></div><div class="line">type(name)</div><div class="line"># 获取name对应值的类型</div><div class="line"></div><div class="line">scan(cursor=0, match=None, count=None)</div><div class="line">scan_iter(match=None, count=None)</div><div class="line"># 同字符串操作，用于增量迭代获取key</div></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，<br>如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import redis</div><div class="line">import time</div><div class="line"></div><div class="line">pool = redis.ConnectionPool(host=&apos;10.211.55.4&apos;, port=6379, db=5)</div><div class="line">r = redis.Redis(connection_pool=pool)</div><div class="line"># pipe = r.pipeline(transaction=False)</div><div class="line">pipe = r.pipeline(transaction=True)</div><div class="line"></div><div class="line">pipe.set(&apos;name&apos;, &apos;alex&apos;)</div><div class="line">time.sleep(60)</div><div class="line">pipe.set(&apos;role&apos;, &apos;sb&apos;)</div><div class="line"></div><div class="line">pipe.execute()</div></pre></td></tr></table></figure><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>收音机举例发布订阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import redis</div><div class="line"></div><div class="line">class RedisHelper:</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.__conn = redis.Redis(host=&apos;10.211.55.4&apos;)</div><div class="line">        self.chan_sub = &apos;fm104.5&apos;</div><div class="line">        self.chan_pub = &apos;fm104.5&apos;</div><div class="line"></div><div class="line">    def public(self, msg):</div><div class="line">        self.__conn.publish(self.chan_pub, msg)</div><div class="line">        return True</div><div class="line"></div><div class="line">    def subscribe(self):</div><div class="line">        pub = self.__conn.pubsub()  # 打开收音机</div><div class="line">        pub.subscribe(self.chan_sub) # 调频道</div><div class="line">        pub.parse_response()  # 准备接收</div><div class="line">        return pub</div></pre></td></tr></table></figure></p><p>订阅方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from RedisHelper import RedisHelper</div><div class="line"></div><div class="line">obj = RedisHelper()</div><div class="line">redis_sub = obj.subscribe()</div><div class="line"></div><div class="line">while True:</div><div class="line">    msg= redis_sub.parse_response()</div><div class="line">    print (msg)</div></pre></td></tr></table></figure></p><p>发布方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from RedisHelper import RedisHelper</div><div class="line"></div><div class="line">obj = RedisHelper()</div><div class="line">obj.public(&apos;hello&apos;)</div></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><img src="http://blog.csdn.net/fgf00/article/details/52917154" alt="http://blog.csdn.net/fgf00/article/details/52917154"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis下载与安装&quot;&gt;&lt;a href=&quot;#redis下载与安装&quot; class=&quot;headerlink&quot; title=&quot;redis下载与安装&quot;&gt;&lt;/a&gt;redis下载与安装&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;windows下redis下载地址:&lt;br&gt;&lt;img sr
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://arvin-he.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>tornado学习笔记(二)</title>
    <link href="http://arvin-he.github.io/2017/11/16/tornado-note2-2017-11-16/"/>
    <id>http://arvin-he.github.io/2017/11/16/tornado-note2-2017-11-16/</id>
    <published>2017-11-16T13:40:47.000Z</published>
    <updated>2017-11-27T01:06:11.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h3><p>ornado 所谓的异步：就是你调用我之后，我发现数据没准备好，那我就不处理，而是跳到程序的其他地方继续执行，等数据准备好之后再切回来继续执行。Tornado 的 IOLoop 就是一个总调度器，汇总了所有的 events 和 callbacks，然后同步执行。这会整体生提升性能，但不会降低单个请求的响应时间。</p><h2 id="一些接口说明"><a href="#一些接口说明" class="headerlink" title="一些接口说明"></a>一些接口说明</h2><h3 id="tornado-web-asynchronous"><a href="#tornado-web-asynchronous" class="headerlink" title="tornado.web.asynchronous"></a>tornado.web.asynchronous</h3><p>其中 tornado.web.asynchronous 装饰器很简单，就是设置 <code>self._auto_finish = False</code>，<br>这样当 AsyncHandler.get() 执行完之后，connection socket 不会被 close，需要主动调用 self.finish()。<br>在保持连接不关闭的情况下，把控制权让出去，等数据就绪之后再切回来，使异步实现成为可能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line"><span class="meta">    @tornado.web.asynchronous</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        http_client = AsyncHTTPClient()</div><div class="line">        http_client.fetch(<span class="string">"http://example.com"</span>,</div><div class="line">                          callback=self.on_fetch)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_fetch</span><span class="params">(self, response)</span>:</span></div><div class="line">        self.write(<span class="string">"Downloaded!"</span>)</div><div class="line">        self.finish()</div></pre></td></tr></table></figure></p><h3 id="SimpleAsyncHTTPClient"><a href="#SimpleAsyncHTTPClient" class="headerlink" title="SimpleAsyncHTTPClient"></a>SimpleAsyncHTTPClient</h3><p>AsyncHTTPClient 的处理流程，简单概括就是：与 HTTP Server 建立连接，等拿到 response 后再来调用回调函数 on_fetch。首先通过创建非阻塞的 socket 连接，然后放入到 ioloop 中，当数据可写/可读之后再接着处理。</p><h3 id="gen-engine-的实现："><a href="#gen-engine-的实现：" class="headerlink" title="gen.engine 的实现："></a>gen.engine 的实现：</h3><p>gen.engine 的作用就是把异步中 callback 的写法通过 yield 替代。<br>以下的代码分析都是基于 Tornado 3.0。<br>tornado.ioloop.IOLoop.current() 创建一个ioloop实例</p><p>###IOLoop 为何没有 <code>__init__</code>函数<br>其实是因为要初始化成为单例，IOLoop 的 new 函数已经被改写了，同时指定了 initialize 做为它的初始化方法，所以没有 <code>__init__</code> 。 </p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future在tornado中是一个很奇妙的对象，它是一个穿梭于协程和调度器之间的信使。提供了回调函数注册(当异步事件完成后，调用注册的回调)、中间结果保存、嵌套协程唤醒父协程(通过Runner实现)等功能。Coroutine和Future是一一对应的，可以从上节gen.coroutine装饰器的实现中看到。每调用一个协程，表达式所返回的就是一个Future对象，它所表达的意义为：这个协程的内部各种异步逻辑执行完毕后，会把结果保存在这个Future中，同时调用这个Future中指定的回调函数，而future中的回调函数是什么时候被注册的呢？那就是当前——你通过调用协程，返回了这个future对象的时候：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一些说明&quot;&gt;&lt;a href=&quot;#一些说明&quot; class=&quot;headerlink&quot; title=&quot;一些说明&quot;&gt;&lt;/a&gt;一些说明&lt;/h3&gt;&lt;p&gt;ornado 所谓的异步：就是你调用我之后，我发现数据没准备好，那我就不处理，而是跳到程序的其他地方继续执行，等数据准备好之
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="tornado" scheme="http://arvin-he.github.io/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>如何去阅读源码</title>
    <link href="http://arvin-he.github.io/2017/11/16/howtoreadsource-2017-11-16/"/>
    <id>http://arvin-he.github.io/2017/11/16/howtoreadsource-2017-11-16/</id>
    <published>2017-11-16T13:34:20.000Z</published>
    <updated>2017-11-27T01:06:11.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阅读源码的方法"><a href="#阅读源码的方法" class="headerlink" title="阅读源码的方法"></a>阅读源码的方法</h3><p>源码分析的时候，一定要有层级和模块的概念，任何一个系统都可以被认为是许多个层级或者模块通过向外界暴露接口或者调用其他层级模块接口的方式连接在一起。所以没有必要上来就把每一个细节的实现搞明白，这是低效不科学的方法。正确的方法是首先从宏观上对整体框架有一个认识，划分出层级和模块，然后再具体把每一个模块搞透彻。</p><h3 id="学习新框架的方法"><a href="#学习新框架的方法" class="headerlink" title="学习新框架的方法"></a>学习新框架的方法</h3><p>学一个新的框架，文档先浏览一下，然后就是照着教程的例子运行，接着弄懂例子的运行原理（看源码）。抓住在使用框架过程中遇到的问题，并以那个问题为切入点深入分析，这样一方面能解决问题；另一方面能借机对框架有更深入的了解，因为框架内容那么多，也不可能面面俱到，但是至少遇到问题的地方你深挖是有价值的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;阅读源码的方法&quot;&gt;&lt;a href=&quot;#阅读源码的方法&quot; class=&quot;headerlink&quot; title=&quot;阅读源码的方法&quot;&gt;&lt;/a&gt;阅读源码的方法&lt;/h3&gt;&lt;p&gt;源码分析的时候，一定要有层级和模块的概念，任何一个系统都可以被认为是许多个层级或者模块通过向外界暴露
      
    
    </summary>
    
      <category term="思想" scheme="http://arvin-he.github.io/categories/%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="方法" scheme="http://arvin-he.github.io/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>tornado学习笔记(一)</title>
    <link href="http://arvin-he.github.io/2017/11/16/tornado-note1-2017-11-16/"/>
    <id>http://arvin-he.github.io/2017/11/16/tornado-note1-2017-11-16/</id>
    <published>2017-11-16T11:42:00.000Z</published>
    <updated>2017-11-27T01:06:11.175Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>高性能源于Tornado基于Epoll（unix为kqueue）的异步网络IO。因为tornado的单线程机制，一不小心就容易写出阻塞服务（block）的代码。不但没有性能提高，反而会让性能急剧下降。因此，探索tornado的异步使用方式很有必要。<br>tornado虽然以异步非阻塞高性能著称的框架,但默认不是异步非阻塞的,你需要添加两个装饰器@tornado.web.asynchronous和@tornado.gen.coroutine,<br>这样才算是异步非阻塞的.然而当你用tornado作为http服务器,同时用了requests库发送请求后,你会发现请求还是一个一个的处理,根本不是异步非阻塞的.<br>原因是requests库发送请求是阻塞的,它会阻塞整个tornado服务进程,为什么阻塞,原因是用 requests 的话能会 block 其他 http 请求。因为他无法注册到 ioloop 里面。只要这个 requests 请求结束， tornado 才会处理下一个 http 请求。 </p><h3 id="Tornado主要模块"><a href="#Tornado主要模块" class="headerlink" title="Tornado主要模块"></a>Tornado主要模块</h3><p>web - FriendFeed 使用的基础 Web 框架，包含了 Tornado 的大多数重要的功能<br>escape - XHTML, JSON, URL 的编码/解码方法<br>database - 对 MySQLdb 的简单封装，使其更容易使用<br>template - 基于 Python 的 web 模板系统<br>httpclient - 非阻塞式 HTTP 客户端，它被设计用来和 web 及 httpserver 协同工作<br>auth - 第三方认证的实现（包括 Google OpenID/OAuth、Facebook Platform、Yahoo BBAuth、FriendFeed OpenID/OAuth、Twitter OAuth）<br>locale - 针对本地化和翻译的支持<br>options - 命令行和配置文件解析工具，针对服务器环境做了优化</p><p>底层模块<br>httpserver - 服务于 web 模块的一个非常简单的 HTTP 服务器的实现<br>iostream - 对非阻塞式的 socket 的简单封装，以方便常用读写操作<br>ioloop - 核心的 I/O 循环</p><h3 id="Tornado-异步使用方式"><a href="#Tornado-异步使用方式" class="headerlink" title="Tornado 异步使用方式"></a>Tornado 异步使用方式</h3><p>简而言之，Tornado的异步包括两个方面，异步服务端和异步客户端。无论服务端和客户端，具体的异步模型又可以分为回调（callback）和协程（coroutine）。具体应用场景，也没有很明确的界限。往往一个请求服务里还包含对别的服务的客户端异步请求。</p><h3 id="服务端异步方式"><a href="#服务端异步方式" class="headerlink" title="服务端异步方式"></a>服务端异步方式</h3><p>服务端异步，可以理解为一个tornado请求之内，需要做一个耗时的任务。直接写在业务逻辑里可能会block整个服务。因此可以把这个任务放到异步处理，实现异步的方式就有两种，<br>一种是yield挂起函数，另外一种就是使用类线程池的方式。请看一个同步例子：<br>同步代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    <span class="comment"># 耗时的代码</span></div><div class="line">    os.system(<span class="string">"ping -c 2 www.google.com"</span>)</div><div class="line">    self.finish(<span class="string">'It works'</span>)</div></pre></td></tr></table></figure></p><p>测试一下：0.99，姑且当成每秒处理一个请求吧。</p><p>异步代码:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line"></div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    tornado.ioloop.IOLoop.instance().add_timeout(<span class="number">1</span>, callback=functools.partial(self.ping, <span class="string">'www.google.com'</span>))</div><div class="line">    <span class="comment"># do something others</span></div><div class="line">    self.finish(<span class="string">'It works'</span>)</div><div class="line"></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, url)</span>:</span></div><div class="line">    os.system(<span class="string">"ping -c 2 &#123;&#125;"</span>.format(url))</div><div class="line">    <span class="keyword">return</span> <span class="string">'after'</span></div></pre></td></tr></table></figure></p><p>尽管在执行异步任务的时候选择了timeout 1秒，主线程的返回还是很快的。<br>上述的使用方式，通过tornado的IO循环，把可以把耗时的任务放到后台异步计算，请求可以接着做别的计算。<br>可是，经常有一些耗时的任务完成之后，我们需要其计算的结果。此时这种方式就不行了。车道山前必有路，只需要切换一异步方式即可。下面使用协程来改写：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncTaskHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line"></div><div class="line"><span class="meta">    @tornado.web.asynchronous</span></div><div class="line"><span class="meta">    @tornado.gen.coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">        <span class="comment"># yield 结果</span></div><div class="line">        response = <span class="keyword">yield</span> tornado.gen.Task(self.ping, <span class="string">' www.google.com'</span>)</div><div class="line">        <span class="keyword">print</span> <span class="string">'response'</span>, response</div><div class="line">        self.finish(<span class="string">'hello'</span>)</div><div class="line"></div><div class="line"><span class="meta">    @tornado.gen.coroutine</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, url)</span>:</span></div><div class="line">        os.system(<span class="string">"ping -c 2 &#123;&#125;"</span>.format(url))</div><div class="line">        <span class="keyword">return</span> <span class="string">'after'</span></div><div class="line">```    </div><div class="line">可以看到异步在处理，而结果值也被返回了。有时候这种协程处理，未必就比同步快。在并发量很小的情况下，IO本身拉开的差距并不大。甚至协程和同步性能差不多。</div><div class="line"><span class="keyword">yield</span>挂起函数协程，尽管没有block主线程，因为需要处理返回值，挂起到响应执行还是有时间等待，相对于单个请求而言。另外一种使用异步和协程的方式就是在主线程之外，使用线程池，线程池依赖于futures。Python2需要额外安装。</div><div class="line">```python</div><div class="line">下面使用线程池的方式修改为异步处理：</div><div class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FutureHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  executor = ThreadPoolExecutor(<span class="number">10</span>)</div><div class="line"></div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    url = <span class="string">'www.google.com'</span></div><div class="line">    tornado.ioloop.IOLoop.instance().add_callback(functools.partial(self.ping, url))</div><div class="line">    self.finish(<span class="string">'It works'</span>)</div><div class="line"></div><div class="line"><span class="meta">  @tornado.concurrent.run_on_executor</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, url)</span>:</span></div><div class="line">    os.system(<span class="string">"ping -c 2 &#123;&#125;"</span>.format(url))</div><div class="line">```    </div><div class="line">再切换一下使用方式接口。使用tornado的gen模块下的with_timeout功能（这个功能必须在tornado&gt;<span class="number">3.2</span>的版本）。</div><div class="line">```python</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Executor</span><span class="params">(ThreadPoolExecutor)</span>:</span></div><div class="line">  _instance = <span class="keyword">None</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> getattr(cls, <span class="string">'_instance'</span>, <span class="keyword">None</span>):</div><div class="line">      cls._instance = ThreadPoolExecutor(max_workers=<span class="number">10</span>)</div><div class="line">    <span class="keyword">return</span> cls._instance</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FutureResponseHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  executor = Executor()</div><div class="line"></div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    future = Executor().submit(self.ping, <span class="string">'www.google.com'</span>)</div><div class="line">    response = <span class="keyword">yield</span> tornado.gen.with_timeout(datetime.timedelta(<span class="number">10</span>), future,</div><div class="line">                         quiet_exceptions=tornado.gen.TimeoutError)</div><div class="line">    <span class="keyword">if</span> response:</div><div class="line">      <span class="keyword">print</span> <span class="string">'response'</span>, response.result()</div><div class="line"></div><div class="line"><span class="meta">  @tornado.concurrent.run_on_executor</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ping</span><span class="params">(self, url)</span>:</span></div><div class="line">    os.system(<span class="string">"ping -c 1 &#123;&#125;"</span>.format(url))</div><div class="line">    <span class="keyword">return</span> <span class="string">'after'</span></div></pre></td></tr></table></figure></p><p>线程池的方式也可以通过使用tornado的yield把函数挂起，实现了协程处理。可以得出耗时任务的result，同时不会block住主线程。</p><p>###异步多样化<br>Tornado异步服务的处理大抵如此。现在异步处理的框架和库也很多，借助redis或者celery等，也可以把tonrado中一些业务异步化，放到后台执行。<br>此外，Tornado还有客户端异步功能。该特性主要是在于 AsyncHTTPClient的使用。此时的应用场景往往是tornado服务内，需要针对另外的IO进行请求和处理。顺便提及，上述的例子中，调用ping其实也算是一种服务内的IO处理。接下来，将会探索一下AsyncHTTPClient的使用，尤其是使用AsyncHTTPClient上传文件与转发请求。</p><h3 id="异步客户端"><a href="#异步客户端" class="headerlink" title="异步客户端"></a>异步客户端</h3><p>前面了解Tornado的异步任务的常用做法，姑且归结为异步服务。通常在我们的服务内，还需要异步的请求第三方服务。针对HTTP请求，Python的库Requests是最好用的库，没有之一。官网宣称：HTTP for Human。然而，在tornado中直接使用requests将会是一场恶梦。requests的请求会block整个服务进程。<br>上帝关上门的时候，往往回打开一扇窗。Tornado提供了一个基于框架本身的异步HTTP客户端（当然也有同步的客户端）— AsyncHTTPClient。</p><h3 id="AsyncHTTPClient-基本用法"><a href="#AsyncHTTPClient-基本用法" class="headerlink" title="AsyncHTTPClient 基本用法"></a>AsyncHTTPClient 基本用法</h3><p>AsyncHTTPClient是 tornado.httpclinet 提供的一个异步http客户端。使用也比较简单。与服务进程一样，AsyncHTTPClient也可以callback和yield两种使用方式。前者不会返回结果，后者则会返回response。如果请求第三方服务是同步方式，同样会杀死性能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    url = <span class="string">'https://api.github.com/'</span></div><div class="line">    resp = requests.get(url)</div><div class="line">    <span class="keyword">print</span> resp.status_code</div><div class="line">    self.finish(<span class="string">'It works'</span>)</div></pre></td></tr></table></figure></p><p>性能相当慢了，换成AsyncHTTPClient再测：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  </div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    url = <span class="string">'https://api.github.com/'</span></div><div class="line">    http_client = tornado.httpclient.AsyncHTTPClient()</div><div class="line">    http_client.fetch(url, self.on_response)</div><div class="line">    self.finish(<span class="string">'It works'</span>)</div><div class="line"></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">on_response</span><span class="params">(self, response)</span>:</span></div><div class="line">    <span class="keyword">print</span> response.code</div></pre></td></tr></table></figure><p>提高了很多,同样，为了获取response的结果，只需要yield函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncResponseHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line">  </div><div class="line"><span class="meta">  @tornado.web.asynchronous</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    url = <span class="string">'https://api.github.com/'</span></div><div class="line">    http_client = tornado.httpclient.AsyncHTTPClient()</div><div class="line">    response = <span class="keyword">yield</span> tornado.gen.Task(http_client.fetch, url)</div><div class="line">    <span class="keyword">print</span> response.code</div><div class="line">    <span class="keyword">print</span> response.body</div></pre></td></tr></table></figure></p><h3 id="AsyncHTTPClient-转发"><a href="#AsyncHTTPClient-转发" class="headerlink" title="AsyncHTTPClient 转发"></a>AsyncHTTPClient 转发</h3><p>使用Tornado经常需要做一些转发服务，需要借助AsyncHTTPClient。既然是转发，就不可能只有get方法，post，put，delete等方法也会有。此时涉及到一些 headers和body，甚至还有https的waring。</p><p>下面请看一个post的例子， yield结果，通常，使用yield的时候，handler是需要 tornado.gen.coroutine。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">headers = self.request.headers</div><div class="line">body = json.dumps(&#123;<span class="string">'name'</span>: <span class="string">'rsj217'</span>&#125;)</div><div class="line">http_client = tornado.httpclient.AsyncHTTPClient()</div><div class="line"></div><div class="line">resp = <span class="keyword">yield</span> tornado.gen.Task(</div><div class="line">  self.http_client.fetch, </div><div class="line">  url,</div><div class="line">  method=<span class="string">"POST"</span>, </div><div class="line">  headers=headers,</div><div class="line">  body=body, </div><div class="line">  validate_cert=<span class="keyword">False</span>)</div></pre></td></tr></table></figure></p><h3 id="AsyncHTTPClient-构造请求"><a href="#AsyncHTTPClient-构造请求" class="headerlink" title="AsyncHTTPClient 构造请求"></a>AsyncHTTPClient 构造请求</h3><p>如果业务处理并不是在handlers写的，而是在别的地方，当无法直接使用tornado.gen.coroutine的时候，可以构造请求，使用callback的方式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">body = urllib.urlencode(params)</div><div class="line">req = tornado.httpclient.HTTPRequest(</div><div class="line"> url=url, </div><div class="line"> method=<span class="string">'POST'</span>, </div><div class="line"> body=body, </div><div class="line"> validate_cert=<span class="keyword">False</span>) </div><div class="line"></div><div class="line">http_client.fetch(req, self.handler_response)</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler_response</span><span class="params">(self, response)</span>:</span></div><div class="line">  <span class="keyword">print</span> response.code</div></pre></td></tr></table></figure></p><p>用法也比较简单，AsyncHTTPClient中的fetch方法，第一个参数其实是一个HTTPRequest实例对象，因此对于一些和http请求有关的参数，例如method和body，可以使用HTTPRequest先构造一个请求，再扔给fetch方法。通常在转发服务的时候，如果开起了validate_cert，有可能会返回599timeout之类，这是一个warning，官方却认为是合理的。</p><h3 id="AsyncHTTPClient-上传图片"><a href="#AsyncHTTPClient-上传图片" class="headerlink" title="AsyncHTTPClient 上传图片"></a>AsyncHTTPClient 上传图片</h3><p>AsyncHTTPClient 更高级的用法就是上传图片。例如服务有一个功能就是请求第三方服务的图片OCR服务。需要把用户上传的图片，再转发给第三方服务。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@router.Route('/api/v2/account/upload')</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiAccountUploadHandler</span><span class="params">(helper.BaseHandler)</span>:</span></div><div class="line"><span class="meta">  @tornado.gen.coroutine</span></div><div class="line"><span class="meta">  @helper.token_require</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, *args, **kwargs)</span>:</span></div><div class="line">    upload_type = self.get_argument(<span class="string">'type'</span>, <span class="keyword">None</span>)</div><div class="line">    files_body = self.request.files[<span class="string">'file'</span>]</div><div class="line">    new_file = <span class="string">'upload/new_pic.jpg'</span></div><div class="line">    new_file_name = <span class="string">'new_pic.jpg'</span></div><div class="line"></div><div class="line">    <span class="comment"># 写入文件</span></div><div class="line">    <span class="keyword">with</span> open(new_file, <span class="string">'w'</span>) <span class="keyword">as</span> w:</div><div class="line">      w.write(file_[<span class="string">'body'</span>])</div><div class="line">    logging.info(<span class="string">'user &#123;&#125; upload &#123;&#125;'</span>.format(user_id, new_file_name))</div><div class="line"></div><div class="line">    <span class="comment"># 异步请求 上传图片</span></div><div class="line">    <span class="keyword">with</span> open(new_file, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</div><div class="line">      files = [(<span class="string">'image'</span>, new_file_name, f.read())]</div><div class="line">    fields = ((<span class="string">'api_key'</span>, KEY), (<span class="string">'api_secret'</span>, SECRET))</div><div class="line">    content_type, body = encode_multipart_formdata(fields, files)</div><div class="line">    headers = &#123;<span class="string">"Content-Type"</span>: content_type, <span class="string">'content-length'</span>: str(len(body))&#125;</div><div class="line">    request = tornado.httpclient.HTTPRequest(config.OCR_HOST,</div><div class="line">                         method=<span class="string">"POST"</span>, headers=headers, body=body, validate_cert=<span class="keyword">False</span>)</div><div class="line"></div><div class="line">    response = <span class="keyword">yield</span> tornado.httpclient.AsyncHTTPClient().fetch(request)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">encode_multipart_formdata</span><span class="params">(fields, files)</span>:</span></div><div class="line">  <span class="string">"""</span></div><div class="line"><span class="string">  fields is a sequence of (name, value) elements for regular form fields.</span></div><div class="line"><span class="string">  files is a sequence of (name, filename, value) elements for data to be</span></div><div class="line"><span class="string">  uploaded as files.</span></div><div class="line"><span class="string">  Return (content_type, body) ready for httplib.HTTP instance</span></div><div class="line"><span class="string">  """</span></div><div class="line">  boundary = <span class="string">'----------ThIs_Is_tHe_bouNdaRY_$'</span></div><div class="line">  crlf = <span class="string">'\r\n'</span></div><div class="line">  l = []</div><div class="line">  <span class="keyword">for</span> (key, value) <span class="keyword">in</span> fields:</div><div class="line">    l.append(<span class="string">'--'</span> + boundary)</div><div class="line">    l.append(<span class="string">'Content-Disposition: form-data; name="%s"'</span> % key)</div><div class="line">    l.append(<span class="string">''</span>)</div><div class="line">    l.append(value)</div><div class="line">  <span class="keyword">for</span> (key, filename, value) <span class="keyword">in</span> files:</div><div class="line">    filename = filename.encode(<span class="string">"utf8"</span>)</div><div class="line">    l.append(<span class="string">'--'</span> + boundary)</div><div class="line">    l.append(</div><div class="line">        <span class="string">'Content-Disposition: form-data; name="%s"; filename="%s"'</span> % (</div><div class="line">          key, filename</div><div class="line">        )</div><div class="line">    )</div><div class="line">    l.append(<span class="string">'Content-Type: %s'</span> % get_content_type(filename))</div><div class="line">    l.append(<span class="string">''</span>)</div><div class="line">    l.append(value)</div><div class="line">  l.append(<span class="string">'--'</span> + boundary + <span class="string">'--'</span>)</div><div class="line">  l.append(<span class="string">''</span>)</div><div class="line">  body = crlf.join(l)</div><div class="line">  content_type = <span class="string">'multipart/form-data; boundary=%s'</span> % boundary</div><div class="line">  <span class="keyword">return</span> content_type, body</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_content_type</span><span class="params">(filename)</span>:</span></div><div class="line">  <span class="keyword">import</span> mimetypes</div><div class="line">  <span class="keyword">return</span> mimetypes.guess_type(filename)[<span class="number">0</span>] <span class="keyword">or</span> <span class="string">'application/octet-stream'</span></div></pre></td></tr></table></figure></p><p>对比上述的用法，上传图片仅仅是多了一个图片的编码。将图片的二进制数据按照multipart 方式编码。编码的同时，还需要把传递的相关的字段处理好。相比之下，使用requests 的方式则非常简单：<br>files = {}<br>f = open(‘/Users/ghost/Desktop/id.jpg’)<br>files[‘image’] = f<br>data = dict(api_key=’KEY’, api_secret=’SECRET’)<br>resp = requests.post(url, data=data, files=files)<br>f.close()<br>print resp.status_Code</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过AsyncHTTPClient的使用方式，可以轻松的实现handler对第三方服务的请求。结合前面关于tornado异步的使用方式。无非还是两个key。是否需要返回结果，来确定使用callback的方式还是yield的方式。当然，如果不同的函数都yield，yield也可以一直传递。这个特性，tornado的中的tornado.auth 里面对oauth的认证。<br>大致就是这样的用法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;说明&quot;&gt;&lt;a href=&quot;#说明&quot; class=&quot;headerlink&quot; title=&quot;说明&quot;&gt;&lt;/a&gt;说明&lt;/h3&gt;&lt;p&gt;高性能源于Tornado基于Epoll（unix为kqueue）的异步网络IO。因为tornado的单线程机制，一不小心就容易写出阻塞服务（
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="tornado" scheme="http://arvin-he.github.io/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>Linux IO模式及 select、poll、epoll详解</title>
    <link href="http://arvin-he.github.io/2017/11/06/someconcept-2017-11-06/"/>
    <id>http://arvin-he.github.io/2017/11/06/someconcept-2017-11-06/</id>
    <published>2017-11-06T12:49:40.000Z</published>
    <updated>2017-11-07T01:18:37.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="epoll-kqueue-select-iocp的概念"><a href="#epoll-kqueue-select-iocp的概念" class="headerlink" title="epoll, kqueue, select, iocp的概念"></a>epoll, kqueue, select, iocp的概念</h2><p>epoll</p><h2 id="阻塞-非阻塞忙轮询"><a href="#阻塞-非阻塞忙轮询" class="headerlink" title="阻塞, 非阻塞忙轮询"></a>阻塞, 非阻塞忙轮询</h2><h2 id="缓冲区-内核缓冲区"><a href="#缓冲区-内核缓冲区" class="headerlink" title="缓冲区,内核缓冲区"></a>缓冲区,内核缓冲区</h2><p>缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用，当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也需要缓冲区。</p><h2 id="用户态-内核态"><a href="#用户态-内核态" class="headerlink" title="用户态, 内核态"></a>用户态, 内核态</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;epoll-kqueue-select-iocp的概念&quot;&gt;&lt;a href=&quot;#epoll-kqueue-select-iocp的概念&quot; class=&quot;headerlink&quot; title=&quot;epoll, kqueue, select, iocp的概念&quot;&gt;&lt;/a&gt;ep
      
    
    </summary>
    
      <category term="Linux" scheme="http://arvin-he.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://arvin-he.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB之aggregate, pipeline及map_reduce</title>
    <link href="http://arvin-he.github.io/2017/11/05/mongodb-aggregate-pipeline/"/>
    <id>http://arvin-he.github.io/2017/11/05/mongodb-aggregate-pipeline/</id>
    <published>2017-11-05T08:18:15.000Z</published>
    <updated>2017-11-07T01:17:17.710Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MongoDB聚合"><a href="#MongoDB聚合" class="headerlink" title="MongoDB聚合"></a>MongoDB聚合</h3><p>聚合操作处理数据记录并返回计算结果。 聚合操作将多个文档中的值组合在一起，并可对分组数据执行各种操作，以返回单个结果。<br>在SQL中的 count(*)与group by组合相当于mongodb 中的聚合功能。</p><p>基本语法: <code>db.COLLECTION_NAME.aggregate(AGGREGATE_OPERATION)</code></p><h3 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h3><p>数据:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   _id: 100, title: &apos;MongoDB Overview&apos;, description: &apos;MongoDB is no sql database&apos;, by_user: &apos;Maxsu&apos;, </div><div class="line">   url: &apos;http://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 100</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">   _id: 101, title: &apos;NoSQL Overview&apos;, description: &apos;No sql database is very fast&apos;, by_user: &apos;Maxsu&apos;,</div><div class="line">   url: &apos;http://www.yiibai.com&apos;, tags: [&apos;mongodb&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 10</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">   _id: 102, title: &apos;Neo4j Overview&apos;, description: &apos;Neo4j is no sql database&apos;, by_user: &apos;Kuber&apos;,</div><div class="line">   url: &apos;http://www.neo4j.com&apos;, tags: [&apos;neo4j&apos;, &apos;database&apos;, &apos;NoSQL&apos;], likes: 750</div><div class="line">&#125;,</div><div class="line">&#123;</div><div class="line">   _id: 103, title: &apos;MySQL Overview&apos;, description: &apos;MySQL is sql database&apos;, by_user: &apos;Curry&apos;,</div><div class="line">   url: &apos;http://www.yiibai.com/mysql/&apos;, tags: [&apos;MySQL&apos;, &apos;database&apos;, &apos;SQL&apos;], likes: 350</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>聚合字段<code>by_user</code>的总数, 其中<code>by_user</code>作为新集合的<code>_id</code>, 统计的总数放在num_tutorial字段的值中.<br><code>db.article.aggregate([{$group : {_id : &quot;$by_user&quot;, num_tutorial : {$sum : 1}}}])</code><br>结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;_id&quot; : &quot;Curry&quot;, &quot;num_tutorial&quot; : 1 &#125;</div><div class="line">&#123; &quot;_id&quot; : &quot;Kuber&quot;, &quot;num_tutorial&quot; : 1 &#125;</div><div class="line">&#123; &quot;_id&quot; : &quot;Maxsu&quot;, &quot;num_tutorial&quot; : 2 &#125;</div></pre></td></tr></table></figure></p><p>上述用例的Sql等效查询<code>select by_user, count(*) as num_tutorial from</code>article<code>group by by_user;</code></p><h3 id="其他用于聚合的表达式"><a href="#其他用于聚合的表达式" class="headerlink" title="其他用于聚合的表达式"></a>其他用于聚合的表达式</h3><p>$sum    从集合中的所有文档中求出定义的值。 db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$sum : “$likes”}}}])<br>$avg    计算集合中所有文档的所有给定值的平均值。db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$avg : “$likes”}}}])<br>$min    从集合中的所有文档获取相应值的最小值。     db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$min : “$likes”}}}])<br>$max    从集合中的所有文档获取相应值的最大值。     db.mycol.aggregate([{$group : {_id : “$by_user”, num_tutorial : {$max : “$likes”}}}])<br>$push    将值插入到生成的文档中的数组中。       db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$push: “$url”}}}])<br>$addToSet    将值插入生成的文档中的数组，但不会创建重复项。    db.mycol.aggregate([{$group : {_id : “$by_user”, url : {$addToSet : “$url”}}}])<br>$first    根据分组从源文档获取第一个文档。 通常情况下，这只适用于以前应用的“$sort”阶段。    db.mycol.aggregate([{$group : {_id : “$by_user”, first_url : {$first : “$url”}}}])<br>$last    根据分组从源文档获取最后一个文档。通常情况下，这只适用于以前应用的“$sort”阶段。    db.mycol.aggregate([{$group : {_id : “$by_user”, last_url : {$last : “$url”}}}])</p><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>在UNIX命令中，shell管道可以对某些输入执行操作，并将输出用作下一个命令的输入。<br>MongoDB也在聚合框架中支持类似的概念。每一组输出可作为另一组文档的输入，并生成一组生成的文档(或最终生成的JSON文档在管道的末尾)。<br>这样就可以再次用于下一阶段等等。</p><p>以下是在聚合框架可能的阶段 -</p><p>$project - 用于从集合中选择一些特定字段。<br>$match - 这是一个过滤操作，因此可以减少作为下一阶段输入的文档数量。<br>$group - 这是上面讨论的实际聚合。<br>$sort - 排序文档。<br>$skip - 通过这种方式，可以在给定数量的文档的文档列表中向前跳过。<br>$limit - 限制从当前位置开始的给定数量的文档数量。<br>$unwind - 用于展开正在使用数组的文档。使用数组时，数据是预先加入的，此操作将被撤销，以便再次单独使用文档。 因此，在这个阶段，将增加下一阶段的文件数量。</p><h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map_reduce"></a>map_reduce</h3><p>Map-reduce是将大量数据合并为有用的聚合结果的数据处理范例。 MongoDB使用mapReduce命令进行map-reduce操作。MapReduce通常用于处理大型数据集。<br>MapReduce命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">db.collection.mapReduce(</div><div class="line">   function() &#123;emit(key,value);&#125;,  //map function</div><div class="line">   function(key,values) &#123;return reduceFunction&#125;, //reduce function</div><div class="line">   &#123;</div><div class="line">    query: query,  </div><div class="line">    out: out,    //指定结果集以什么方式存储，可选参数包括：  </div><div class="line">                //replace:如果文档(table)存在，则替换table，  </div><div class="line">                //merge:如果文档中存在记录，则覆盖已存在的文档记录  </div><div class="line">                //reduce: 如果文档中存在相同key的记录了，则先计算两条记录，然后覆盖旧记录  </div><div class="line">                // &#123;inline:1&#125;  在内存中存储记录，不写入磁盘(用户数据量少的计算) </div><div class="line">    sort: sort,  </div><div class="line">    limit: limit,  </div><div class="line">    finalize: function  //这个function主要用来在存入out之前可以修改数据，function(key,values) &#123;   </div><div class="line">                        //return modifiedValues;&#125;  </div><div class="line">    scope: document,    //设置参数值，在这里设置的值在map，reduce，finalize函数中可见</div><div class="line">    jsMode:boolean      //是否减少执行过程中BSON和JS的转换，默认true]</div><div class="line">                        //false时 BSON--&gt;JS--&gt;map--&gt;BSON--&gt;JS--&gt;reduce--&gt;BSON,可处理非常大的mapreduce,</div><div class="line">                        //true时BSON--&gt;js--&gt;map--&gt;reduce--&gt;BSON</div><div class="line">                        </div><div class="line">    verbose:boolean     //是否产生更加详细的服务器日志，默认true</div><div class="line">    keytemp：boolean    //true或false，表明结果输出到的collection是否是临时的，如果为true，则会在客户端连接中断后自动删除，如果你用的是MongoDB的mongo客户端连接，  </div><div class="line">                        //那必须exit后才会删除。如果是脚本执行，脚本退出或调用close会自动删除结果collection    </div><div class="line"></div><div class="line">   &#125;</div><div class="line">)</div><div class="line"></div><div class="line">必备参数：map,reduce, out</div></pre></td></tr></table></figure></p><p><code>map: function() {emit(this.cat_id,this.goods_number); }</code><br>说明: 函数内部要调用内置的emit函数,cat_id代表根据cat_id来进行分组,<br>goods_number代表把文档中的goods_number字段映射到cat_id分组上的数据,<br>其中this是指向向前的文档的,这里的第二个参数可以是一个对象,如果是一个对象的话,也是作为数组的元素压进数组里面;</p><p>reduce: function(cat_id,all_goods_number) {return Array.sum(all_goods_number)},<br>cat_id代表着cat_id当前的这一组,all_goods_number代表当前这一组的goods_number集合,这部分返回的就是结果中的value值;</p><p>out: <output>, // 输出到某一个集合中,注意本属性来还支持如果输出的集合如果已经存在了,那是替换,合并还是继续reduce? 另外还支持输出到其他db的分片中,具体用到时查阅文档,筛选出现的键名分别是_id和value;</output></p><p>query: <document>, // 一个查询表达式,是先查询出来,再进行mapReduce的</document></p><p>sort: <document>, // 发往map函数前先给文档排序</document></p><p>limit: <number>, // 发往map函数的文档数量上限,该参数貌似不能用在分片模式下的mapreduce</number></p><p>finalize: function(key, reducedValue) {return modifiedObject; }, // 从reduce函数中接受的参数key与reducedValue,并且可以访问scope中设定的变量</p><p>scope: <document>, // 指定一个全局变量,能应用于finalize和reduce函数</document></p><p>jsMode: <boolean>, // 布尔值，是否减少执行过程中BSON和JS的转换，默认true,true时BSON–&gt;js–&gt;map–&gt;reduce–&gt;BSON,false时 BSON–&gt;JS–&gt;map–&gt;BSON–&gt;JS–&gt;reduce–&gt;BSON,可处理非常大的mapreduce。</boolean></p><p>verbose: <boolean> // 是否产生更加详细的服务器日志，默认true</boolean></p><p>map-reduce函数首先查询集合，然后将结果文档映射到发出的键值对，然后根据具有多个值的键进行减少。</p><ul><li>map是一个JavaScript函数，它将一个值与一个键映射并发出一个键值对；</li><li>reduce是一个javascript函数，可以减少或分组具有相同键的所有文档；</li><li>out指定map-reduce查询结果的输出位置,一般是输出到另一个新的集合里；</li><li>query指定选择文档的可选选择条件；</li><li>sort指定可选的排序条件；</li><li>limit指定可选的最大文档数；</li></ul><p>MapReduce查询可用于构建大型复杂聚合查询。 使用自定义JavaScript函数可以使用MapReduce，它非常灵活和强大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MongoDB聚合&quot;&gt;&lt;a href=&quot;#MongoDB聚合&quot; class=&quot;headerlink&quot; title=&quot;MongoDB聚合&quot;&gt;&lt;/a&gt;MongoDB聚合&lt;/h3&gt;&lt;p&gt;聚合操作处理数据记录并返回计算结果。 聚合操作将多个文档中的值组合在一起，并可对分组
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MongoDB" scheme="http://arvin-he.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>libuv与libev,epoll与select</title>
    <link href="http://arvin-he.github.io/2017/10/31/libuv-libev-epoll-select-2017-10-31/"/>
    <id>http://arvin-he.github.io/2017/10/31/libuv-libev-epoll-select-2017-10-31/</id>
    <published>2017-10-31T14:08:37.000Z</published>
    <updated>2017-11-07T01:17:17.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="libuv与libev"><a href="#libuv与libev" class="headerlink" title="libuv与libev"></a>libuv与libev</h3><h3 id="epoll与select机制"><a href="#epoll与select机制" class="headerlink" title="epoll与select机制"></a>epoll与select机制</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;libuv与libev&quot;&gt;&lt;a href=&quot;#libuv与libev&quot; class=&quot;headerlink&quot; title=&quot;libuv与libev&quot;&gt;&lt;/a&gt;libuv与libev&lt;/h3&gt;&lt;h3 id=&quot;epoll与select机制&quot;&gt;&lt;a href=&quot;#epo
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>python中的一些errors</title>
    <link href="http://arvin-he.github.io/2017/10/29/py-errors-2017-10-29/"/>
    <id>http://arvin-he.github.io/2017/10/29/py-errors-2017-10-29/</id>
    <published>2017-10-29T09:22:42.000Z</published>
    <updated>2017-11-07T01:17:17.722Z</updated>
    
    <content type="html"><![CDATA[<ol><li>builtins.ImportError: cannot import name ‘Empty’<br>当运行python脚本程序后,python解析器会自动将当前脚本的路径加到syspath中,<br>如果当前脚本的路径中含有与标准库同名的脚本queue.py,则报上面的错.所以不要有与标准库同名的脚本.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;builtins.ImportError: cannot import name ‘Empty’&lt;br&gt;当运行python脚本程序后,python解析器会自动将当前脚本的路径加到syspath中,&lt;br&gt;如果当前脚本的路径中含有与标准库同名的脚本queue.py
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python之psutil模块使用</title>
    <link href="http://arvin-he.github.io/2017/10/18/py-psutil-2017-10-18/"/>
    <id>http://arvin-he.github.io/2017/10/18/py-psutil-2017-10-18/</id>
    <published>2017-10-18T06:36:01.000Z</published>
    <updated>2017-10-18T06:37:03.330Z</updated>
    
    <content type="html"><![CDATA[<h3 id="psutil模块"><a href="#psutil模块" class="headerlink" title="psutil模块"></a>psutil模块</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;psutil模块&quot;&gt;&lt;a href=&quot;#psutil模块&quot; class=&quot;headerlink&quot; title=&quot;psutil模块&quot;&gt;&lt;/a&gt;psutil模块&lt;/h3&gt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux笔记</title>
    <link href="http://arvin-he.github.io/2017/10/18/linux-note1-2017-10-18/"/>
    <id>http://arvin-he.github.io/2017/10/18/linux-note1-2017-10-18/</id>
    <published>2017-10-18T06:17:30.000Z</published>
    <updated>2017-10-18T06:30:49.753Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看linux下所有的python3进程"><a href="#查看linux下所有的python3进程" class="headerlink" title="查看linux下所有的python3进程"></a>查看linux下所有的python3进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps aux | grep python3</div></pre></td></tr></table></figure><h3 id="linux下bash脚本执行错误"><a href="#linux下bash脚本执行错误" class="headerlink" title="linux下bash脚本执行错误"></a>linux下bash脚本执行错误</h3><p>错误: <code>-bash: ./reporteveryday.sh: /bin/bash^M: bad interpreter: No such file or directory</code><br>windows下的换行是回车符+换行符，也就是\r\n, 而unix下是换行符\n。<br>linux下不识别\r为回车符，所以导致每行多了个\r。并且因为这个是控制字符，所以在输出参数的时候不会打印出来.</p><p>bash脚本不要在windows下创建,然后在拷贝到Linux下,这样容易导致bash脚本无法执行,且不报错.<br>解决办法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">vim file</div><div class="line"># 查看文件的format</div><div class="line">:set ff</div><div class="line"># 修改文件format为unix</div><div class="line">:set ff=unix</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;查看linux下所有的python3进程&quot;&gt;&lt;a href=&quot;#查看linux下所有的python3进程&quot; class=&quot;headerlink&quot; title=&quot;查看linux下所有的python3进程&quot;&gt;&lt;/a&gt;查看linux下所有的python3进程&lt;/h3&gt;&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http://arvin-he.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 缓存机制与 functools.lru_cache</title>
    <link href="http://arvin-he.github.io/2017/09/29/py-cache-2017-09-29/"/>
    <id>http://arvin-he.github.io/2017/09/29/py-cache-2017-09-29/</id>
    <published>2017-09-29T07:37:17.000Z</published>
    <updated>2017-09-29T07:47:43.927Z</updated>
    
    <content type="html"><![CDATA[<h3 id="缓存概念"><a href="#缓存概念" class="headerlink" title="缓存概念"></a>缓存概念</h3><p>缓存是一种将定量数据加以保存以备迎合后续请求的处理方式，目的是为了加快数据的检索速度<br>下面看一个例子:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> datetime</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCache</span>:</span></div><div class="line">    <span class="string">""""""</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""Constructor"""</span></div><div class="line">        self.cache = &#123;&#125;</div><div class="line">        self.max_cache_size = <span class="number">10</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        根据该键是否存在于缓存当中返回True或者False</span></div><div class="line"><span class="string">        """</span></div><div class="line">        <span class="keyword">return</span> key <span class="keyword">in</span> self.cache</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, key, value)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        更新该缓存字典，您可选择性删除最早条目</span></div><div class="line"><span class="string">        """</span></div><div class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.cache <span class="keyword">and</span> len(self.cache) &gt;= self.max_cache_size:</div><div class="line">            self.remove_oldest()</div><div class="line">        self.cache[key] = &#123;<span class="string">'date_accessed'</span>: datetime.datetime.now(),</div><div class="line">                           <span class="string">'value'</span>: value&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove_oldest</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        删除具备最早访问日期的输入数据</span></div><div class="line"><span class="string">        """</span></div><div class="line">        oldest_entry = <span class="keyword">None</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> self.cache:</div><div class="line">            <span class="keyword">if</span> oldest_entry == <span class="keyword">None</span>:</div><div class="line">                oldest_entry = key</div><div class="line">            <span class="keyword">elif</span> self.cache[key][<span class="string">'date_accessed'</span>] &lt; self.cache[oldest_entry][<span class="string">'date_accessed'</span>]:</div><div class="line">                oldest_entry = key</div><div class="line"></div><div class="line">        self.cache.pop(oldest_entry)</div><div class="line"></div><div class="line"><span class="meta">    @property</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line"><span class="string">        返回缓存容量大小</span></div><div class="line"><span class="string">        """</span></div><div class="line">        <span class="keyword">return</span> len(self.cache)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment">#测试缓存</span></div><div class="line">    keys = [<span class="string">'test'</span>, <span class="string">'red'</span>, <span class="string">'fox'</span>, <span class="string">'fence'</span>, <span class="string">'junk'</span>, \</div><div class="line">            <span class="string">'other'</span>, <span class="string">'alpha'</span>, <span class="string">'bravo'</span>, <span class="string">'cal'</span>, <span class="string">'devo'</span>, <span class="string">'ele'</span>]</div><div class="line">    s = <span class="string">'abcdefghijklmnop'</span></div><div class="line">    cache = MyCache()</div><div class="line">    <span class="keyword">for</span> i, key <span class="keyword">in</span> enumerate(keys):</div><div class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> cache:</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            value = <span class="string">''</span>.join([random.choice(s) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">20</span>)])</div><div class="line">            cache.update(key, value)</div><div class="line">        print(<span class="string">"#%s iterations, #%s cached entries"</span> % (i+<span class="number">1</span>, cache.size))</div></pre></td></tr></table></figure></p><p>在 Python 的 3.2 版本中，引入了一个非常优雅的缓存机器，即 functool 模块中的 <code>lru_cache</code> 装饰器。如果要在 python2 中使用 <code>lru_cahce</code> 需要安装 <code>functools32</code>。lru_cache 原型如下：<code>@functools.lru_cache(maxsize=None, typed=False)</code><br>使用functools模块的lur_cache装饰器，可以缓存最多 maxsize 个此函数的调用结果，从而提高程序执行的效率，特别适合于耗时的函数。参数maxsize为最多缓存的次数，如果为None，则无限制，设置为2n时，性能最佳；<br>被 <code>lru_cache</code> 装饰的函数会有 <code>cache_clear</code> 和 <code>cache_info</code> 两个方法，分别用于清除缓存和查看缓存信息。<br>这里用一个简单的示例演示 lru_cache 效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</div><div class="line"><span class="meta">@lru_cache(None)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line">    print(<span class="string">"calculating: %s + %s"</span> % (x, y))</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"></div><div class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">print(add(<span class="number">2</span>, <span class="number">3</span>))</div><div class="line"></div><div class="line"><span class="comment">#输出结果：</span></div><div class="line">calculating: <span class="number">1</span> + <span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">3</span></div><div class="line">calculating: <span class="number">2</span> + <span class="number">3</span></div><div class="line"><span class="number">5</span></div></pre></td></tr></table></figure></p><p>从结果可以看出，当第二次调用 add(1, 2) 时，并没有真正执行函数体，而是直接返回缓存的结果。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="http://blog.konghy.cn/2016/04/20/python-cache/" target="_blank" rel="external">http://blog.konghy.cn/2016/04/20/python-cache/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;缓存概念&quot;&gt;&lt;a href=&quot;#缓存概念&quot; class=&quot;headerlink&quot; title=&quot;缓存概念&quot;&gt;&lt;/a&gt;缓存概念&lt;/h3&gt;&lt;p&gt;缓存是一种将定量数据加以保存以备迎合后续请求的处理方式，目的是为了加快数据的检索速度&lt;br&gt;下面看一个例子:&lt;br&gt;&lt;fig
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>谷歌浏览器常用快捷键</title>
    <link href="http://arvin-he.github.io/2017/09/29/chrome-hotkey-2017-09-29/"/>
    <id>http://arvin-he.github.io/2017/09/29/chrome-hotkey-2017-09-29/</id>
    <published>2017-09-29T06:20:11.000Z</published>
    <updated>2017-09-29T06:33:46.434Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Chrome窗口和标签页快捷键："><a href="#Chrome窗口和标签页快捷键：" class="headerlink" title="Chrome窗口和标签页快捷键："></a>Chrome窗口和标签页快捷键：</h3><ol><li>Ctrl+N    打开新窗口</li><li>Ctrl+T    打开新标签页</li><li>Ctrl+Shift+N    在隐身模式下打开新窗口</li><li>Ctrl+O，然后选择文件，在谷歌浏览器中打开计算机上的文件</li><li>按住 Ctrl 键，然后点击链接，从后台在新标签页中打开链接，但您仍停留在当前标签页中</li><li>按住 Ctrl+Shift 键，然后点击链接    在新标签页中打开链接，同时切换到新打开的标签页</li><li>按住 Shift 键，然后点击链接    在新窗口中打开链接</li><li>Alt+F4    关闭当前浏览器窗口</li><li>Ctrl+Shift+T 重新打开上次关闭的标签页。谷歌浏览器可记住最近关闭的 10 个标签页。</li><li>将链接拖动到标签页内    在指定标签页中打开链接</li><li>将链接拖动到两个标签页之间    在标签页横条的指定位置建立一个新标签页，在该标签页中打开链接</li><li>Ctrl+1 到 Ctrl+8    切换到指定位置编号的标签页。您按下的数字代表标签页横条上的相应标签位置。</li><li>Ctrl+9    切换到最后一个标签页</li><li>Ctrl+Tab 或 Ctrl+PgDown    切换到下一个标签页</li><li>Ctrl+Shift+Tab 或 Ctrl+PgUp    切换到上一个标签页</li><li>Ctrl+W 或 Ctrl+F4    关闭当前标签页或弹出式窗口</li><li>Alt+Home    打开主页</li></ol><h3 id="Chrome地址栏快捷键-："><a href="#Chrome地址栏快捷键-：" class="headerlink" title="Chrome地址栏快捷键 ："></a>Chrome地址栏快捷键 ：</h3><h4 id="在地址栏，进行下列操作之一："><a href="#在地址栏，进行下列操作之一：" class="headerlink" title="在地址栏，进行下列操作之一："></a>在地址栏，进行下列操作之一：</h4><ol><li>键入搜索字词    使用默认搜索引擎进行搜索</li><li>键入网址中”www.”和”.com”之间的部分，然后按Ctrl+Enter 键    为您在地址栏中输入的内容添加”www.”和”.com”，然后打开网址</li><li>键入搜索引擎关键字或网址，按 Tab键，然后键入搜索字词    使用与关键字或网址相关联的搜索引擎进行搜索。如果谷歌浏览器可以识别您要使用的搜索引擎，则会提示您按 Tab 键。</li><li>F6 或 Ctrl+L 或 Alt+D    选中网址区域中的内容</li><li>键入网址，然后按 Alt+Enter 键    在新标签页中打开网址</li><li>打开谷歌chrome浏览器各功能的快捷键</li><li>Ctrl+B    打开和关闭书签栏</li><li>Ctrl+Shift+B    打开书签管理器</li><li>Ctrl+H    查看”历史记录”页</li><li>Ctrl+J    查看”下载”页</li><li>Shift+Escape    查看任务管理器</li><li>Shift+Alt+T    将焦点设置在工具栏上。使用键盘上的向右和向左箭头，可导航至工具栏上的不同按钮。</li></ol><h3 id="Chrome网页快捷键："><a href="#Chrome网页快捷键：" class="headerlink" title="Chrome网页快捷键："></a>Chrome网页快捷键：</h3><ol><li>Ctrl+P    打印当前页</li><li>Ctrl+S    保存当前页</li><li>F5    重新加载当前页</li><li>Esc    停止加载当前页</li><li>Ctrl+F    打开”在网页上查找”框</li><li>点击鼠标中键或滚轮（只在谷歌浏览器测试版（只有英文版）中可用）    激活自动滚动。当您移动鼠标时，网页会根据鼠标的移动方向自动滚动。</li><li>Ctrl+F5 或 Shift+F5    重新加载当前页，但忽略缓存内容</li><li>按住 Alt 键，然后点击链接    下载链接</li><li>Ctrl+G 或 F3    查找与您在”在网页上查找”框中输入的内容相匹配的下一个匹配项</li><li>Ctrl+Shift+G 或 Shift+F3    查找与您在”在网页上查找”框中输入的内容相匹配的上一个匹配项</li><li>Ctrl+U    查看源代码</li><li>将链接拖动到书签栏    将链接加入书签</li><li>Ctrl+D    将当前网页加入书签</li><li>Ctrl++，或者按住 Ctrl 键并向上滚动鼠标滚轮    放大网页上的所有内容</li><li>Ctrl+-，或者按住 Ctrl 键并向下滚动鼠标滚轮    缩小网页上的所有内容</li><li>Ctrl+0    将网页上的所有内容都恢复到正常大小</li><li>空格键                             向下滚动网页。</li><li>Home                               转至网页顶部。</li><li>End                                转至网页底部。</li><li>按住 Shift 键的同时滚动鼠标滚轮。  在网页上横向滚动。</li></ol><h3 id="浏览器文本快捷键："><a href="#浏览器文本快捷键：" class="headerlink" title="浏览器文本快捷键："></a>浏览器文本快捷键：</h3><ol><li>Ctrl+C                             将突出显示的内容复制到剪贴板中。</li><li>Ctrl+V 或 Shift+Insert             从剪贴板中粘贴内容。</li><li>Ctrl+Shift+V                       从剪贴板中粘贴内容(不带格式)。</li><li>Ctrl+X 或 Shift+Delete             删除突出显示的内容并将其复制到剪贴板中。</li></ol><h3 id="chrome命令16个非常有用的chrome-命令，操作方法与上述类似。"><a href="#chrome命令16个非常有用的chrome-命令，操作方法与上述类似。" class="headerlink" title="chrome命令16个非常有用的chrome://命令，操作方法与上述类似。"></a>chrome命令16个非常有用的chrome://命令，操作方法与上述类似。</h3><ol><li>chrome://downloads 等同于从菜单中查看下载内容，其快捷键是Ctrl+J</li><li>chrome://extensions 等同于菜单-工具-扩展</li><li>chrome://plugins 显示已安装插件 </li><li>chrome://bookmarks 等同于菜单-书签-书签管理器，快捷键Ctrl+Shift+O</li><li>chrome://history 等同于从菜单-历史直接访问，快捷键 Ctrl+H</li><li>chrome://restart 重启chrome浏览器</li><li>chrome://apps 打开chrome网上应用商店</li><li>chrome://flags 可用来启用或者关闭某些chrome的体验特性</li><li>chrome://dns 显示浏览器预抓取的主机名列表，让你随时了解DNS状态</li><li>chrome://memory 重定向到chrome://memory-redirect/，显示系统运行中的浏览器内存使用情况，以及浏览器中进程的详细信息。</li><li>chrome://net-internals 显示网络相关信息，用来捕获浏览器生成的网络事件，可导出数据，可查看DNS主机解析缓存。</li><li>chrome://quota-internals 用来显示浏览器所使用磁盘空间配额的情况。</li><li>chrome://sessions 该命令用来显示当前运行的浏览器的会话信息数以及详细列表</li><li>chrome://settings 该命令可通过菜单-选项直接访问，可用来控制浏览器各项设置值</li><li>chrome://sync-internals 用来显示 chrome 的同步状态</li><li>chrome://about/ 查看 chrome 所有的命令</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Chrome窗口和标签页快捷键：&quot;&gt;&lt;a href=&quot;#Chrome窗口和标签页快捷键：&quot; class=&quot;headerlink&quot; title=&quot;Chrome窗口和标签页快捷键：&quot;&gt;&lt;/a&gt;Chrome窗口和标签页快捷键：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Ctrl+N  
      
    
    </summary>
    
      <category term="工具" scheme="http://arvin-he.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="谷歌" scheme="http://arvin-he.github.io/tags/%E8%B0%B7%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title>爬虫笔记</title>
    <link href="http://arvin-he.github.io/2017/09/29/scrapy-notes2-2017-09-29/"/>
    <id>http://arvin-he.github.io/2017/09/29/scrapy-notes2-2017-09-29/</id>
    <published>2017-09-29T05:40:34.000Z</published>
    <updated>2017-09-29T06:57:19.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一些常识"><a href="#一些常识" class="headerlink" title="一些常识"></a>一些常识</h3><ol><li>代理ip会被集体封禁,然后过一段时间再开放</li><li>ip被封禁后,有的会过段时间解除封禁</li><li>代理ip不是全部可靠的,通常有效代理大概在70%左右</li></ol><h3 id="爬虫错误处理方法"><a href="#爬虫错误处理方法" class="headerlink" title="爬虫错误处理方法"></a>爬虫错误处理方法</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一些常识&quot;&gt;&lt;a href=&quot;#一些常识&quot; class=&quot;headerlink&quot; title=&quot;一些常识&quot;&gt;&lt;/a&gt;一些常识&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;代理ip会被集体封禁,然后过一段时间再开放&lt;/li&gt;
&lt;li&gt;ip被封禁后,有的会过段时间解除封禁&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="爬虫" scheme="http://arvin-he.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB配置</title>
    <link href="http://arvin-he.github.io/2017/09/27/mongodb-config-2017-09-27/"/>
    <id>http://arvin-he.github.io/2017/09/27/mongodb-config-2017-09-27/</id>
    <published>2017-09-27T11:59:15.000Z</published>
    <updated>2017-11-07T01:17:17.718Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装mongodb"><a href="#安装mongodb" class="headerlink" title="安装mongodb"></a>安装mongodb</h3><p>安装就免了吧,安装好mongodb,然后配置环境变量</p><h3 id="创建MongoDB配置文件"><a href="#创建MongoDB配置文件" class="headerlink" title="创建MongoDB配置文件"></a>创建MongoDB配置文件</h3><p><strong>注意:</strong> 配置文件中的所有路径必须要存在, mongodb不会自动给你创建文件夹,所以像data,log,pid等文件夹按照配置文件指定路径手动创建好,否则会报错.<br>先创建一个配置文件,名称为mongodb.cfg,配置内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">#数据文件存放位置</div><div class="line">dbpath=F:/mongodb/data/db</div><div class="line"></div><div class="line">#日志文件存放位置</div><div class="line">logpath=F:/mongodb/data/log/mongodb.log</div><div class="line"></div><div class="line">#PID的路径</div><div class="line">pidfilepath=F:/mongodb/pid/mongodb.pid</div><div class="line"></div><div class="line">#端口号</div><div class="line">port=27017</div><div class="line"></div><div class="line">#错误日志采用追加模式，配置这个选项后mongodb的日志会追加到现有的日志文件</div><div class="line">logappend=true</div><div class="line"></div><div class="line">#启用日志文件，默认启用</div><div class="line">journal=true</div><div class="line"></div><div class="line">#这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为false</div><div class="line">quiet=true</div><div class="line"></div><div class="line">#打开28017网页端口（若不开启注释掉即可）</div><div class="line">rest=true</div></pre></td></tr></table></figure></p><h3 id="启动mongodb"><a href="#启动mongodb" class="headerlink" title="启动mongodb"></a>启动mongodb</h3><p>在终端执行:<code>mongod --config F:/mongodb/config/mongodb.cfg</code><br>然后在浏览器输入:127.0.0.1:27017,回车会看到网页有”It looks like you are trying to access MongoDB over HTTP on the native driver port.”,则表明启动成功</p><h3 id="注册mongodb服务"><a href="#注册mongodb服务" class="headerlink" title="注册mongodb服务"></a>注册mongodb服务</h3><p>如果每次都按照步骤三那样操作，岂不是很麻烦，按照如下命令来创建并启动MongoDB服务，就可以通过windows服务来管理MongoDB的启动和关闭了.<br>安装mongodb服务,在终端输入: <code>mongod --config F:/mongodb/config/mongodb.cfg --install --serviceName MongoDB</code><br>启动mongodb服务,在终端输入: <code>net start MongoDB</code>, 回车,然后有提示出来:MongoDB服务正在启动, MongoDB服务已经启动成功</p><p>错误: 服务名无效<br>一般由两个原因造成,第一: 可能是你的服务名称拼写错误,第二: 就是没有用管理员权限运行命令.<br>查看mongodb日志发现: Error connecting to the Service Control Manager: 拒绝访问, 这说明没有用管理员权限运行命令.<br>使用管理员权限打开cmd, 然后再输入命令并运行, 然后服务就启动成功了.</p><h3 id="去除mongodb服务"><a href="#去除mongodb服务" class="headerlink" title="去除mongodb服务"></a>去除mongodb服务</h3><p>如果需要去除MongoDB服务，执行如下命令：<br><code>mongod --remove --serviceName MongoDB</code></p><h3 id="如何创建用户管理员"><a href="#如何创建用户管理员" class="headerlink" title="如何创建用户管理员"></a>如何创建用户管理员</h3><p>用户管理员是第一个要创建的用户。在没有创建任何用户之前，你可以随意创建用户；但数据库中一旦有了用户，那么未登录的客户端就没有权限做任何操作了，除非使用db.auth(username, password)方法登录。</p><p>用户管理员的角色名叫 userAdminAnyDatabase，这个角色只能在 admin 数据库中创建。下面是一个例子：<br>首先,在终端输入:mongo,回车,进入mongo shell, 然后输入命令.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; use admin</div><div class="line">switched to db admin</div><div class="line">&gt; db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[&quot;userAdminAnyDatabase&quot;]&#125;)</div><div class="line">Successfully added user: &#123; &quot;user&quot; : &quot;root&quot;, &quot;roles&quot; : [ &quot;userAdminAnyDatabase&quot; ] &#125;</div></pre></td></tr></table></figure></p><p>这个例子创建了一个名为 root 的用户管理员。创建完了这个用户之后，我们应该马上以该用户的身份登录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; db.auth(&quot;root&quot;,&quot;root123&quot;)</div><div class="line">1</div><div class="line">db.auth() 方法返回 1 表示登录成功。接下来我们为指定的数据库创建访问所需的账号。</div></pre></td></tr></table></figure></p><h3 id="如何创建数据库用户"><a href="#如何创建数据库用户" class="headerlink" title="如何创建数据库用户"></a>如何创建数据库用户</h3><p>首先保证你已经以用户管理员的身份登录 admin 数据库。然后用 use 命令切换到目标数据库，<br>同样用 db.createUser() 命令来创建用户，其中角色名为 “readWrite”。</p><p>普通的数据库用户角色有两种，read 和 readWrite。顾名思义，前者只能读取数据不能修改，后者可以读取和修改。<br>下面是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; use test</div><div class="line">switched to db test</div><div class="line">&gt; db.createUser(&#123;user:&quot;testuser&quot;,pwd:&quot;testpass&quot;,roles:[&quot;readWrite&quot;]&#125;)</div><div class="line">Successfully added user: &#123; &quot;user&quot; : &quot;testuser&quot;, &quot;roles&quot; : [ &quot;readWrite&quot; ] &#125;</div><div class="line">&gt; db.auth(&quot;testuser&quot;,&quot;testpass&quot;)</div><div class="line">1</div></pre></td></tr></table></figure></p><p>这样 MongoDB 的数据安全性就得到保障了，没有登录的客户端将无法执行任何命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安装mongodb&quot;&gt;&lt;a href=&quot;#安装mongodb&quot; class=&quot;headerlink&quot; title=&quot;安装mongodb&quot;&gt;&lt;/a&gt;安装mongodb&lt;/h3&gt;&lt;p&gt;安装就免了吧,安装好mongodb,然后配置环境变量&lt;/p&gt;
&lt;h3 id=&quot;创建M
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MongoDB" scheme="http://arvin-he.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Python定时器</title>
    <link href="http://arvin-he.github.io/2017/09/20/py-timer-2017-09-20/"/>
    <id>http://arvin-he.github.io/2017/09/20/py-timer-2017-09-20/</id>
    <published>2017-09-20T12:15:37.000Z</published>
    <updated>2017-09-21T00:45:12.220Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python中定时器"><a href="#python中定时器" class="headerlink" title="python中定时器"></a>python中定时器</h3><p>python中的定时器在threading模块中,而且只执行一次, 那么如何定时循环调用呢?<br>Timer:  隔一定时间调用一个函数,如果想实现每隔一段时间就调用一个函数的话，就要在Timer调用的函数中，再次设置Timer。<br>Timer其实是Thread的一个派生类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(name)</span>:</span></div><div class="line">    print(<span class="string">"hello %s\n"</span> % name)</div><div class="line">    <span class="keyword">global</span> timer</div><div class="line">    timer = threading.Timer(<span class="number">2.0</span>, hello, [<span class="string">"world"</span>])</div><div class="line">    timer.start()</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    timer = threading.Timer(<span class="number">2.0</span>, hello, [<span class="string">"world"</span>])</div><div class="line">    timer.start()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;python中定时器&quot;&gt;&lt;a href=&quot;#python中定时器&quot; class=&quot;headerlink&quot; title=&quot;python中定时器&quot;&gt;&lt;/a&gt;python中定时器&lt;/h3&gt;&lt;p&gt;python中的定时器在threading模块中,而且只执行一次, 那么如何
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Python" scheme="http://arvin-he.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux一些常用命令</title>
    <link href="http://arvin-he.github.io/2017/09/19/linux-cmds-2017-09-19/"/>
    <id>http://arvin-he.github.io/2017/09/19/linux-cmds-2017-09-19/</id>
    <published>2017-09-19T13:46:02.000Z</published>
    <updated>2017-10-17T03:54:57.749Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h2><p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件或文件夹.scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p><p>命令格式：<br>scp [参数] [原路径] [目标路径]</p><h3 id="从本地服务器复制到远程服务器："><a href="#从本地服务器复制到远程服务器：" class="headerlink" title="从本地服务器复制到远程服务器："></a>从本地服务器复制到远程服务器：</h3><p>命令格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">scp local_file remote_username@remote_ip:remote_folder  </div><div class="line">或者  </div><div class="line">scp local_file remote_username@remote_ip:remote_file  </div><div class="line">或者  </div><div class="line">scp local_file remote_ip:remote_folder  </div><div class="line">或者  </div><div class="line">scp local_file remote_ip:remote_file</div></pre></td></tr></table></figure></p><p>第1,2个指定了用户名，命令执行后需要输入用户密码，<br>第1个仅指定了远程的目录，文件名字不变，<br>第2个指定了文件名<br>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，<br>第3个仅指定了远程的目录，文件名字不变，<br>第4个指定了文件名 </p><h3 id="从本地拷贝文件夹到远程服务器："><a href="#从本地拷贝文件夹到远程服务器：" class="headerlink" title="从本地拷贝文件夹到远程服务器："></a>从本地拷贝文件夹到远程服务器：</h3><p>命令格式：<br><code>scp -r local_folder remote_username@remote_ip:remote_folder</code><br>或者<br><code>scp -r local_folder remote_ip:remote_folder</code><br>第1个指定了用户名，命令执行后需要输入用户密码；<br>第2个没有指定用户名，命令执行后需要输入用户名和密码；</p><h3 id="从远程服务器复制到本地服务器："><a href="#从远程服务器复制到本地服务器：" class="headerlink" title="从远程服务器复制到本地服务器："></a>从远程服务器复制到本地服务器：</h3><p>从远程复制到本地的scp命令与上面的命令相似，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。</p><p><code>scp arvin@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/</code></p><h3 id="screen命令"><a href="#screen命令" class="headerlink" title="screen命令"></a>screen命令</h3><p> 当使用SSH 或者 telent 远程登录到 Linux 服务器,经常有一些长时间运行的任务，比如系统备份、ftp 传输等等。通常情况下我们都是为每一个这样的任务开一个远程终端窗口，但是他们执行的时间太长了。必须等待它执行完毕，在此期间可不能关掉终端窗口或者断开连接，也不能关机, 否则这个任务就会被杀掉，一切半途而废了。显然,这不是我们所希望的.</p><p>screen命令可以远程运行服务器程序并观察程序执行,即使关闭终端或者关闭电脑也不要紧,服务器上的程序也一直在运行.<br>简单来说，Screen是一个可以在多个进程之间多路复用一个物理终端的窗口管理器。Screen中有会话的概念，用户可以在一个screen会话中创建多个screen窗口，在每一个screen窗口中就像操作一个真实的telnet/SSH连接窗口那样。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span><span class="bash"> ssh登陆. 注意:需要先通过ssh登陆远程服务器才能使用screen</span></div><div class="line">ssh user@ip</div><div class="line"><span class="meta">#</span><span class="bash"> 创建一个screen会话窗口</span></div><div class="line">screen -S test</div><div class="line"><span class="meta">#</span><span class="bash"> 执行程序</span></div><div class="line">python3 test.py</div><div class="line"><span class="meta">#</span><span class="bash"> 查看正在运行的程序,会显示程序执行的pid</span></div><div class="line">screen -ls</div><div class="line"><span class="meta">#</span><span class="bash"> 查看某个程序在终端的输出, 6245是执行成的pid</span></div><div class="line">screen -r -D 6245</div><div class="line"><span class="meta">#</span><span class="bash"> 杀掉screen中的session</span></div><div class="line">kill -9 6245</div><div class="line">screen -ls</div><div class="line"><span class="meta">#</span><span class="bash"> 清除dead 会话</span></div><div class="line">screen -wipe test</div></pre></td></tr></table></figure></p><p>(Detached)—-&gt;挂起状态，无终端在连接会话<br>(Attached)—-&gt;有终端在连接会话。<br><strong>注意:</strong> 如果程序在运行时,不要按下CTRL+C, 这样会中止程序的运行,直接关闭终端窗口就可以了,这样不会关闭程序的运行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">其他常用的命令选项有：</div><div class="line">-c file使用配置文件file，而不使用默认的$HOME/.screenrc</div><div class="line">-d|-D [pid.tty.host]不开启新的screen会话，而是断开其他正在运行的screen会话</div><div class="line">-h num指定历史回滚缓冲区大小为num行</div><div class="line">-list|-ls列出现有screen会话，格式为pid.tty.host</div><div class="line">-d -m启动一个开始就处于断开模式的会话</div><div class="line">-r sessionowner/ [pid.tty.host]重新连接一个断开的会话。多用户模式下连接到其他用户screen会话需要指定sessionowner，需要setuid-root权限</div><div class="line">-S sessionname创建screen会话时为会话指定一个名字</div><div class="line">-v显示screen版本信息</div><div class="line">-wipe [match]同-list，但删掉那些无法连接的会话</div></pre></td></tr></table></figure><p>下例显示当前有两个处于detached状态的screen会话，你可以使用<code>screen -r &lt;screen_pid&gt;</code>重新连接上.<br>如果由于某种原因其中一个会话死掉了（例如人为杀掉该会话），这时screen -list会显示该会话为dead状态。使用screen -wipe命令清除该会话.</p><h3 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h3><p>kill[参数][进程号]</p><p>init进程是不可杀的,<br>init是Linux系统操作中不可缺少的程序之一。所谓的init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。所以,init始终是第一个进程（其进程编号始终为1）。 其它所有进程都是init进程的子孙。init进程是不可杀的！</p><p>常用的信号：只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">HUP    1    终端断线</div><div class="line">INT     2    中断（同 Ctrl + C）</div><div class="line">QUIT    3    退出（同 Ctrl + \）</div><div class="line">TERM   15    终止</div><div class="line">KILL    9    强制终止</div><div class="line">CONT   18    继续（与STOP相反， fg/bg命令）</div><div class="line">STOP    19    暂停（同 Ctrl + Z）</div></pre></td></tr></table></figure></p><p>彻底杀死进程:<br>命令：<code>kill –9 3268</code></p><p>应注意:</p><ol><li><p>信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。</p></li><li><p>要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scp命令&quot;&gt;&lt;a href=&quot;#scp命令&quot; class=&quot;headerlink&quot; title=&quot;scp命令&quot;&gt;&lt;/a&gt;scp命令&lt;/h2&gt;&lt;p&gt;scp是secure copy的简写，用于在Linux下进行远程拷贝文件或文件夹.scp传输是加密的。可能会稍微影响
      
    
    </summary>
    
      <category term="编程" scheme="http://arvin-he.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http://arvin-he.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
