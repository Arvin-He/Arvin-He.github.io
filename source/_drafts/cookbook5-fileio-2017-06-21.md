---
title: 文件与 IO
tags:
---
1. 怎么读写各种不同编码的文本数据，比如 ASCII，UTF-8 或 UTF-16 编码等?
使用带有 rt 模式的 open() 函数读取文本文件
写入一个文本文件，使用带有 wt 模式的 open() 函数，如果之前文件内容存在则清除并覆盖掉。
如果是在已存在文件中添加内容，使用模式为 at 的 open() 函数。
文件的读写操作默认使用系统编码，可以通过调用 sys.getdefaultencoding() 来
得到。在大多数机器上面都是 utf-8 编码。如果你已经知道你要读写的文本是其他编码
方式，那么可以通过传递一个可选的 encoding 参数给 open() 函数

2. 关于换行符的识别问题，在 Unix 和 Windows 中是不一样的 (分别是 n 和 rn)。
默认情况下，Python 会以统一模式处理换行符。这种模式下，在读取文
本的时候，Python 可以识别所有的普通换行符并将其转换为单个 `\n` 字符。类似的，
在输出时会将换行符 \n 转换为系统默认的换行符。如果你不希望这种默认的处理方
式，可以给 open() 函数传入参数 `newline=''`.

3. 你读取或者写入一个文本文件时，你可能会遇到一个编码或者解码错误, 通常表示你读取文本时指定的编码不正确,如果编码错误还是存在的话，你可以给 open() 函数传递一个可选的 errors 参数来处理这些错误。
` g = open('sample.txt', 'rt', encoding='ascii', errors='ignore')`

4. 在 print() 函数中使用 sep 和 end 关键字参数，以你想要的方式输出
```python
print('ACME', 50, 91.5, sep=',', end='!!\n')
ACME,50,91.5!!
```

使用 end 参数也可以在输出中禁止换行
```python
>>>for i in range(5):
...     print(i, end=' ')

0 1 2 3 4 >>>
```

```python
>>> row = ('ACME', 50, 91.5)
>>> print(*row, sep=',')

ACME,50,91.5
```

5. 读写二进制文件，比如图片，声音文件
使用模式为 rb 或 wb 的 open() 函数来读取或写入二进制数据.
需要指明的是所有返回的数据都是字节字符串格式的，而不是文本字符串
在读取二进制数据的时候，特别需要注意的是，索引和迭代动作返回的是字节的值而不是字节字符串.如果你想从二进制模式的文件中读取或写入文本数据，必须确保要进行解码和编码操作。
```python
with open('somefile.bin', 'rb') as f:
    data = f.read(16)
    text = data.decode('utf-8')

with open('somefile.bin', 'wb') as f:
    text = 'Hello World'
    f.write(text.encode('utf-8'))
```

二进制 I/O 还有一个鲜为人知的特性就是数组和 C 结构体类型能直接被写入，而不需要中间转换为自己对象。

6. 文件不存在才能写入, 不允许覆盖已存在的文件内容
可以在 open() 函数中使用 x 模式来代替 w 模式的方法来解决这个问题,
如果文件是二进制的，使用 xb 来代替 xt.
要注意的是 x 模式是一个 Python3 对open() 函数特有的扩展。在 Python 的旧版本或者是 Python 实现的底层 C 函数库中都是没有这个模式的。

7. 字符串的 I/O 操作 
当你想模拟一个普通的文件的时候 StringIO 和 BytesIO 类是很有用的。比如，在
单元测试中，你可以使用 StringIO 来创建一个包含测试数据的类文件对象，这个对象
可以被传给某个参数为普通文件对象的函数。
需要注意的是， StringIO 和 BytesIO 实例并没有正确的整数类型的文件描述符。
因此，它们不能在那些需要使用真实的系统级文件如文件，管道或者是套接字的程序
中使用。

8. 读写压缩文件
读写一个 gzip 或 bz2 格式的压缩文件,gzip 和 bz2 模块可以很容易的处理这些文件。两个模块都为 open() 函数提供了另外的实现来解决这个问题.
大部分情况下读写压缩数据都是很简单的。但是要注意的是选择一个正确的文件模
式是非常重要的。如果你不指定模式，那么默认的就是二进制模式，如果这时候程序
想要接受的是文本数据，那么就会出错。
当写入压缩数据时，可以使用 compresslevel 这个可选的关键字参数来指定一个压缩级别。
```python
with gzip.open('somefile.gz', 'wt', compresslevel=5) as f:
    f.write(text)
```

默认的等级是 9，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。
最后一点， gzip.open() 和 bz2.open() 还有一个很少被知道的特性，它们可以作
用在一个已存在并以二进制模式打开的文件上。
```python
import gzip
f = open('somefile.gz', 'rb')
with gzip.open(f, 'rt') as g:
    text = g.read()
```

这样就允许 gzip 和 bz2 模块可以工作在许多类文件对象上，比如套接字，管道和内存中文件等。

9. 什么是类文件对象?
类文件对象是任意一个带有read方法的对象，read方法有一个可选的size参数。
如果没有指定size，就会从输入源读入所有的数据作为单个字符串返回，否则，只读入size个数据返回。再次调用会从size处接着读。

10. 固定大小记录的文件迭代
你想在一个固定长度记录或者数据块的集合上迭代，而不是在一个文件中一行一行的迭代。
通过下面这个小技巧使用 iter 和 functools.partial() 函数：
```python
from functools import partial
RECORD_SIZE = 32
with open('somefile.data', 'rb') as f:
    records = iter(partial(f.read, RECORD_SIZE), b'')
    for r in records:
        ...
```

这个例子中的 records 对象是一个可迭代对象，它会不断的产生固定大小的数据
块，直到文件末尾。要注意的是如果总记录大小不是块大小的整数倍的话，最后一个
返回元素的字节数会比期望值少。

iter() 函数有一个鲜为人知的特性就是，如果你给它传递一个可调用对象和一个
标记值，它会创建一个迭代器。这个迭代器会一直调用传入的可调用对象直到它返回
标记值为止，这时候迭代终止。
在例子中， functools.partial 用来创建一个每次被调用时从文件中读取固定数
目字节的可调用对象。标记值 b'' 就是当到达文件结尾时的返回值。
最后再提一点，上面的例子中的文件时以二进制模式打开的。如果是读取固定大小
的记录，这通常是最普遍的情况。而对于文本文件，一行一行的读取 (默认的迭代行
为) 更普遍点。

11. 读取二进制数据到可变缓冲区中而不需要做任何的中间复制操作。或者你想原地修改数据并将它写回到一个文件中去
为了读取数据到一个可变数组中，使用文件对象的 readinto() 方法
文件对象的 readinto() 方法能被用来为预先分配内存的数组填充数据，甚至包括
由 array 模块或 numpy 库创建的数组。和普通 read() 方法不同的是， readinto() 填
充已存在的缓冲区而不是为新对象重新分配内存再返回它们。因此，你可以使用它来
避免大量的内存分配操作。
另外有一个有趣特性就是 memoryview ，它可以通过零复制的方式对已存在的缓冲
区执行切片操作，甚至还能修改它的内容。
使用 f.readinto() 时需要注意的是，你必须检查它的返回值，也就是实际读取的字节数。
如果字节数小于缓冲区大小，表明数据被截断或者被破坏了 (比如你期望每次读取指定数量的字节)。

12. 内存映射的二进制文件
你想内存映射一个二进制文件到一个可变字节数组中，目的可能是为了随机访问它的内容或者是原地做些修改。
使用 mmap 模块来内存映射文件。mmap() 返回的 mmap 对象同样也可以作为一个上下文管理器来使用，这时候底层的
文件会被自动关闭。
需要强调的一点是，内存映射一个文件并不会导致整个文件被读取到内存中。也就
是说，文件并没有被复制到内存缓存或数组中。相反，操作系统仅仅为文件内容保留
了一段虚拟内存。当你访问文件的不同区域时，这些区域的内容才根据需要被读取并
映射到内存区域中。而那些从没被访问到的部分还是留在磁盘上。所有这些过程是透
明的，在幕后完成！

12. os.path模块
想获取元数据 (比如文件大小或者是修改日期)，也可以使用 os.path 模
块来解决：
```python
>>> os.path.getsize('/etc/passwd')
3669
>>> os.path.getmtime('/etc/passwd')
1272478234.0
>>> import time
>>> time.ctime(os.path.getmtime('/etc/passwd'))
'Wed Apr 28 13:10:34 2010'
>>>
```

可能唯一需要注意的就是你需要考虑文件权限的问题，特别是在获取元数据时候

13.  忽略文件名编码
你想使用原始文件名执行文件的 I/O 操作，也就是说文件名并没有经过系统默认编码去解码或编码过。默认情况下，所有的文件名都会根据 sys.getfilesystemencoding() 返回的文本编码来编码或解码。如果因为某种原因你想忽略这种编码，可以使用一个原始字节字符串来指定一个文
件名即可.

14. 增加或改变已打开文件的编码
在不关闭一个已打开的文件前提下增加或改变它的 Unicode 编码.
如果你想修改一个已经打开的文本模式的文件的编码方式，可以先使用 detach()方法移除掉已存在的文本编码层，并使用新的编码方式代替。
I/O 系统由一系列的层次构建而成。
io.TextIOWrapper 是一个编码和解码 Unicode 的文本处理层，
io.BufferedWriter 是一个处理二进制数据的带缓冲的 I/O 层， 
io.FileIO 是一个表示操作系统底层文件描述符的原始文件。
增加或改变文本编码会涉及增加或改变最上面的 io.TextIOWrapper 层。
一般来讲，像上面例子这样通过访问属性值来直接操作不同的层是很不安全的。导致文件被破坏掉不可用.
detach() 方法会断开文件的最顶层并返回第二层，之后最顶层就没什么用了

15. 创建临时文件和文件夹
你需要在程序执行时创建一个临时文件或目录，并希望使用完之后可以自动销毁掉。
tempfile 模块中有很多的函数可以完成这任务。为了创建一个匿名的临时文件，可以使用 tempfile.TemporaryFile 
在大多数 Unix 系统上，通过 TemporaryFile() 创建的文件都是匿名的，甚至连目录都没有。
如果你想打破这个限制，可以使用 NamedTemporaryFile() 来代替。
被打开文件的 f.name 属性包含了该临时文件的文件名。当你需要将文件
名传递给其他代码来打开这个文件的时候，这个就很有用了。和 TemporaryFile() 一
样，结果文件关闭时会被自动删除掉。如果你不想这么做，可以传递一个关键字参数delte=False 即可。
TemporaryFile() 、NamedTemporaryFile() 和 TemporaryDirectory() 函数应该
是处理临时文件目录的最简单的方式了，因为它们会自动处理所有的创建和清理步骤。
在一个更低的级别，你可以使用 mkstemp() 和 mkdtemp() 来创建临时文件和目录。
所有和临时文件相关的函数都允许你通过使用关键字参数 prefix 、suffix 和 dir
来自定义目录以及命名规则。

16. 序列化 Python 对象
将一个 Python 对象序列化为一个字节流，以便将它保存到一个文件、存储到数据库或者通过网络传输它.
对于序列化最普遍的做法就是使用 pickle 模块, pickle 是一种 Python 特有的自描述的数据编码。通过自描述，被序列化后的数据
包含每个对象开始和结束以及它的类型信息。
千万不要对不信任的数据使用 pickle.load() 。
pickle 在加载时有一个副作用就是它会自动加载相应模块并构造实例对象。
但是某个坏人如果知道 pickle 的工作原理，
他就可以创建一个恶意的数据导致 Python 执行随意指定的系统命令。
因此，一定要保证 pickle 只在相互之间可以认证对方的解析器的内部使用。

有些类型的对象是不能被序列化的。这些通常是那些依赖外部系统状态的对象，
比如打开的文件，网络连接，线程，进程，栈帧等等。用户自定义类可以通过提
供 getstate () 和 setstate () 方法来绕过这些限制。如果定义了这两个方法，
pickle.dump() 就会调用 getstate () 获取序列化的对象。类似的， setstate ()
在反序列化时被调用。

pickle 对于大型的数据结构比如使用 array 或 numpy 模块创建的二进制数组效率
并不是一个高效的编码方式。由于 pickle 是 Python 特有的并且附着在源码上，所有如果需要长期存储数据的
时候不应该选用它。例如，如果源码变动了，你所有的存储数据可能会被破坏并且变
得不可读取。