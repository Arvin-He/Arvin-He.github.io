<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Simple & Freedom" type="application/atom+xml" />






<meta name="description" content="Learn and live.">
<meta property="og:type" content="website">
<meta property="og:title" content="Simple &amp; Freedom">
<meta property="og:url" content="http://arvin-he.github.io/page/22/index.html">
<meta property="og:site_name" content="Simple &amp; Freedom">
<meta property="og:description" content="Learn and live.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple &amp; Freedom">
<meta name="twitter:description" content="Learn and live.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://arvin-he.github.io/page/22/"/>





  <title>Simple & Freedom</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Simple & Freedom</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Learn and live.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/05/03/cpp-volatile-2017-05-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/03/cpp-volatile-2017-05-03/" itemprop="url">C++之volatile关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T15:22:22+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>volatile的本意是“易变的”,volatile关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。</p>
<p>当要求使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被寄存。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> i=<span class="number">10</span>;</div><div class="line"><span class="keyword">int</span> a = i;</div><div class="line">......    <span class="comment">//其他代码，并未明确告诉编译器，对i进行过操作</span></div><div class="line"><span class="keyword">int</span> b = i;</div></pre></td></tr></table></figure></p>
<p>volatile 指出 i是随时可能发生变化的，每次使用它的时候必须从i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在b中。而优化做法是，由于编译器发现两次从i读数据的代码之间的代码没有对i进行过操作，它会自动把上次读的数据放在b中。而不是重新从i里面读。这样以来，如果i是一个寄存器变量或者表示一个端口数据就容易出错，所以说volatile可以保证对特殊地址的稳定访问。</p>
<h3 id="volatile的易变性"><a href="#volatile的易变性" class="headerlink" title="volatile的易变性"></a>volatile的易变性</h3><p>所谓的易变性，在<strong>汇编层面</strong>反映出来，就是两条语句，下一条语句不会直接使用上一条语句对应的volatile变量的寄存器内容，而是重新从内存中读取。</p>
<h3 id="volatile的不可优化性"><a href="#volatile的不可优化性" class="headerlink" title="volatile的不可优化性"></a>volatile的不可优化性</h3><p>“不可优化”特性。volatile告诉编译器，不要对我这个变量进行各种激进的优化，甚至将变量直接消除，保证程序员写在代码中的指令，一定会被执行。</p>
<h3 id="volatile的顺序性"><a href="#volatile的顺序性" class="headerlink" title="volatile的顺序性"></a>volatile的顺序性</h3><p>C/C++ Volatile关键词前面提到的易变性和不可优化性，让Volatile经常被解读为一个为多线程而生的关键词：一个全局变量，会被多线程同时访问/修改，那么线程内部，就不能假设此变量的不变性，并且基于此假设，来做一些程序设计。当然，这样的假设，本身并没有什么问题，多线程编程，并发访问/修改的全局变量，通常都会建议加上Volatile关键词修饰，来防止C/C++编译器进行不必要的优化。但是，很多时候，C/C++ Volatile关键词，在多线程环境下，会被赋予更多的功能，从而导致问题的出现。</p>
<p>”顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。Volatile变量与非Volatile变量的顺序，编译器不保证顺序，可能会进行乱序优化。同时，C/C++ Volatile关键词，并不能用于构建happens-before语义，因此在进行多线程程序设计时，要小心使用volatile，不要掉入volatile变量的使用陷阱之中。</p>
<h3 id="关于volatile的补充："><a href="#关于volatile的补充：" class="headerlink" title="关于volatile的补充："></a>关于volatile的补充：</h3><p>一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。<br>下面是volatile变量的几个例子：</p>
<ul>
<li>并行设备的硬件寄存器（如：状态寄存器）</li>
<li>一个中断服务子程序中会访问到的非自动变量(Non-automatic variables)</li>
<li>多线程应用中被几个任务共享的变量</li>
</ul>
<p>关于volatile的一些问题：<br>1). 一个参数既可以是const还可以是volatile吗？解释为什么。<br>2). 一个指针可以是volatile 吗？解释为什么。<br>3). 下面的函数有什么错误：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> *ptr * *ptr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是答案：<br>1). 是的。一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。<br>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修改一个指向一个buffer的指针时。<br>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针*ptr指向值的平方，但是，由于*ptr指向一个volatile型参数，编译器将产生类似下面的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> a,b;</div><div class="line">    a = *ptr;</div><div class="line">    b = *ptr;</div><div class="line">    <span class="keyword">return</span> a * b;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>由于*ptr的值可能被意想不到地该变，因此a和b可能是不同的。结果，这段代码可能返不是你所期望的平方值！正确的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">long</span> <span class="title">square</span><span class="params">(<span class="keyword">volatile</span> <span class="keyword">int</span> *ptr)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> a;</div><div class="line">    a = *ptr;</div><div class="line">    <span class="keyword">return</span> a * a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://hedengcheng.com/?p=725" target="_blank" rel="external">参考文章</a></li>
<li><a href="http://blog.csdn.net/wuliming_sc/article/details/3717017" target="_blank" rel="external">参考文章</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/05/03/cpp-explicit-2017-05-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/03/cpp-explicit-2017-05-03/" itemprop="url">C++之explicit关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-03T14:49:41+08:00">
                2017-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h3><p>C++中，explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换。</p>
<p>在C++中，如果一个类只有一个参数的构造函数，C++允许一种特殊的声明类变量的方式。即可以直接将一个对应于构造函数参数类型的数据直接赋值给类变量，编译器在编译时会自动进行类型转换，将对应于构造函数参数类型的数据转换为类的对象。如果在构造函数前加上explicit修饰词，则会禁止这种自动转换，此时，即使将对应于构造函数参数类型的数据直接赋值给类变量，编译器也会报错。</p>
<h3 id="explicit使用注意事项"><a href="#explicit使用注意事项" class="headerlink" title="explicit使用注意事项"></a>explicit使用注意事项</h3><p>explicit 关键字只能用于类内部的构造函数声明上，且作用于<strong>单个参数</strong>的构造函数。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="keyword">int</span> age;</div><div class="line">Student (<span class="keyword">int</span> a) &#123;age=a;&#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span> <span class="params">( <span class="keyword">void</span> )</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">　<span class="function">Student <span class="title">s1</span><span class="params">(<span class="number">10</span>)</span></span>;　 <span class="comment">//方式一</span></div><div class="line">　Student* p_s2=<span class="keyword">new</span> Student(<span class="number">10</span>); <span class="comment">//方式二</span></div><div class="line">　Student s3=<span class="number">10</span>; <span class="comment">//方式三</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三种方式比较特殊,因为C++是一种强类型语言，不同的数据类型是不能随意转换的，必须进行显式或隐式的类型转换，这里，没有进行任何显式转换，直接将一个整型数据赋值给了类变量s3.这里是进行了一次隐式类型转换，<strong>编译器</strong>自动将对应于构造函数参数类型的数据转换为了该类的对象，最终方式三经编译器自动转换后和方式一的实现方式是相同的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/04/27/cpp-extern-2017-04-27/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/27/cpp-extern-2017-04-27/" itemprop="url">C/C++之extern关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-27T09:39:42+08:00">
                2017-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="extern作用"><a href="#extern作用" class="headerlink" title="extern作用"></a>extern作用</h3><p>extern可以置于变量或者函数前，表示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义。此外extern也可用来进行链接指定。</p>
<p>extern有两个作用:<br>第一个,当它与”C”一起连用时，如: <code>extern &quot;C&quot; void fun(int a, int b);</code><br>则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的，C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是<code>fun@aBc_int_int#%$</code>也可能是别的，不同的编译器采用的方法不一样，为什么这么做呢，因为C++支持函数的重载.<br>第二，当extern不与”C”在一起修饰变量或函数时，它的作用就是<strong>声明函数或全局变量</strong>的作用范围的关键字,如在头文件中: <code>extern int g_Int;</code> ，其声明的函数和变量可以在本模块和其他模块中使用.记住它是一个<strong>声明</strong>不是定义!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可,在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在链接时从模块A生成的目标代码中找到此函数。</p>
<h3 id="extern一些使用实例"><a href="#extern一些使用实例" class="headerlink" title="extern一些使用实例"></a>extern一些使用实例</h3><ol>
<li><p>问题:在一个源文件里定义了一个数组:<code>char a[6];</code>,在另外一个文件里用下列语句进行了声明：<code>extern char \*a</code>, 请问这样可以吗？<br>答案:不可以，程序运行时会告诉你非法访问。<br>原因:指向类型T的指针并不等价于类型T的数组。extern char <em>a声明的是一个指针变量而不是字符数组，因此与实际的定义不同，从而造成运行时非法访问。应该将声明改为extern char a[]。<br>分析:例子分析如下，如果a[] = “abcd”,则外部变量a=0x61626364 (abcd的ASCII码值)，</em>a显然没有意义,显然a指向的空间（0x61626364）没有意义，易出现非法内存访问。这提示我们，在使用extern时候要严格对应声明时的格式，在实际编程中，这样的错误屡见不鲜。<br>extern用在变量声明中常常有这样一个作用，你在*.c文件中声明了一个全局的变量，这个全局的变量如果要被引用，就放在*.h中并用extern来声明。</p>
</li>
<li><p>问题：单方面修改extern 函数原型<br>当函数提供方单方面修改函数原型时，如果使用方不知情继续沿用原来的extern声明，这样编译时编译器不会报错。但是在运行过程中，因为少了或者多了输入参数，往往会照成系统错误，这种情况应该如何解决？<br>答案与分析：目前业界针对这种情况的处理没有一个很完美的方案，通常的做法是提供方在自己的xxx_pub.h中提供对外部接口的声明，然后调用方include该头文件，从而省去extern这一步。以避免这种错误。宝剑有双锋，对extern的应用，不同的场合应该选择不同的做法。</p>
</li>
<li><p>extern “C”, 在C++环境下使用C函数的时候，常常会出现编译器无法找到obj模块中的C函数定义，从而导致链接失败的情况，应该如何解决这种情况呢？<br>答案与分析：C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此会造成链接时找不到对应函数的情况，此时C函数就需要用extern “C”进行链接指定，这告诉编译器，请保持我的名称，不要给我生成用于链接的中间函数名。下面是一个标准的写法：</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在.h文件的头上</span></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> __cplusplus</span></div><div class="line"><span class="keyword">extern</span> <span class="string">"C"</span>&#123;</div><div class="line">　<span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">　<span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cplusplus */</span> </span></div><div class="line">　…</div><div class="line">　…</div><div class="line">　<span class="comment">//.h文件结束的地方</span></div><div class="line">　<span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">　<span class="meta">#<span class="meta-keyword">if</span> __cplusplus</span></div><div class="line">&#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></div></pre></td></tr></table></figure>
<ol>
<li>常见extern放在函数的前面成为函数声明的一部分，那么，C语言的关键字extern在函数的声明中起什么作用？<br>答案与分析：如果函数的声明中带有关键字extern，仅仅是暗示这个函数可能在别的源文件里定义，没有其它作用。<br>即下述两个函数声明没有明显的区别：<code>extern int f();</code>和<code>int f();</code><br>当然，这样的用处还是有的，就是在程序中取代include “*.h”来声明函数，在一些复杂的项目中，我比较习惯在所有的函数声明前添加extern修饰。关于这样做的原因和利弊可见下面的这个例子：用extern修饰的全局变量<br>(1) 在test1.h中有下列声明:<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST1H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST1H</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">char</span> g_str[]; <span class="comment">// 声明全局变量g_str</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure>
</li>
</ol>
<p>(2) 在test1.cpp中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></div><div class="line"><span class="keyword">char</span> g_str[] = <span class="string">"123456"</span>; <span class="comment">// 定义全局变量g_str</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; g_str &lt;&lt; <span class="built_in">endl</span>; &#125;</div></pre></td></tr></table></figure></p>
<p>(3) 以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span>    </span>&#123; <span class="built_in">cout</span> &lt;&lt; g_str &lt;&lt; <span class="built_in">endl</span>;    &#125;</div></pre></td></tr></table></figure></p>
<p>以上test1和test2可以同时编译连接通过，如果你感兴趣的话可以用ultraEdit打开test1.obj,你可以在里面找到”123456”这个字符串,但是你却不能在test2.obj里面找到，这是因为g_str是整个工程的全局变量，在内存中只存在一份,test2.obj这个编译单元不需要再有一份了，不然会在连接时报告重复定义这个错误!</p>
<ol>
<li>有些人喜欢把全局变量的声明和定义放在一起，这样可以防止忘记了定义.<br>如把上面test1.h改为:<code>extern char g_str[] = &quot;123456&quot;; // 这个时候相当于没有extern</code>,然后把test1.cpp中的g_str的定义去掉,这个时候再编译连接test1和test2两个模块时，会报链接错误，这是因为你把全局变量g_str的定义放在了头文件之后，test1.cpp这个模块包含了test1.h所以定义了一次g_str,而test2.cpp也包含了test1.h,所以再一次定义了g_str,这个时候链接器在链接test1和test2时发现两个g_str。如果你非要把g_str的定义放在test1.h中的话，那么就把test2的代码中#include “test1.h”去掉 换成:<code>extern char g_str[];</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在test2先声明下,再使用</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">char</span> g_str[];</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span>   </span>&#123;  <span class="built_in">cout</span> &lt;&lt; g_str &lt;&lt; <span class="built_in">endl</span>;   &#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这个时候编译器就知道g_str是引自于外部的一个编译模块了，不会在本模块中再重复定义一个出来，但是我想说这样做非常糟糕，因为你由于无法在test2.cpp中使用<code>#include &quot;test1.h&quot;</code>,那么test1.h中声明的<strong>其他函数</strong>你<strong>也无法使用</strong>了，除非也用都用extern修饰，这样的话你光声明的函数就要一大串，而且头文件的作用就是要给外部提供接口使用的，所以 请记住， <strong>只在头文件中做声明</strong>，真理总是这么简单。</p>
<ol>
<li>extern 和 static<br>(1) extern 表明该变量在别的地方已经定义过了,在这里要使用那个变量.<br>(2) static 表示静态的变量，分配内存的时候, 存储在静态区,不存储在栈上面.</li>
</ol>
<p>static 作用范围是内部连接的关系, 和extern有点相反.它和对象本身是分开存储的,extern也是分开存储的,但是extern可以被其他的对象用extern引用,而static 不可以,只允许对象本身用它.<br>具体差别:<br>首先，static与extern是一对“水火不容”的家伙，也就是说extern和static不能同时修饰一个变量；<br>其次，static修饰的全局变量声明与定义同时进行，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；<br>最后，static修饰全局变量的作用域只能是本身的编译单元，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它,如:<br>(1) test1.h:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST1H</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST1H</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">char</span> g_str[] = <span class="string">"123456"</span>; </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div></pre></td></tr></table></figure></p>
<p>(2) test1.cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span>  </span>&#123;   <span class="built_in">cout</span> &lt;&lt; g_str &lt;&lt; <span class="built_in">endl</span>;  &#125;</div></pre></td></tr></table></figure></p>
<p>(3) test2.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span>  </span>&#123;   <span class="built_in">cout</span> &lt;&lt; g_str &lt;&lt; <span class="built_in">endl</span>;  &#125;</div></pre></td></tr></table></figure></p>
<p>以上两个编译单元可以连接成功, 当你打开test1.obj时，你可以在它里面找到字符串”123456”,同时你也可以在test2.obj中找到它们，它们之所以可以连接成功而没有报重复定义的错误是因为虽然它们有相同的内容，但是存储的物理地址并不一样，就像是两个不同变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元。 也许你比较较真，自己偷偷的跟踪调试上面的代码,结果你发现两个编译单元（test1,test2）的g_str的内存地址相同，于是你下结论static修饰的变量也可以作用于其他模块，但是我要告诉你，那是你的编译器在欺骗你，大多数编译器都对代码都有优化功能，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份，比如上面的”123456”, 位于两个编译单元中的变量都是同样的内容，那么在连接的时候它在内存中就只会存在一份了，如果你把上面的代码改成下面的样子，你马上就可以拆穿编译器的谎言:<br>(1) test1.cpp:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    g_str[<span class="number">0</span>] = <span class="string">"a"</span>;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; g_str &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(2) test2.cpp<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test1.h"</span></span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span>  </span>&#123;  <span class="built_in">cout</span> &lt;&lt; g_str &lt;&lt; <span class="built_in">endl</span>;  &#125;</div></pre></td></tr></table></figure></p>
<p>(3)<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    fun1(); <span class="comment">// a23456</span></div><div class="line">    fun2(); <span class="comment">// 123456</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>这个时候你在跟踪代码时，就会发现两个编译单元中的g_str地址并不相同，因为你在一处修改了它，所以编译器被强行的恢复内存的原貌，在内存中存在了两份拷贝给两个模块中的变量使用。正是因为static有以上的特性，所以<strong>一般定义static全局变量时，都把它放在源文件中而不是头文件</strong>，这样就不会给其他模块造成不必要的信息污染，同样记住这个原则吧！</p>
<ol>
<li>extern 和const</li>
</ol>
<p>C++中const修饰的全局常量具有跟static相同的特性，即它们只能作用于本编译模块中，但是const可以与extern连用来声明该常量可以作用于其他编译模块中, 如<code>extern const char g_str[];</code>,然后在原文件中别忘了定义:<code>const char g_str[] = &quot;123456&quot;;</code>.</p>
<p>所以当const单独使用时它就与static相同，而当与extern一起合作的时候，它的特性就跟extern的一样了！我只是想提醒你，<code>const char* g_str = &quot;123456&quot;</code> 与 <code>const char g_str[] =&quot;123465&quot;</code>是不同的， 前面那个const 修饰的是<code>char *</code>而不是g_str,它的g_str并不是常量，它被看做是一个定义了的全局变量（可以被其他编译单元使用）， 所以如果你像让<code>char* g_str</code>遵守const的全局常量的规则，最好这么定义const char* const g_str=”123456”.</p>
<p>假如a.h中有 int a=10; t1.cpp和t2.cpp同时include “a.h”则编译不成功，因为a重复定义；<br>如果 a.h中是 static int a=10;则可以，因为t1和t2中的a只是名字相同，地址空间不同；<br>如果a.h中是 extern int a; 并且在a.cpp中 int a=10; 则t1和t2中的a指向同一个地址空间。</p>
<p>在头文件中定义全局变量，如果该头文件不被任何.c或者.cpp中包含的话，该变量的定义是没有意义的，即使加了extern 关键字。因为在变量定义中，extern关键字是不起作用的，extern只用作声明。<br>编译器在编译时，是不管头文件的，只有在预处理时会include头文件中的内容，也就是把头文件中的内容全盘粘贴过来。因此，如果你只是在头文件中定义变量，而不include头文件，这时，编译器无论是在预处理阶段，还是在链接阶段，直接无视头文件的存在(链接器只会在.c/.cpp生成的目标文件(.o)中查找变量名）。这样一来，头文件中定义的变量也就形同虚设，完全没有意义可言。因此虽然在头文件定义,但不include该头文件时,VS链接时也就会在.c/.cpp生成的目标文件(.o)中查找变量名出现无法解析的外部命令了。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.cnblogs.com/yc_sunniwell/archive/2010/07/14/1777431.html" target="_blank" rel="external">C/C++中extern关键字详解</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/04/26/cpp-inline-2017-04-26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/26/cpp-inline-2017-04-26/" itemprop="url">C/C++之inline关键字</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T15:57:56+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="内联函数-——-C-中关键字-inline-用法解析"><a href="#内联函数-——-C-中关键字-inline-用法解析" class="headerlink" title="内联函数 —— C 中关键字 inline 用法解析"></a>内联函数 —— C 中关键字 inline 用法解析</h3><p>内联函数:在C语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。<br>为了解决这个问题，特别的引入了inline修饰符，表示为内联函数。<br>栈空间就是指放置程式的局部数据也就是函数内数据的内存空间，在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程式出错的问题，函数的死循环递归调用的最终结果就是导致栈内存空间耗尽。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="comment">//函数定义为inline即:内联函数</span></div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">dbtest</span><span class="params">(<span class="keyword">int</span> a)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">return</span> (i % <span class="number">2</span> &gt; <span class="number">0</span>) ? <span class="string">"奇"</span> : <span class="string">"偶"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"i:%d    奇偶性:%s /n"</span>, i, dbtest(i));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的例子就是标准的内联函数的用法，使用inline修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个for循环的内部任何调用dbtest(i)的地方都换成了(i%2&gt;0)?”奇”:”偶”这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。<br>其实这种有点类似动态库和静态库的问题，将dbtest函数中的代码直接被放到main函数中，执行for循环时，会不断调用这段代码，而不是不断地开辟一个函数栈。</p>
<p>内联函数的注意事项:<br>关键字inline 必须与函数<strong>定义体</strong>放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用。<br>所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline 关键字，但我认为inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。</p>
<p>inline的使用是有所限制的<br>inline只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数(自己内部还调用自己的函数).</p>
<p>慎用内联<br>内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？<br>内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收<br>获会很少。<br>另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。<br>以下情况不宜使用内联：<br>（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。<br>（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。<br>一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline 不应该出现在函数的声明中）。</p>
<p>总结：<br>因此,将内联函数放在头文件里实现是合适的,省却你为每个文件实现一次的麻烦.而声明跟定义要一致,其实是指,如果在每个文件里都实现一次该内联函数的话,那么,最好保证每个定义都是一样的,否则,将会引起未定义的行为,即是说,如果不是每个文件里的定义都一样,那么,编译器展开的是哪一个,那要看具体的编译器而定.所以,最好将内联函数定义放在头文件中.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://blog.csdn.net/zqixiao_09/article/details/50877383" target="_blank" rel="external">参考文章</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/04/26/cpp-thread-process-2017-04-26/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/26/cpp-thread-process-2017-04-26/" itemprop="url">C++之线程与进程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T10:47:37+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程与线程的概念"><a href="#进程与线程的概念" class="headerlink" title="进程与线程的概念"></a>进程与线程的概念</h3><ol>
<li><p>任务调度<br>大部分操作系统(如Windows、Linux)的任务调度是采用时间片轮转的抢占式调度方式，即一个任务执行一小段时间后强制暂停去执行下一个任务，每个任务轮流执行。任务执行的一小段时间叫做时间片，任务正在执行时的状态叫运行状态，任务执行一段时间后强制暂停去执行下一个任务，被暂停的任务就处于就绪状态等待下一个属于它的时间片的到来,这样每个任务都能得到执行.</p>
</li>
<li><p>进程<br>操作系统是计算机的管理者，它负责任务的调度、资源的分配和管理，统领整个计算机硬件；应用程序则是具有某种功能的程序，程序是运行于操作系统之上的.<br>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p>
</li>
</ol>
<p>进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p>
<p>进程是一种抽象的概念，从来没有统一的标准定义。进程一般由程序、数据集合和进程控制块三部分组成。<br>程序用于描述进程要完成的功能，是控制进程执行的指令集；<br>数据集合是程序在执行时所需要的数据和工作区；<br>程序控制块(Program Control Block，简称PCB)，包含进程的描述信息和控制信息，是进程存在的唯一标志。</p>
<p>进程具有的特征：<br>动态性：进程是程序的一次执行过程，是临时的，有生命期的，是动态产生，动态消亡的；<br>并发性：任何进程都可以同其他进程一起并发执行；<br>独立性：进程是系统进行资源分配和调度的一个独立单位；<br>结构性：进程由程序、数据和进程控制块三部分组成。</p>
<ol>
<li>线程<br>线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。<br>一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。<br>一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成,<br>而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</li>
</ol>
<h3 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h3><ol>
<li>线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；</li>
<li>一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；</li>
<li>进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；</li>
<li>调度和切换：线程上下文切换比进程上下文切换要快得多。<br>总之，线程和进程都是一种抽象的概念，线程是一种比进程更小的抽象，线程和进程都可用于实现并发。<br>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。它相当于一个进程里只有一个线程，进程本身就是线程。所以线程有时被称为轻量级进程(Lightweight Process，LWP）。<br>后来，随着计算机的发展，对多个任务之间上下文切换的效率要求越来越高，就抽象出一个更小的概念——线程，一般一个进程会有多个(也可是一个)线程。</li>
</ol>
<h3 id="多线程与多核"><a href="#多线程与多核" class="headerlink" title="多线程与多核"></a>多线程与多核</h3><p>很多操作系统的书都说“同一时间点只有一个任务在执行”,其实“同一时间点只有一个任务在执行”这句话是不准确的，至少它是不全面的。那多核处理器的情况下，线程是怎样执行呢？这就需要了解内核线程。<br>多核(心)处理器是指在一个处理器上集成多个运算核心从而提高计算能力，也就是有多个真正并行计算的处理核心，每一个处理核心对应一个内核线程。<br>内核线程（Kernel Thread， KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器对线程进行调度，并负责将线程的任务映射到各个处理器上。一般一个处理核心对应一个内核线程，比如单核处理器对应一个内核线程，双核处理器对应两个内核线程，四核处理器对应四个内核线程。</p>
<p>现在的电脑一般是双核四线程、四核八线程，是采用超线程技术将一个物理处理核心模拟成两个逻辑处理核心，对应两个内核线程，所以在操作系统中看到的CPU数量是实际物理CPU数量的两倍，如你的电脑是双核四线程，打开“任务管理器\性能”可以看到4个CPU的监视器，四核八线程可以看到8个CPU的监视器。</p>
<p>超线程技术就是利用特殊的硬件指令，把一个物理芯片模拟成两个逻辑处理核心，让单个处理器都能使用线程级并行计算，进而兼容多线程操作系统和软件，减少了CPU的闲置时间，提高的CPU的运行效率。这种超线程技术(如双核四线程)由处理器硬件的决定，同时也需要操作系统的支持才能在计算机中表现出来。</p>
<p>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口——轻量级进程（Light Weight Process，LWP），轻量级进程就是我们通常意义上所讲的线程(我们在这称它为用户线程)，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。用户线程与内核线程的对应关系有三种模型：一对一模型、多对一模型、多对多模型.</p>
<ul>
<li>一对一模型<br>一个用户线程就唯一地对应一个内核线程(反过来不一定成立，一个内核线程不一定有对应的用户线程)。这样，如果CPU没有采用超线程技术(如四核四线程的计算机)，一个用户线程就唯一地映射到一个物理CPU的线程，线程之间的并发是真正的并发。一对一模型使用户线程具有与内核线程一样的优点，一个线程因某种原因阻塞时其他线程的执行不受影响；此处，一对一模型也可以让多线程程序在多处理器的系统上有更好的表现。<br>但一对一模型也有两个缺点：<br>1.许多操作系统限制了内核线程的数量，因此一对一模型会使用户线程的数量受到限制；<br>2.许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li>
<li>多对一模型<br>多对一模型将多个用户线程映射到一个内核线程上，线程之间的切换由用户态的代码来进行，因此相对一对一模型，多对一模型的线程切换速度要快许多；此外，多对一模型对用户线程的数量几乎无限制。<br>但多对一模型也有两个缺点：<br>1.如果其中一个用户线程阻塞，那么其它所有线程都将无法执行，因为此时内核线程也随之阻塞了；<br>2.在多处理器系统上，处理器数量的增加对多对一模型的线程性能不会有明显的增加，因为所有的用户线程都映射到一个处理器上了。</li>
<li>多对多模型<br>多对多模型结合了一对一模型和多对一模型的优点，将多个用户线程映射到多个内核线程上。<br>多对多模型的优点有：<br>1.一个用户线程的阻塞不会导致所有线程的阻塞，因为此时还有别的内核线程被调度来执行；<br>2.多对多模型对用户线程的数量没有限制；<br>3.在多处理器的操作系统中，多对多模型的线程也能得到一定的性能提升，但提升的幅度不如一对一模型的高。<br>在现在流行的操作系统中，大都采用多对多的模型。</li>
</ul>
<h3 id="进程和线程的状态"><a href="#进程和线程的状态" class="headerlink" title="进程和线程的状态"></a>进程和线程的状态</h3><p>当线程的数量小于处理器的数量时，线程的并发是真正的并发，不同的线程运行在不同的处理器上。但当线程的数量大于处理器的数量时，线程的并发会受到一些阻碍，此时并不是真正的并发，因为此时至少有一个处理器会运行多个线程。<br>在单个处理器运行多个线程时，并发是一种模拟出来的状态。操作系统采用时间片轮转的方式轮流执行每一个线程。现在，几乎所有的现代操作系统采用的都是时间片轮转的抢占式调度方式，如我们熟悉的Unix、Linux、Windows及Mac OS X等流行的操作系统。<br>线程是程序执行的最小单位，也是任务执行的最小单位。在早期只有进程的操作系统中，进程有五种状态，创建、就绪、运行、阻塞(等待)、退出。早期的进程相当于现在的只有单个线程的进程，那么现在的多线程也有五种状态，现在的多线程的生命周期与早期进程的生命周期类似。</p>
<ul>
<li>进程的状态<br>进程在运行过程有三种状态：就绪、运行、阻塞，创建和退出状态描述的是进程的创建过程和退出过程。<br>创建：进程正在创建，还不能运行。操作系统在创建进程时要进行的工作包括分配和建立进程控制块表项、建立资源表格并分配资源、加载程序并建立地址空间；<br>就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来；<br>运行：此线程正在执行，正在占用时间片；<br>阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；<br>退出：进程已结束，所以也称结束状态，释放操作系统分配的资源。</li>
<li>线程的状态<br>创建：一个新的线程被创建，等待该线程被调用执行；<br>就绪：时间片已用完，此线程被强制暂停，等待下一个属于他的时间片到来；<br>运行：此线程正在执行，正在占用时间片；<br>阻塞：也叫等待状态，等待某一事件(如IO或另一个线程)执行完；<br>退出：一个线程完成任务或者其他终止条件发生，该线程终止进入退出状态，退出状态释放该线程所分配的资源。</li>
</ul>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>优先级调度(Priority Schedule)决定了线程按照什么顺序轮流执行.线程拥有各自的线程优先级(Thread Priority),线程的优先级可以由用户手动设置，此外系统也会根据不同情形调整优先级。频繁等待的线程称之为IO密集型线程(IO Bound Thread)，而把很少等待的线程称之为CPU密集型线程(CPU Bound Thread)。IO密集型线程总是比CPU密集型线程更容易得到优先级的提升。</p>
<p>线程饿死:优先级较低的线程，在它执行之前总是有比它优先级更高的线程等待执行，因此这个低优先级的线程始终得不到执行。</p>
<p>在优先级调度环境下，线程优先级的改变有三种方式： </p>
<ol>
<li>用户指定优先级； </li>
<li>根据进入等待状态的频繁程度提升或降低优先级(由操作系统完成)； </li>
<li>长时间得不到执行而被提升优先级。</li>
</ol>
<h3 id="线程安全与锁"><a href="#线程安全与锁" class="headerlink" title="线程安全与锁"></a>线程安全与锁</h3><p>多个线程对同一数据的进行访问时需要同步，以确保线程安全。<br>同步(synchronization)就是指一个线程访问数据时，其它线程不得对同一个数据进行访问，即同一时刻只能有一个线程访问该数据，当这一线程访问结束时其它线程才能对这它进行访问。<br>同步最常见的方式就是使用锁(Lock)，也称为线程锁。锁是一种非强制机制，每一个线程在访问数据或资源之前，首先试图获取(Acquire)锁，并在访问结束之后释放(Release)锁。在锁被占用时试图获取锁，线程会进入等待状态，直到锁被释放再次变为可用。</p>
<ol>
<li><p>二元信号量<br>二元信号量(Binary Semaphore)是一种最简单的锁，它有两种状态：占用和非占用。它适合只能被唯一一个线程独占访问的资源。当二元信号量处于非占用状态时，第一个试图获取该二元信号量锁的线程会获得该锁，并将二元信号量锁置为占用状态，之后其它试图获取该二元信号量的线程会进入等待状态，直到该锁被释放。</p>
</li>
<li><p>信号量<br>多元信号量允许多个线程访问同一个资源，多元信号量简称信号量(Semaphore)，对于允许多个线程并发访问的资源，这是一个很好的选择。一个初始值为N的信号量允许N个线程并发访问。线程访问资源时首先获取信号量锁，进行如下操作：<br>1). 将信号量的值减1；<br>2). 如果信号量的值小于0，则进入等待状态，否则继续执行；<br>访问资源结束之后，线程释放信号量锁，进行如下操作：<br>1). 将信号量的值加1；<br>2). 如果信号量的值小于1(等于0)，唤醒一个等待中的线程；</p>
</li>
<li><p>互斥量<br>互斥量(Mutex)和二元信号量类似，资源仅允许一个线程访问。与二元信号量不同的是，信号量在整个系统中可以被任意线程获取和释放，也就是说，同一个信号量可以由一个线程获取而由另一线程释放。而互斥量则要求哪个线程获取了该互斥量锁就由哪个线程释放，其它线程越俎代庖释放互斥量是无效的。</p>
</li>
<li><p>临界区<br>临界区(Critical Section)是一种比互斥量更加严格的同步手段。互斥量和信号量在系统的任何进程都是可见的，也就是说一个进程创建了一个互斥量或信号量，另一进程试图获取该锁是合法的。而临界区的作用范围仅限于本进程，其它的进程无法获取该锁。除此之处，临界区与互斥量的性质相同。</p>
</li>
<li><p>读写锁<br>读写锁(Read-Write Lock)允许多个线程同时对同一个数据进行读操作，而只允许一个线程进行写操作。这是因为读操作不会改变数据的内容，是安全的；而写操作会改变数据的内容，是不安全的。对同一个读写锁，有两种获取方式：共享的(Shared)和独占的(Exclusive)。当锁处于自由状态时，试图以任何一种方式获取锁都能成功，并将锁置为对应的状态；如果锁处于共享状态，其它线程以共享方式获取该锁，仍然能成功，此时该锁分配给了多个线程；如果其它线程试图如独占的方式获取处于共享状态的锁，它必须等待所有线程释放该锁；处于独占状态的锁阻止任何线程获取该锁，不论它们以何种方式。获取读写锁的方式总结如下：<br>|读写锁的状态    |以共享方式获取    |以独占方式获取|<br>|————|—————|————-|<br>|自由    |成功    |成功|<br>|共享    |成功    |等待|<br>|独占    |等待    |等待|</p>
</li>
</ol>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>任何程序至少有一个线程，即使你没有主动地创建线程，程序从一开始执行就有一个默认的线程，被称为主线程(main thread)，只有一个线程的程序称为单线程程序。</p>
<h3 id="线程使用"><a href="#线程使用" class="headerlink" title="线程使用"></a>线程使用</h3><ol>
<li>创建线程<br>在Windows平台，Windows API提供了对多线程的支持。Windows中线程相关的操作和方法：<code>CreateThread与CloseHandle</code>.<br>CreateThread用于创建一个线程，其函数原型如下：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function">HANDLE WINAPI <span class="title">CreateThread</span><span class="params">(</span></span></div><div class="line"><span class="function"><span class="params">    LPSECURITY_ATTRIBUTES   lpThreadAttributes, <span class="comment">//线程安全相关的属性，常置为NULL</span></span></span></div><div class="line"><span class="function"><span class="params">    SIZE_T                  dwStackSize,        <span class="comment">//新线程的初始化栈在大小，可设置为0</span></span></span></div><div class="line"><span class="function"><span class="params">    LPTHREAD_START_ROUTINE  lpStartAddress,     <span class="comment">//被线程执行的回调函数，也称为线程函数</span></span></span></div><div class="line"><span class="function"><span class="params">    LPVOID                  lpParameter,        <span class="comment">//传入线程函数的参数，不需传递参数时为NULL</span></span></span></div><div class="line"><span class="function"><span class="params">    DWORD                   dwCreationFlags,    <span class="comment">//控制线程创建的标志</span></span></span></div><div class="line"><span class="function"><span class="params">    LPDWORD                 lpThreadId          <span class="comment">//传出参数，用于获得线程ID，如果为NULL则不返回线程ID</span></span></span></div><div class="line"><span class="function"><span class="params">)</span></span>;</div></pre></td></tr></table></figure>
<p><strong>说明：</strong><br>lpThreadAttributes：指向SECURITY_ATTRIBUTES结构的指针，决定返回的句柄是否可被子进程继承，如果为NULL则表示返回的句柄不能被子进程继承。<br>dwStackSize ：线程栈的初始化大小，字节单位。系统分配这个值对<br>lpStartAddress：指向一个函数指针，该函数将被线程调用执行。因此该函数也被称为线程函数(ThreadProc)，是线程执行的起始地址，线程函数是一个回调函数，由操作系统在线程中调用。</p>
<p>线程函数的原型如下：<br>DWORD WINAPI ThreadProc(LPVOID lpParameter);    //lpParameter是传入的参数，是一个空指针<br>lpParameter：传入线程函数(ThreadProc)的参数，不需传递参数时为NULL<br>dwCreationFlags：控制线程创建的标志，有三个类型，0：线程创建后立即执行线程；CREATE_SUSPENDED：线程创建后进入就绪状态，直到线程被唤醒时才调用；STACK_SIZE_PARAM_IS_A_RESERVATION：dwStackSize 参数指定线程初始化栈的大小，如果STACK_SIZE_PARAM_IS_A_RESERVATION标志未指定，dwStackSize将会设为系统预留的值。<br>返回值：如果线程创建成功，则返回这个新线程的句柄，否则返回NULL。如果线程创建失败，可通过GetLastError函数获得错误信息。<br>BOOL WINAPI CloseHandle(HANDLE hObject);        //关闭一个被打开的对象句柄<br>可用这个函数关闭创建的线程句柄，如果函数执行成功则返回true(非0),如果失败则返回false(0)，如果执行失败可调用GetLastError.函数获得错误信息。</p>
<p>创建一个简单的线程:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="comment">//线程函数</span></div><div class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"子线程:i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        Sleep(<span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//创建一个线程</span></div><div class="line">    HANDLE thread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">//关闭线程</span></div><div class="line">    CloseHandle(thread);</div><div class="line">    <span class="comment">//主线程的执行路径</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程:i = "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        Sleep(<span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在线程函数中传入参数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_LINE   40</span></div><div class="line"><span class="comment">//定义线程函数传入参数的结构体</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">THREAD_DATA</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> nMaxNum;</div><div class="line">    <span class="keyword">char</span> strThreadName[NAME_LINE];</div><div class="line">    __THREAD_DATA() : nMaxNum(<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(strThreadName, <span class="number">0</span>, NAME_LINE * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</div><div class="line">    &#125;</div><div class="line">&#125;THREAD_DATA;</div><div class="line"></div><div class="line"><span class="comment">//线程函数</span></div><div class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    THREAD_DATA* pThreadData = (THREAD_DATA*)lpParameter;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pThreadData-&gt;nMaxNum; ++ i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; pThreadData-&gt;strThreadName &lt;&lt; <span class="string">" --- "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        Sleep(<span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//初始化线程数据</span></div><div class="line">    THREAD_DATA threadData1, threadData2;</div><div class="line">    threadData1.nMaxNum = <span class="number">5</span>;</div><div class="line">    <span class="built_in">strcpy</span>(threadData1.strThreadName, <span class="string">"线程1"</span>);</div><div class="line">    threadData2.nMaxNum = <span class="number">10</span>;</div><div class="line">    <span class="built_in">strcpy</span>(threadData2.strThreadName, <span class="string">"线程2"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//创建第一个子线程</span></div><div class="line">    HANDLE hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, &amp;threadData1, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">//创建第二个子线程</span></div><div class="line">    HANDLE hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, &amp;threadData2, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">//关闭线程</span></div><div class="line">    CloseHandle(hThread1);</div><div class="line">    CloseHandle(hThread2);</div><div class="line"></div><div class="line">    <span class="comment">//主线程的执行路径</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程 === "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        Sleep(<span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程同步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_LINE   40</span></div><div class="line"><span class="comment">//定义线程函数传入参数的结构体</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">THREAD_DATA</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> nMaxNum;</div><div class="line">    <span class="keyword">char</span> strThreadName[NAME_LINE];</div><div class="line"></div><div class="line">    __THREAD_DATA() : nMaxNum(<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(strThreadName, <span class="number">0</span>, NAME_LINE * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</div><div class="line">    &#125;</div><div class="line">&#125;THREAD_DATA;</div><div class="line"></div><div class="line">HANDLE g_hMutex = <span class="literal">NULL</span>;     <span class="comment">//互斥量</span></div><div class="line"></div><div class="line"><span class="comment">//线程函数</span></div><div class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    THREAD_DATA* pThreadData = (THREAD_DATA*)lpParameter;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pThreadData-&gt;nMaxNum; ++ i)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//请求获得一个互斥量锁</span></div><div class="line">        WaitForSingleObject(g_hMutex, INFINITE);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; pThreadData-&gt;strThreadName &lt;&lt; <span class="string">" --- "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        Sleep(<span class="number">100</span>);</div><div class="line">        <span class="comment">//释放互斥量锁</span></div><div class="line">        ReleaseMutex(g_hMutex);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//创建一个互斥量</span></div><div class="line">    g_hMutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//初始化线程数据</span></div><div class="line">    THREAD_DATA threadData1, threadData2;</div><div class="line">    threadData1.nMaxNum = <span class="number">5</span>;</div><div class="line">    <span class="built_in">strcpy</span>(threadData1.strThreadName, <span class="string">"线程1"</span>);</div><div class="line">    threadData2.nMaxNum = <span class="number">10</span>;</div><div class="line">    <span class="built_in">strcpy</span>(threadData2.strThreadName, <span class="string">"线程2"</span>);</div><div class="line"></div><div class="line">    <span class="comment">//创建第一个子线程</span></div><div class="line">    HANDLE hThread1 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, &amp;threadData1, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">//创建第二个子线程</span></div><div class="line">    HANDLE hThread2 = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, ThreadProc, &amp;threadData2, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="comment">//关闭线程</span></div><div class="line">    CloseHandle(hThread1);</div><div class="line">    CloseHandle(hThread2);</div><div class="line"></div><div class="line">    <span class="comment">//主线程的执行路径</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++ i)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//请求获得一个互斥量锁</span></div><div class="line">        WaitForSingleObject(g_hMutex, INFINITE);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程 === "</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        Sleep(<span class="number">100</span>);</div><div class="line">        <span class="comment">//释放互斥量锁</span></div><div class="line">        ReleaseMutex(g_hMutex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>模拟火车售票系统<br>SaleTickets.h :</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strstream&gt; </span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NAME_LINE   40</span></div><div class="line"></div><div class="line"><span class="comment">//定义线程函数传入参数的结构体</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">TICKET</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="keyword">int</span> nCount;</div><div class="line">    <span class="keyword">char</span> strTicketName[NAME_LINE];</div><div class="line"></div><div class="line">    __TICKET() : nCount(<span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(strTicketName, <span class="number">0</span>, NAME_LINE * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</div><div class="line">    &#125;</div><div class="line">&#125;TICKET;</div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">THD_DATA</span></span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    TICKET* pTicket;</div><div class="line">    <span class="keyword">char</span> strThreadName[NAME_LINE];</div><div class="line"></div><div class="line">    __THD_DATA() : pTicket(<span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">memset</span>(strThreadName, <span class="number">0</span>, NAME_LINE * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</div><div class="line">    &#125;</div><div class="line">&#125;THD_DATA;</div><div class="line"></div><div class="line"></div><div class="line"> <span class="comment">//基本类型数据转换成字符串</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></div><div class="line"><span class="class"><span class="title">string</span> <span class="title">convertToString</span>(<span class="title">const</span> <span class="title">T</span> <span class="title">val</span>)</span></div><div class="line"><span class="class">&#123;</span></div><div class="line">    <span class="built_in">string</span> s;</div><div class="line">    <span class="built_in">std</span>::strstream ss;</div><div class="line">    ss &lt;&lt; val;</div><div class="line">    ss &gt;&gt; s;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//售票程序</span></div><div class="line"><span class="function">DWORD WINAPI <span class="title">SaleTicket</span><span class="params">(LPVOID lpParameter)</span></span>;</div></pre></td></tr></table></figure>
<p>SaleTickets.cpp ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SaleTickets.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="keyword">extern</span> HANDLE g_hMutex;</div><div class="line"></div><div class="line"><span class="comment">//售票程序</span></div><div class="line"><span class="function">DWORD WINAPI <span class="title">SaleTicket</span><span class="params">(LPVOID lpParameter)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line"></div><div class="line">    THD_DATA* pThreadData = (THD_DATA*)lpParameter;</div><div class="line">    TICKET* pSaleData = pThreadData-&gt;pTicket;</div><div class="line">    <span class="keyword">while</span>(pSaleData-&gt;nCount &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">//请求获得一个互斥量锁</span></div><div class="line">        WaitForSingleObject(g_hMutex, INFINITE);</div><div class="line">        <span class="keyword">if</span> (pSaleData-&gt;nCount &gt; <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">            <span class="built_in">cout</span> &lt;&lt; pThreadData-&gt;strThreadName &lt;&lt; <span class="string">"出售第"</span> &lt;&lt; pSaleData-&gt;nCount -- &lt;&lt; <span class="string">"的票,"</span>;</div><div class="line">            <span class="keyword">if</span> (pSaleData-&gt;nCount &gt;= <span class="number">0</span>) &#123;</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"出票成功!剩余"</span> &lt;&lt; pSaleData-&gt;nCount &lt;&lt; <span class="string">"张票."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"出票失败！该票已售完。"</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        Sleep(<span class="number">10</span>);</div><div class="line">        <span class="comment">//释放互斥量锁</span></div><div class="line">        ReleaseMutex(g_hMutex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0L</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//售票系统</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test2</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="comment">//创建一个互斥量</span></div><div class="line">    g_hMutex = CreateMutex(<span class="literal">NULL</span>, FALSE, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">    <span class="comment">//初始化火车票</span></div><div class="line">    TICKET ticket;</div><div class="line">    ticket.nCount = <span class="number">100</span>;</div><div class="line">    <span class="built_in">strcpy</span>(ticket.strTicketName, <span class="string">"北京--&gt;赣州"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> THREAD_NUMM = <span class="number">8</span>;</div><div class="line">    THD_DATA threadSale[THREAD_NUMM];</div><div class="line">    HANDLE hThread[THREAD_NUMM];</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_NUMM; ++ i)</div><div class="line">    &#123;</div><div class="line">        threadSale[i].pTicket = &amp;ticket;</div><div class="line">        <span class="built_in">string</span> strThreadName = convertToString(i);</div><div class="line"></div><div class="line">        strThreadName = <span class="string">"窗口"</span> + strThreadName;</div><div class="line"></div><div class="line">        <span class="built_in">strcpy</span>(threadSale[i].strThreadName, strThreadName.c_str());</div><div class="line"></div><div class="line">        <span class="comment">//创建线程</span></div><div class="line">        hThread[i] = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SaleTicket, &amp;threadSale[i], <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">        <span class="comment">//请求获得一个互斥量锁</span></div><div class="line">        WaitForSingleObject(g_hMutex, INFINITE);</div><div class="line">        <span class="built_in">cout</span> &lt;&lt; threadSale[i].strThreadName &lt;&lt; <span class="string">"开始出售 "</span> &lt;&lt; threadSale[i].pTicket-&gt;strTicketName &lt;&lt; <span class="string">" 的票..."</span> &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">        <span class="comment">//释放互斥量锁</span></div><div class="line">        ReleaseMutex(g_hMutex);</div><div class="line"></div><div class="line">        <span class="comment">//关闭线程</span></div><div class="line">        CloseHandle(hThread[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    system(<span class="string">"pause"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><h3 id="进程间同步方式"><a href="#进程间同步方式" class="headerlink" title="进程间同步方式"></a>进程间同步方式</h3><ol>
<li>Mutex（互斥）可以跨进城使用</li>
<li>Semphore（信号量）可以跨进城使用等</li>
</ol>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><p>进程间通信又称IPC(Inter-Process Communication),指多个进程之间相互通信，交换信息的方法。<br>进程间通讯(IPC)方法主要有以下几种: 管道/FIFO/共享内存/消息队列/信号<br>根据进程通信时信息量大小的不同,可以将进程通信划分为两大类型:<br>1、低级通信,控制信息的通信(主要用于进程之间的同步,互斥,终止和挂起等等控制信息的传递)<br>2、高级通信,大批数据信息的通信(主要用于进程间数据块数据的交换和共享,常见的高级通信有管道,消息队列,共享内存等). </p>
<p>1.管道有命名管道和非命名管道(即匿名管道)之分，非命名管道(即匿名管道)只能用于父子进程通讯，命名管道可用于非父子进程，命名管道就是FIFO，管道是先进先出的通讯方式.<br>管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。<br>命名管道 (named pipe) ： 命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<p>2.消息队列是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。<br>需要注意的是，消息队列是用创建文件的方式建立的，如果一个进程向某个消息队列中写入了数据之后，另一个进程并没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列中的数据并没有消失，也就是说下次再从这个消息队列读数据的时候，就是上次的数据！!<br>消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。<br>消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。  </p>
<p>3.信号量，它与WINDOWS下的信号量是一样的.<br>信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。不是用于交换大批数据,而用于多线程之间的同步.常作为一种锁机制,防止某进程在访问资源时其它进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p>4.共享内存，类似于WINDOWS下的DLL中的共享变量，但LINUX下的共享内存区不需要像DLL这样的东西，只要首先创建一个共享内存区，其它进程按照一定的步骤就能访问到这个共享内存区中的数据，当然可读可写.<br>共享内存( shared memory )：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。<br>共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。<br>信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。</p>
<p>套接字( socket ) ：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul>
<li><a href="http://blog.csdn.net/luoweifu/article/details/46595285" target="_blank" rel="external">编程思想之多线程与多进程</a></li>
<li><a href="https://www.zhihu.com/question/36529093/answer/67959045" target="_blank" rel="external">知乎</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/21/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/21/">21</a><span class="page-number current">22</span><a class="page-number" href="/page/23/">23</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/23/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvin</p>
              <p class="site-description motion-element" itemprop="description">Learn and live.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">141</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arvin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
