<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simple &amp; Freedom</title>
  
  <subtitle>Learn and live.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://arvin-he.github.io/"/>
  <updated>2018-02-08T07:15:32.233Z</updated>
  <id>http://arvin-he.github.io/</id>
  
  <author>
    <name>Arvin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>web常见攻击手段</title>
    <link href="http://arvin-he.github.io/2018/02/08/web-netsafe-2018-02-08/"/>
    <id>http://arvin-he.github.io/2018/02/08/web-netsafe-2018-02-08/</id>
    <published>2018-02-08T06:38:57.000Z</published>
    <updated>2018-02-08T07:15:32.233Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF攻击"><a href="#CSRF攻击" class="headerlink" title="CSRF攻击"></a>CSRF攻击</h1><p>CSRF是Cross Site Request Forgery的缩写，翻译过来就是跨站请求伪造。 也被称为 one click attack/session riding，缩写为：CSRF/XSRF。<br>可以这么理解CSRF攻击：从网站A中发起一个到网站B的请求，而这个请求是经过伪装的， 伪装的目的就是让请求看起来像是从网站B中发起的， 也就是说，让B网站所在的服务器端误以为该请求是从自己网站发起的，而不是从A网站发起的。当然，请求一般都是恶意的。</p><h2 id="浏览器的跨域访问限制"><a href="#浏览器的跨域访问限制" class="headerlink" title="浏览器的跨域访问限制"></a>浏览器的跨域访问限制</h2><h3 id="Cookie跨域"><a href="#Cookie跨域" class="headerlink" title="Cookie跨域"></a>Cookie跨域</h3><p>cookie可以跨二级域名来访问，例如在www.cmj.com所在的web应用程序创建了一个cookie， 在cs.cmj.com这样的二级域名对应的应用程序中可以访问，当然你在创建cookie的时候需要指出Domain属性为cmj.com。 其他情况下的不同域名就无法访问这个cookie了。</p><h3 id="JavaScript跨域"><a href="#JavaScript跨域" class="headerlink" title="JavaScript跨域"></a>JavaScript跨域</h3><p>js跨域是指通过js在不同的域之间进行数据传输或通信，比如用ajax向一个不同的域请求数据， 或者通过js获取页面中不同域的框架中(iframe)的数据。只要协议、域名、端口有任何一个不同，都被当作是不同的域。</p><p><img src="/2018/02/08/web-netsafe-2018-02-08/1.png" alt=""></p><h3 id="通过jsonp跨域"><a href="#通过jsonp跨域" class="headerlink" title="通过jsonp跨域"></a>通过jsonp跨域</h3><p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。 但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。</p><p>如果你的页面使用jquery，那么通过它封装的方法就能很方便的来进行jsonp操作了。 普通的jquery的ajax调用方法基本都采用这个方式，所以就可以调用不同域名实现的API了。</p><p>$.getJSON方法会自动判断是否跨域，不跨域的话，就调用普通的ajax方法； 跨域的话，则会以异步加载js文件的形式来调用jsonp的回调函数。</p><h3 id="通过document-domain来跨子域"><a href="#通过document-domain来跨子域" class="headerlink" title="通过document.domain来跨子域"></a>通过document.domain来跨子域</h3><p>浏览器的同源策略，不能通过ajax的方法去请求不同源中的文档。</p><p>我们只要把<code>http://www.example.com/a.html</code> 和 <code>http://example.com/b.html</code>这两个页面的document.domain都设成相同的域名就可以了。</p><h3 id="CSRF攻击步骤"><a href="#CSRF攻击步骤" class="headerlink" title="CSRF攻击步骤"></a>CSRF攻击步骤</h3><p>要完成一次CSRF攻击，受害者必须依次完成两个步骤：</p><p>登录受信任网站A，并在本地生成Cookie。<br>在不登出A的情况下，访问危险网站B。</p><h3 id="CSRF防御"><a href="#CSRF防御" class="headerlink" title="CSRF防御"></a>CSRF防御</h3><p>防御效果是从服务端着手效果比较好，现在一般的CSRF防御也都在服务端进行。</p><h4 id="Cookie-Hashing"><a href="#Cookie-Hashing" class="headerlink" title="Cookie Hashing"></a>Cookie Hashing</h4><p><strong>所有表单</strong>都包含<strong>同一个伪随机值</strong>，这可能是最简单的解决方案了， 因为攻击者不能获得第三方的Cookie(理论上)，所以表单中的数据也就构造失败了。</p><p>这个方法个人觉得已经可以杜绝99%的CSRF攻击了，那还有1%呢….由于用户的Cookie很容易由于网站的XSS漏洞而被盗取，这就另外的1%。</p><h4 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h4><p>每次的用户提交都需要用户在表单中填写一个图片上的随机字符串，这个方案可以完全解决CSRF，但个人觉得在易用性方面似乎不是太好。</p><h1 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h1><p>XSS攻击：跨站脚本攻击(Cross-Site Scripting),XSS是一种常见的web安全漏洞，它允许攻击者将恶意代码植入到提供给其它用户使用的页面中。</p><h2 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h2><h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>主要出现在让用户输入数据，供其他浏览此页的用户进行查看的地方，包括留言、评论、博客日志和各类表单等。</p><p>应用程序从数据库中查询数据，在页面中显示出来，攻击者在相关页面输入恶意的脚本数据后，用户浏览此类页面时就可能受到攻击。</p><p>这个流程简单可以描述为:恶意用户的Html输入Web程序-&gt;进入数据库-&gt;Web程序-&gt;用户浏览器。</p><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>将脚本代码加入URL地址的请求参数里，请求参数进入程序后在页面直接输出，用户点击类似的恶意链接就可能受到攻击。</p><h2 id="XSS攻击主要使用的手段和目的"><a href="#XSS攻击主要使用的手段和目的" class="headerlink" title="XSS攻击主要使用的手段和目的"></a>XSS攻击主要使用的手段和目的</h2><ul><li>盗用cookie，获取敏感信息。</li><li>利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。</li><li>利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击者）用户的身份执行一些管理动作， 或执行一些如:发微博、加好友、发私信等常规操作，前段时间新浪微博就遭遇过一次XSS。</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li><li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果</li></ul><h2 id="XSS原理"><a href="#XSS原理" class="headerlink" title="XSS原理"></a>XSS原理</h2><p>Web应用未对用户提交请求的数据做充分的检查过滤，允许用户在提交的数据中掺入HTML代码(最主要的是“&gt;”, “&lt;”)， 并将未经转义的恶意代码输出到第三方用户的浏览器解释执行，是导致XSS漏洞的产生原因。</p><h2 id="预防XSS"><a href="#预防XSS" class="headerlink" title="预防XSS"></a>预防XSS</h2><p>答案很简单，坚决不要相信用户的任何输入，并过滤掉输入中的所有特殊字符。这样就能消灭绝大部分的XSS攻击。</p><p>目前防御XSS主要有如下几种方式：</p><ul><li>过滤特殊字符<br>避免XSS的方法之一主要是将用户所提供的内容进行过滤。</li><li>使用HTTP头指定类型<br>这样就可以让浏览器解析javascript代码，而不会是html输出。</li></ul><p>总之, XSS漏洞是相当有危害的，在开发Web应用的时候，一定要记住过滤数据，特别是在输出到客户端之前，这是现在行之有效的防止XSS的手段。</p><h1 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h1><p>SQL注入攻击（SQL Injection），简称注入攻击，是Web开发中最常见的一种安全漏洞。 可以用它来从数据库获取敏感信息，或者利用数据库的特性执行添加用户，导出文件等一系列恶意操作， 甚至有可能获取数据库乃至系统用户最高权限。</p><p>而造成SQL注入的原因是因为<strong>程序没有有效过滤用户的输入</strong>，使攻击者成功的向服务器<strong>提交恶意的SQL查询代码</strong>， 程序在接收后并错误的将攻击者的输入作为查询语句的一部分执行，导致原始的查询逻辑被改变， 额外的执行了攻击者精心构造的恶意代码。</p><h2 id="如何预防SQL注入"><a href="#如何预防SQL注入" class="headerlink" title="如何预防SQL注入"></a>如何预防SQL注入</h2><p>永远不要信任外界输入的数据，特别是来自于用户的数据，包括选择框、表单隐藏域和 cookie。 就如上面的第一个例子那样，就算是正常的查询也有可能造成灾难。</p><p>下面这些建议或许对防治SQL注入有一定的帮助：</p><ul><li>严格限制Web应用的数据库的操作权限，给此用户提供仅仅能够满足其工作的最低权限，从而最大限度的减少注入攻击对数据库的危害。</li><li>检查输入的数据是否具有所期望的数据格式，严格限制变量的类型，例如使用regexp包进行一些匹配处理， 或者使用strconv包对字符串转化成其他基本类型的数据进行判断。</li><li>对进入数据库的特殊字符（’”\尖括号&amp;*;等）进行转义处理，或编码转换。</li><li>所有的查询语句建议使用数据库提供的参数化查询接口，参数化的语句使用参数而不是将用户输入变量嵌入到SQL语句中， 比如Java中的PrepareStatement。</li><li>在应用发布之前建议使用专业的SQL注入检测工具进行检测， 以及时修补被发现的SQL注入漏洞。网上有很多这方面的开源工具，例如sqlmap、SQLninja等。</li><li>避免网站打印出SQL错误信息，比如类型错误、字段不匹配等，把代码里的SQL语句暴露出来，以防止攻击者利用这些错误信息进行SQL注入。</li></ul><p>总之, SQL注入是危害相当大的安全漏洞。所以对于我们平常编写的Web应用，应该对于每一个小细节都要非常重视。</p><h1 id="防止表单重复提交"><a href="#防止表单重复提交" class="headerlink" title="防止表单重复提交"></a>防止表单重复提交</h1><p>在平时开发中，如果网速比较慢的情况下，用户提交表单后，发现服务器半天都没有响应， 那么用户可能会以为是自己没有提交表单，就会再点击提交按钮重复提交表单，我们在开发中必须防止表单重复提交。</p><h2 id="重复提交的几个场景"><a href="#重复提交的几个场景" class="headerlink" title="重复提交的几个场景"></a>重复提交的几个场景</h2><ul><li>场景一<br>在网络延迟的情况下让用户有时间点击多次submit按钮导致表单重复提交</li><li>场景二<br>表单提交后用户点击【刷新】按钮导致表单重复提交，点击浏览器的刷新按钮， 就是把浏览器上次做的事情再做一次，因为这样也会导致表单重复提交。</li><li>场景三<br>用户提交表单后，使用浏览器【后退】按钮重复之前的操作，导致重复提交表单。</li></ul><h2 id="表单重复提交解决办法"><a href="#表单重复提交解决办法" class="headerlink" title="表单重复提交解决办法"></a>表单重复提交解决办法</h2><h3 id="JavaScript方案"><a href="#JavaScript方案" class="headerlink" title="JavaScript方案"></a>JavaScript方案</h3><p>可通过javascript来防止表单重复提交，表单提交之后， 将提交按钮设置为不可用，让用户没有机会点击第二次提交按钮</p><h3 id="Session方案"><a href="#Session方案" class="headerlink" title="Session方案"></a>Session方案</h3><p>对于【场景二】和【场景三】导致表单重复提交的问题，既然客户端无法解决， 那么就在服务器端解决，在服务器端解决就需要用到session了。</p><p>具体的做法：在服务器端生成一个唯一的随机标识号，专业术语称为Token(令牌)，同时在当前用户的Session域中保存这个Token。 然后将Token发送到客户端的Form表单中，在Form表单中使用隐藏域来存储这个Token， 表单提交的时候连同这个Token一起提交到服务器端，然后在服务器端判断客户端提交上来的Token与服务器端生成的Token是否一致， 如果不一致，那就是重复提交了，此时服务器端就可以不处理重复提交的表单。如果相同则处理表单提交， 处理完后清除当前用户的Session域中存储的标识号。</p><p>在下列情况下，服务器程序将拒绝处理用户提交的表单请求：</p><ol><li>存储Session域中的Token(令牌)与表单提交的Token(令牌)不同。</li><li>当前用户的Session中不存在Token(令牌)。</li><li>用户提交的表单数据中没有Token(令牌)。</li></ol><h3 id="使用Post-Redirect-Get模式"><a href="#使用Post-Redirect-Get模式" class="headerlink" title="使用Post/Redirect/Get模式"></a>使用Post/Redirect/Get模式</h3><p>针对【场景二】和【场景三】，除了使用Session方案，还有一种方案可以实现。 这就是所谓的 Post-Redirect-Get (PRG)模式。</p><p>简言之，当用户提交了表单后，你去执行一个客户端的重定向，转到提交成功信息页面。 这能避免用户按F5导致的重复提交，而其也不会出现浏览器表单重复提交的警告，也能消除按浏览器前进和后退按导致的同样问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSRF攻击&quot;&gt;&lt;a href=&quot;#CSRF攻击&quot; class=&quot;headerlink&quot; title=&quot;CSRF攻击&quot;&gt;&lt;/a&gt;CSRF攻击&lt;/h1&gt;&lt;p&gt;CSRF是Cross Site Request Forgery的缩写，翻译过来就是跨站请求伪造。 也被称为 
      
    
    </summary>
    
      <category term="web" scheme="http://arvin-he.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://arvin-he.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>SQLAlchemy学习使用</title>
    <link href="http://arvin-he.github.io/2018/02/08/py-sqlalchemy-2018-02-08/"/>
    <id>http://arvin-he.github.io/2018/02/08/py-sqlalchemy-2018-02-08/</id>
    <published>2018-02-08T02:30:39.000Z</published>
    <updated>2018-02-08T03:59:50.174Z</updated>
    
    <content type="html"><![CDATA[<p>SQLAlchemy分为两个部分，一个是最常用的ORM对象映射，另一个是核心的SQL expression。 第一个是纯粹的ORM，后面这个不是ORM，而是DBAPI的封装，通过一些sql表达式来避免了直接写sql。 使用SQLAlchemy则可以分为三种方式。</p><ul><li>使用ORM避免直接书写sql</li><li>使用raw sql直接书写sql</li><li>使用sql expression，通过SQLAlchemy的方法写sql表达式</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>一般来讲对某个底层数据库需要安装相应的驱动，比如使用了mysql，那么需要安装python的mysql驱动，<br>有很多种选择，SQLAlchemy默认的MySQLdb/MySQL-Python，也可以使用PyMySQL,下面就用PyMySQL作为例子.<br>在centos上面安装MySQL-Python</p><ol><li>yum install mysql-devel</li><li>pip install MySQL-python</li></ol><p>安装PyMySQL: <code>pip install PyMySQL</code></p><p><strong>注意：</strong> MySQLdb仅仅支持python2，如果要支持python3，请安装PyMySQL.</p><h1 id="定义映射"><a href="#定义映射" class="headerlink" title="定义映射"></a>定义映射</h1><p>这里使用两个表来说明，一个用户表users，一个电子邮件表addresses，两者一对多的关系。我们先定义这两个映射：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</div><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, Integer, String</div><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> ForeignKey</div><div class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> relationship</div><div class="line"></div><div class="line">Base = declarative_base()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="string">"""电子邮件表"""</span></div><div class="line">    __tablename__ = <span class="string">'addresses'</span></div><div class="line"></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    email_address = Column(String(<span class="number">30</span>), nullable=<span class="keyword">False</span>)</div><div class="line">    user_id = Column(Integer, ForeignKey(<span class="string">'users.id'</span>))</div><div class="line">    user = relationship(<span class="string">"User"</span>, back_populates=<span class="string">"addresses"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;Address(email_address='&#123;&#125;')&gt;"</span>.format(self.email_address)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></div><div class="line">    <span class="string">"""用户表"""</span></div><div class="line">    __tablename__ = <span class="string">'users'</span></div><div class="line"></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    name = Column(String(<span class="number">10</span>))</div><div class="line">    fullname = Column(String(<span class="number">20</span>))</div><div class="line">    password = Column(String(<span class="number">20</span>))</div><div class="line"></div><div class="line">    addresses = relationship(<span class="string">"Address"</span>, order_by=Address.id, back_populates=<span class="string">"user"</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> <span class="string">"&lt;User(name='&#123;&#125;', fullname='&#123;&#125;', password='&#123;&#125;')&gt;"</span>.format(</div><div class="line">            self.name, self.fullname, self.password)</div></pre></td></tr></table></figure></p><h1 id="连接数据库并创建表"><a href="#连接数据库并创建表" class="headerlink" title="连接数据库并创建表"></a>连接数据库并创建表</h1><p>通过<code>create_engine()</code>可以连接数据库，另外先要提前创建test这个测试数据库：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> create_engine</div><div class="line"></div><div class="line"><span class="comment"># 下面是MySQLdb/MySQL-Python默认写法,python2中用这个</span></div><div class="line"><span class="comment"># engine = create_engine('mysql://root:mysql@127.0.0.1:3306/test', echo=True)</span></div><div class="line"></div><div class="line"><span class="comment"># 这里我使用的是PyMySQL</span></div><div class="line"><span class="comment"># echo=True是开启调试，这样当我们执行文件的时候会提示相应的文字</span></div><div class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:mysql@127.0.0.1:3306/test'</span>, echo=<span class="keyword">True</span>)</div><div class="line"><span class="comment"># 定义了表映射，而数据库里面还没有真实表，这里需要使用Base类的metadata来自动创建表</span></div><div class="line">Base.metadata.create_all(engine)</div></pre></td></tr></table></figure></p><h1 id="创建session"><a href="#创建session" class="headerlink" title="创建session"></a>创建session</h1><p>对数据库的操作<strong>必须先创建一个session</strong>，增删改查操作都有这个session负责，<br>首先我们先创建一个session工厂类，由它来负责后续的session创建<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> sessionmaker</div><div class="line">Session = sessionmaker(bind=engine)</div></pre></td></tr></table></figure></p><h1 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先使用工程类来创建一个session对象</span></div><div class="line">session = Session() </div><div class="line">ed_user = User(name=<span class="string">'ed'</span>, fullname=<span class="string">'Ed Jones'</span>, password=<span class="string">'edspassword'</span>)</div><div class="line">session.add(ed_user)</div><div class="line"><span class="comment"># 同时创建多个</span></div><div class="line">session.add_all([</div><div class="line">    User(name=<span class="string">'wendy'</span>, fullname=<span class="string">'Wendy Williams'</span>, password=<span class="string">'foobar'</span>),</div><div class="line">    User(name=<span class="string">'mary'</span>, fullname=<span class="string">'Mary Contrary'</span>, password=<span class="string">'xxg527'</span>),</div><div class="line">    User(name=<span class="string">'fred'</span>, fullname=<span class="string">'Fred Flinstone'</span>, password=<span class="string">'blah'</span>)])</div><div class="line"><span class="comment"># 提交事务</span></div><div class="line">session.commit()</div></pre></td></tr></table></figure><h1 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h1><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>在session上面调用query()方法会创建一个Query对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> user <span class="keyword">in</span> session.query(User).order_by(User.id):</div><div class="line">    print(user.name, user.fullname)</div><div class="line"></div><div class="line"><span class="comment"># 使用filter_by过滤</span></div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> session.query(User.name).filter_by(fullname=<span class="string">'Ed Jones'</span>):</div><div class="line">    print(name)</div><div class="line"></div><div class="line"><span class="comment"># 使用sqlalchemy的SQL表达式语法过滤，可以使用python语句</span></div><div class="line"><span class="keyword">for</span> name <span class="keyword">in</span> session.query(User.name).filter(User.fullname==<span class="string">'Ed Jones'</span>):</div><div class="line">    print(name)</div></pre></td></tr></table></figure></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">session.delete(ed_user)</div><div class="line">session.query(User).filter_by(name=&apos;ed&apos;).count()</div></pre></td></tr></table></figure><h1 id="关系映射"><a href="#关系映射" class="headerlink" title="关系映射"></a>关系映射</h1><h2 id="一对多的关系映射"><a href="#一对多的关系映射" class="headerlink" title="一对多的关系映射"></a>一对多的关系映射</h2><p>sqlalchemy使用ForeignKey来指明一对多的关系，表示一对多的关系时，在子表类中通过 foreign key (外键)引用父表类。然后，在父表类中通过 relationship() 方法来引用子表的类：比如一个用户可有多个邮件地址，而一个邮件地址只属于一个用户。那么就是典型的一对多或多对一关系。<br><strong>注意:</strong>两个类中都通过relationship()方法指明相互关系。</p><p>在Address类中，我们定义外键，还有对应所属的user对象<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    <span class="comment"># 在父表类中通过 relationship() 方法来引用子表的类集合</span></div><div class="line">    children = relationship(<span class="string">"Child"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'child'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    <span class="comment"># 在子表类中通过 foreign key (外键)引用父表的参考字段</span></div><div class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">'parent.id'</span>))</div></pre></td></tr></table></figure></p><p>下面通过几个例子来操作一对多的关系映射<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 先添加一个用户，并且给这个用户增加两个邮件地址</span></div><div class="line">jack = User(name=<span class="string">'jack'</span>, fullname=<span class="string">'Jack Bean'</span>, password=<span class="string">'gjffdd'</span>)</div><div class="line">jack.addresses = [Address(email_address=<span class="string">'jack@google.com'</span>),</div><div class="line">                  Address(email_address=<span class="string">'j25@yahoo.com'</span>)]</div><div class="line">session.add(jack)</div><div class="line">session.commit()</div><div class="line"></div><div class="line"><span class="comment"># 查询</span></div><div class="line">jack = session.query(User).filter_by(name=<span class="string">'jack'</span>).one()</div><div class="line"><span class="comment"># 只有在调用jack.addresses时才会调用查询邮件地址的SQL，这个是典型的懒加载模式</span></div><div class="line">jack.addresses</div><div class="line"></div><div class="line"><span class="comment"># join查询</span></div><div class="line">session.query(User).join(Address).filter(Address.email_address==<span class="string">'jack@google.com'</span>).all()</div></pre></td></tr></table></figure></p><p>有时候我们不想使用懒加载，而是要强制一次性加载某个关联数据，那么可以使用subqueryload或者joinedload<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> subqueryload</div><div class="line"></div><div class="line">jack = session.query(User).options(subqueryload(User.addresses)).filter_by(name=<span class="string">'jack'</span>).one()</div><div class="line"></div><div class="line"><span class="comment"># 推荐使用下面这种方案</span></div><div class="line"><span class="keyword">from</span> sqlalchemy.orm <span class="keyword">import</span> joinedload</div><div class="line">jack = session.query(User).options(joinedload(User.addresses)).filter_by(name=<span class="string">'jack'</span>).one()</div></pre></td></tr></table></figure></p><h2 id="多对一映射"><a href="#多对一映射" class="headerlink" title="多对一映射"></a>多对一映射</h2><p>在多对一的关系中建立双向的关系，这样的话在对方看来这就是一个多对一的关系， 在子表类中附加一个relationship()方法，并且在双方的relationship()方法中使用relationship.back_populates方法参数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    children = relationship(<span class="string">"Child"</span>, back_populates=<span class="string">"parent"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'child'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">'parent.id'</span>))</div><div class="line">    parent = relationship(<span class="string">"Parent"</span>, back_populates=<span class="string">"children"</span>)</div><div class="line">    <span class="comment"># 子表类中附加一个 relationship() 方法</span></div><div class="line">    <span class="comment"># 并且在(父)子表类的 relationship() 方法中使用 relationship.back_populates 参数</span></div></pre></td></tr></table></figure></p><p>这样的话子表将会在多对一的关系中获得父表的属性,或者可以在单一的relationship()方法中使用backref参数来代替back_populates参数， 推荐使用这种方式，可以少些几句话。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    children = relationship(<span class="string">"Child"</span>, backref=<span class="string">"parent"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'child'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">'parent.id'</span>))</div></pre></td></tr></table></figure></p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>一对一就是多对一和一对多的一个特例,只需在relationship加上一个参数uselist=False替换多的一端就是一对一<br>一对多 =&gt; 一对一:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    child = relationship(<span class="string">"Child"</span>, uselist=<span class="keyword">False</span>, backref=<span class="string">"parent"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'child'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    parent_id = Column(Integer, ForeignKey(<span class="string">'parent.id'</span>))</div></pre></td></tr></table></figure></p><p>多对一 =&gt; 一对一:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">    child_id = Column(Integer, ForeignKey(<span class="string">'child.id'</span>))</div><div class="line">    child = relationship(<span class="string">"Child"</span>, backref=backref(<span class="string">"parent"</span>, uselist=<span class="keyword">False</span>))</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'child'</span></div><div class="line">    id = Column(Integer, primary_key=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>多对多关系需要一个中间关联表,通过参数secondary来指定。backref会自动的为子表类加载同样的secondary参数,<br>所以为了简洁起见仍然推荐这种写法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, Text</div><div class="line"></div><div class="line">post_keywords = Table(<span class="string">'post_keywords'</span>,Base.metadata,</div><div class="line">    Column(<span class="string">'post_id'</span>,Integer,ForeignKey(<span class="string">'posts.id'</span>)),</div><div class="line">    Column(<span class="string">'keyword_id'</span>,Integer,ForeignKey(<span class="string">'keywords.id'</span>))</div><div class="line">)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'posts'</span></div><div class="line">    id = Column(Integer,primary_key=<span class="keyword">True</span>)</div><div class="line">    body = Column(Text)</div><div class="line">    keywords = relationship(<span class="string">'Keyword'</span>,secondary=post_keywords,backref=<span class="string">'posts'</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyword</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'keywords'</span></div><div class="line">    id = Column(Integer,primary_key = <span class="keyword">True</span>)</div><div class="line">    keyword = Column(String(<span class="number">50</span>),nullable=<span class="keyword">False</span>,unique=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p><p>如果使用back_populates，那么两个都要定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Table, Text</div><div class="line">post_keywords = Table(<span class="string">'post_keywords'</span>,Base.metadata,</div><div class="line">    Column(<span class="string">'post_id'</span>,Integer,ForeignKey(<span class="string">'posts.id'</span>)),</div><div class="line">    Column(<span class="string">'keyword_id'</span>,Integer,ForeignKey(<span class="string">'keywords.id'</span>))</div><div class="line">)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlogPost</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'posts'</span></div><div class="line">    id = Column(Integer,primary_key=<span class="keyword">True</span>)</div><div class="line">    body = Column(Text)</div><div class="line">    keywords = relationship(<span class="string">'Keyword'</span>,secondary=post_keywords,back_populates=<span class="string">"parents"</span>)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Keyword</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'keywords'</span></div><div class="line">    id = Column(Integer,primary_key = <span class="keyword">True</span>)</div><div class="line">    keyword = Column(String(<span class="number">50</span>),nullable=<span class="keyword">False</span>,unique=<span class="keyword">True</span>)</div><div class="line">    parents = relationship(<span class="string">'BlogPost'</span>,secondary=post_keywords,back_populates=<span class="string">"keywords"</span>)</div></pre></td></tr></table></figure></p><h1 id="一些重要参数"><a href="#一些重要参数" class="headerlink" title="一些重要参数"></a>一些重要参数</h1><p>relationship()函数接收的参数非常多，比如：backref，secondary，primaryjoin等等。 下面列举一下我用到的参数</p><ul><li>backref 在一对多或多对一之间建立双向关系</li><li>lazy:默认值是True, 懒加载</li><li><p>remote_side: 表中的外键引用的是自身时, 如Node类,如果想表示多对一的树形关系, 那么就可以使用remote_side</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Base)</span>:</span></div><div class="line">__tablename__ = <span class="string">'node'</span></div><div class="line">id = Column(Integer, primary_key=<span class="keyword">True</span>)</div><div class="line">parent_id = Column(Integer, ForeignKey(<span class="string">'node.id'</span>))</div><div class="line">data = Column(String(<span class="number">50</span>))</div><div class="line">parent = relationship(<span class="string">"Node"</span>, remote_side=[id])</div></pre></td></tr></table></figure></li><li><p>secondary: 多对多指定中间表关键字</p></li><li><p>order_by: 在一对多的关系中,如下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></div><div class="line"></div><div class="line">  addresses = relationship(<span class="keyword">lambda</span>: Address,</div><div class="line">                   order_by=<span class="keyword">lambda</span>: desc(Address.email),</div><div class="line">                   primaryjoin=<span class="keyword">lambda</span>: Address.user_id==User.id)</div></pre></td></tr></table></figure></li><li><p>cascade: 级联删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span><span class="params">(Base)</span>:</span></div><div class="line">    __tablename__ = <span class="string">'parent'</span></div><div class="line">    id = Column(Integer,primary_key = <span class="keyword">True</span>)</div><div class="line">    children = relationship(<span class="string">"Child"</span>,cascade=<span class="string">'all'</span>,backref=<span class="string">'parent'</span>)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete_parent</span><span class="params">()</span>:</span></div><div class="line">    session = Session()</div><div class="line">    parent = session.query(Parent).get(<span class="number">2</span>)</div><div class="line">    session.delete(parent)</div><div class="line">    session.commit()</div></pre></td></tr></table></figure></li></ul><p>不设置cascade，删除parent时，其关联的chilren不会删除，只会把chilren关联的parent.id置为空，<br>设置cascade后就可以级联删除children</p><h1 id="对象的四种状态"><a href="#对象的四种状态" class="headerlink" title="对象的四种状态"></a>对象的四种状态</h1><p>对象在session中可能存在的四种状态包括：</p><ul><li>Transient：实例还不在session中，还没有保存到数据库中去，没有数据库身份，像刚创建出来的对象比如User()，仅仅只有mapper()与之关联</li><li>Pending：用add()一个transient对象后，就变成了一个pending对象，这时候仍然没有flushed到数据库中去，直到flush发生。</li><li>Persistent：实例出现在session中而且在数据库中也有记录了，通常是通过flush一个pending实例变成Persistent或者从数据库中querying一个已经存在的实例。</li><li>Detached：一个对象它有记录在数据库中，但是不在任何session中，</li></ul><h1 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h1><p>查询：[<a href="http://docs.sqlalchemy.org/en/rel_1_1/orm/query.html" target="_blank" rel="external">http://docs.sqlalchemy.org/en/rel_1_1/orm/query.html</a>]<br>关联查询: [<a href="http://docs.sqlalchemy.org/en/rel_1_1/orm/query.html#sqlalchemy.orm.query.Query.join" target="_blank" rel="external">http://docs.sqlalchemy.org/en/rel_1_1/orm/query.html#sqlalchemy.orm.query.Query.join</a>]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 非常简单的关联查询，外键就一个，系统知道如何去关联：</span></div><div class="line">session.query(User).join(Address).filter(Address.email==”lzjun@qq.com”).all()</div><div class="line"><span class="comment"># 指定ON字段：</span></div><div class="line">q = session.query(User).join(Address, User.id==Address.user_id)</div><div class="line"><span class="comment"># 多个join</span></div><div class="line">q = session.query(User).join(<span class="string">"orders"</span>, <span class="string">"items"</span>, <span class="string">"keywords"</span>)</div><div class="line">q = session.query(User).join(User.orders).join(Order.items).join(Item.keywords)</div><div class="line"><span class="comment"># 子查询JOIN：</span></div><div class="line">address_subq = session.query(Address).\</div><div class="line">                filter(Address.email_address == <span class="string">'ed@foo.com'</span>).\</div><div class="line">                subquery()</div><div class="line"></div><div class="line">q = session.query(User).join(address_subq, User.addresses)</div><div class="line"><span class="comment"># join from:</span></div><div class="line">q = session.query(Address).select_from(User).\</div><div class="line">                join(User.addresses).\</div><div class="line">                filter(User.name == <span class="string">'ed'</span>)</div><div class="line"><span class="comment"># 和下面的SQL等价：</span></div><div class="line">SELECT address.* FROM user</div><div class="line">    JOIN address ON user.id=address.user_id</div><div class="line">    WHERE user.name = :name_1</div><div class="line"><span class="comment"># 左外连接，指定isouter=True，等价于Query.outerjoin()：</span></div><div class="line">q = session.query(Node).\</div><div class="line">        join(<span class="string">"children"</span>, <span class="string">"children"</span>, aliased=<span class="keyword">True</span>, isouter=<span class="keyword">True</span>).\</div><div class="line">        filter(Node.name == <span class="string">'grandchild 1'</span>)</div></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.xncoding.com/2016/03/07/python/sqlalchemy01.html" target="_blank" rel="external">SQLAlchemy入门</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SQLAlchemy分为两个部分，一个是最常用的ORM对象映射，另一个是核心的SQL expression。 第一个是纯粹的ORM，后面这个不是ORM，而是DBAPI的封装，通过一些sql表达式来避免了直接写sql。 使用SQLAlchemy则可以分为三种方式。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="数据库" scheme="http://arvin-he.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>关于coroutine</title>
    <link href="http://arvin-he.github.io/2018/02/01/py-asyncio-coroutine-2018-02-01/"/>
    <id>http://arvin-he.github.io/2018/02/01/py-asyncio-coroutine-2018-02-01/</id>
    <published>2018-02-01T03:29:08.000Z</published>
    <updated>2018-02-08T01:33:20.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="关于协程"><a href="#关于协程" class="headerlink" title="关于协程"></a>关于协程</h2><p>协程，又称微线程，纤程。英文名Coroutine。<br>python中的协程发展有3个阶段:</p><ol><li>最初的生成器变形yield/send</li><li>python3.4引入@asyncio.coroutine和yield from</li><li>python3.5引入async/await关键字</li></ol><h2 id="协程库"><a href="#协程库" class="headerlink" title="协程库"></a>协程库</h2><p>常用的协程有gevent和asyncio</p><p>asyncio是一个基于事件循环的实现异步I/O的模块。</p><h2 id="从yield说起"><a href="#从yield说起" class="headerlink" title="从yield说起"></a>从yield说起</h2><p>当一个函数func中包含yield语句时，python会自动将其识别为一个生成器,<br>当调用该函数func()时,并<strong>不会真正调用函数体,而是以函数体生成一个生成器对象实例.</strong><br>yield在这里保留func函数的计算现场,暂停func的计算并将返回值返回。<br>而将func放入for…in循环中时，每次循环都会调用next(func())，唤醒生成器，<br>执行到下一个yield语句处，直到抛出StopIteration异常。此异常会被for循环捕获，导致跳出循环。</p><h2 id="然后是send"><a href="#然后是send" class="headerlink" title="然后是send"></a>然后是send</h2><p>yield实现数据的流出,即产生返回,但是不能接收数据,但如果可以send数据给生成器函数不就相当于实现了协程了嘛.<br>这时send就起这个发送数据生成器的作用了,这样生成器就能接收数据,再产生数据,形成一个连续的流程了.<br>于是在python中的生成器有send函数.当一个函数被标记为生成器,那么这个函数就有了send函数了.这是生成器的特性决定的.<br>Python的生成器不但通过yield可以返回一个值，它还可以接收调用者发出的参数。</p><h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pymongo</div><div class="line"><span class="keyword">from</span> gevent.pool <span class="keyword">import</span> Pool</div><div class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</div><div class="line">monkey.patch_all()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TMonitor</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, domain)</span>:</span></div><div class="line">        db = ConnectMongo().db</div><div class="line">        self.movie = db[<span class="string">'xxxxx'</span>]</div><div class="line">        self.domain = domain</div><div class="line">        self.results = []</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, first, second)</span>:</span></div><div class="line">        pool = Pool(<span class="number">10</span>)</div><div class="line">        pool.map(self.run_task, self.get_items(first, second))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_item</span><span class="params">(self, start_end)</span>:</span></div><div class="line">        print(<span class="string">"~~~~~~~~~~~~~~~~~~~~~"</span>)</div><div class="line">        select_dict = &#123;<span class="string">'$and'</span>: [&#123;<span class="string">'insert_time'</span>: &#123;<span class="string">'$gte'</span>: start_end[<span class="number">0</span>], <span class="string">'$lte'</span>: start_end[<span class="number">1</span>]&#125;&#125;, &#123;<span class="string">'domain'</span>: &#123;<span class="string">'$eq'</span>: self.domain&#125;&#125;]&#125;</div><div class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.movie.find(select_dict, no_cursor_timeout=<span class="keyword">True</span>).sort(<span class="string">'insert_time'</span>, pymongo.ASCENDING):</div><div class="line">            insert_time = item[<span class="string">'insert_time'</span>]</div><div class="line">            url = item[<span class="string">'request'</span>][<span class="string">'url'</span>]</div><div class="line">            content = item[<span class="string">'response'</span>][<span class="string">'content'</span>]</div><div class="line">            task_dict = &#123;<span class="string">'url'</span>: url, <span class="string">'content'</span>: content, <span class="string">'insert_time'</span>: insert_time&#125;</div><div class="line">            print(<span class="string">"ooooooooooooo"</span>)</div><div class="line">            <span class="keyword">yield</span> task_dict</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_items</span><span class="params">(self, first, second)</span>:</span></div><div class="line">        generator1 = self.get_item(first)</div><div class="line">        generator2 = self.get_item(second)</div><div class="line">        <span class="comment"># 进入生成器</span></div><div class="line">        <span class="comment"># next(item1)</span></div><div class="line">        <span class="comment"># next(item2)</span></div><div class="line">        generator1.send(<span class="keyword">None</span>)</div><div class="line">        generator2.send(<span class="keyword">None</span>)</div><div class="line">        print(<span class="string">'KKKKKKKKKKKKKKKKK'</span>)</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                item1_res = generator1.send(first)</div><div class="line">                item2_res = generator2.send(second)</div><div class="line">                <span class="keyword">yield</span> (item1_res, item2_res)</div><div class="line">            <span class="keyword">except</span> StopIteration:</div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_task</span><span class="params">(self, items)</span>:</span></div><div class="line">        print(<span class="string">'xxxxxxxxxxx'</span>)</div><div class="line">        pprint(items[<span class="number">0</span>].get(<span class="string">'url'</span>, <span class="string">'None'</span>))</div><div class="line">        <span class="comment"># pprint(items[0].get('insert_time'))</span></div><div class="line">        pprint(items[<span class="number">1</span>].get(<span class="string">'url'</span>, <span class="string">'None'</span>))</div><div class="line">        <span class="comment"># pprint(items[1].get('insert_time'))</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    domain = <span class="string">'www.xxxx.com'</span></div><div class="line">    tamp = TMonitor(domain)</div><div class="line">    first = (<span class="string">'1517463871757'</span>, <span class="string">'1517463967738'</span>)</div><div class="line">    second = (<span class="string">'1517464006277'</span>, <span class="string">'1517464088805'</span>)</div><div class="line">    tamp.run(first, second)</div></pre></td></tr></table></figure><h2 id="yield-from来了"><a href="#yield-from来了" class="headerlink" title="yield from来了"></a>yield from来了</h2><p>yield from用于重构生成器,yield from的作用还体现可以像一个管道一样将send信息传递给内层协程，并且处理好了各种异常情况.</p><h2 id="asyncio-coroutine和yield-from"><a href="#asyncio-coroutine和yield-from" class="headerlink" title="asyncio.coroutine和yield from"></a>asyncio.coroutine和yield from</h2><p>asyncio是一个基于事件循环的实现异步I/O的模块。通过yield from，可以将协程asyncio.sleep(或其他协程)的控制权交给事件循环，<br>然后挂起当前协程；之后，由事件循环决定何时唤醒asyncio.sleep,接着向后执行代码。</p><h2 id="关于async和await"><a href="#关于async和await" class="headerlink" title="关于async和await"></a>关于async和await</h2><p>async和await两个关键字是python3.5引入的,可以完美替换掉python3.4引入的asyncio.coroutine和yield from.<br>从Python设计的角度来看，async/await让协程表面上独立于生成器，将细节都隐藏于asyncio模块之下，语法更清晰明了。</p><h2 id="async-with-和async-for"><a href="#async-with-和async-for" class="headerlink" title="async with 和async for"></a>async with 和async for</h2><p>async with是一个异步上下文管理器,异步上下文管理器指的是在enter和exit方法处能够暂停执行的上下文管理器。<br>为了实现这样的功能，需要加入两个新的方法：<code>__aenter__</code> 和<code>__aexit__</code>。这两个方法<strong>都要返回一个 awaitable类型的值</strong>。<br>异步上下文管理器的一种使用方法是:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncContextManager</span>:</span></div><div class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aenter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">await</span> log(<span class="string">'entering context'</span>)</div><div class="line"></div><div class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__aexit__</span><span class="params">(self, exc_type, exc, tb)</span>:</span></div><div class="line">        <span class="keyword">await</span> log(<span class="string">'exiting context'</span>)</div></pre></td></tr></table></figure><p>和常规的with表达式一样，可以在一个async with表达式中指定多个上下文管理器。<br>如果向async with表达式传入的上下文管理器中没有<code>__aenter__</code> 和<code>__aexit__</code>方法，这将引起一个错误 。<br>如果在async def函数外面使用async with，将引起一个SyntaxError（语法错误）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="keyword">with</span> async_open(<span class="string">'1.txt'</span>) <span class="keyword">as</span> f:</div><div class="line">    content = <span class="keyword">await</span> f.read()</div></pre></td></tr></table></figure><p>相应的，async_open 函数返回的 f 对象需要实现 <code>__aenter__</code> 和 <code>__aexit__</code> 这 2 个异步方法。</p><p>async for是一个异步迭代器,一个异步可迭代对象（asynchronous iterable）能够在迭代过程中调用异步代码，而异步迭代器就是能够在next方法中调用异步代码。为了支持异步迭代：</p><ol><li>一个对象必须实现<code>__aiter__</code>方法，该方法返回一个异步迭代器（asynchronous iterator）对象。</li><li>一个异步迭代器对象必须实现<code>__anext__</code>方法，该方法返回一个awaitable类型的值。</li><li>为了停止迭代，<code>__anext__</code>必须抛出一个StopAsyncIteration异常。</li></ol><p>异步迭代器的一个例子如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncIterable</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__aiter__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self</div><div class="line"></div><div class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">__anext__</span><span class="params">(self)</span>:</span></div><div class="line">        data = <span class="keyword">await</span> self.fetch_data()</div><div class="line">        <span class="keyword">if</span> data:</div><div class="line">            <span class="keyword">return</span> data</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">raise</span> StopAsyncIteration</div><div class="line"></div><div class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">fetch_data</span><span class="params">(self)</span>:</span></div><div class="line">        ...</div></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f = open(<span class="string">'1.txt'</span>)</div><div class="line"><span class="keyword">async</span> <span class="keyword">for</span> line <span class="keyword">in</span> f:</div><div class="line">    print(line)</div></pre></td></tr></table></figure><p>async for 实现了 <code>__aiter__</code> 和 <code>__anext__</code>方法.<br>PEP 525 引入的异步生成器（asynchronous generator）就实现了这两个方法。在异步方法中使用 yield 表达式，<br>会将它变成异步生成器函数（Python 3.6 以后可用，3.5 之前是语法错误）。<br>值得注意的是，异步生成器没有实现 <code>__await__</code> 方法，因此它不是协程，也不能被 await。<br>把一个没有<code>__aiter__</code>方法的迭代对象传递给 async for将引起TypeError。<br>和常规的for表达式一样， async for也有一个可选的else 分句。</p><h2 id="asyncio使用"><a href="#asyncio使用" class="headerlink" title="asyncio使用"></a>asyncio使用</h2><p>协程不能直接运行,需要将协程加入到事件循环(loop)中, <code>asyncio.get_event_loop</code>方法可以创建一个事件循环，<br>然后调用<code>run_until_complete</code>将协程注册到事件循环，并启动事件循环。</p><ul><li>event_loop 事件循环：程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。</li><li>coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会<strong>返回一个协程对象</strong>。协程对象需要注册到事件循环，由事件循环调用。</li><li>task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态。</li><li>future： 代表将来执行或没有执行的任务的结果。它和task上没有本质的区别</li><li>async/await 关键字：python3.5 用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。</li></ul><h3 id="关于task"><a href="#关于task" class="headerlink" title="关于task"></a>关于task</h3><p>在注册协程的事件循环的时候，实际上<code>run_until_complete</code>方法将协程包装成为了一个任务（task）对象。<br>而task对象是Future类的子类,保存了协程运行后的状态，用于未来获取协程的结果。<br>创建task后，task在加入事件循环之前是pending状态，<br><code>asyncio.ensure_future(coroutine)</code> 和 <code>loop.create_task(coroutine)</code>都可以创建一个task，<br><code>run_until_complete</code>的参数是一个futrue对象。当传入一个协程，其内部会自动封装成task，task是Future的子类。<br><code>isinstance(task, asyncio.Future)</code>将会输出True。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line"></div><div class="line">start = now()</div><div class="line"><span class="comment"># 协程对象</span></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line"><span class="comment"># 创建事件循环</span></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"><span class="comment"># 创建任务task</span></div><div class="line"><span class="comment"># task = asyncio.ensure_future(coroutine)</span></div><div class="line">task = loop.create_task(coroutine)</div><div class="line"></div><div class="line">print(task)</div><div class="line"><span class="comment"># 注册事件,开始事件循环</span></div><div class="line">loop.run_until_complete(task)</div><div class="line">print(task)</div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure><h3 id="绑定回调"><a href="#绑定回调" class="headerlink" title="绑定回调"></a>绑定回调</h3><p>绑定回调，在task执行完毕的时候可以获取执行的结果，回调的最后一个参数是future对象，<br>通过该对象可以获取协程返回值。如果回调需要多个参数，可以通过偏函数导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line">now = <span class="keyword">lambda</span> : time.time()</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(future)</span>:</span></div><div class="line">    print(<span class="string">'Callback: '</span>, future.result())</div><div class="line"> </div><div class="line">start = now()</div><div class="line"><span class="comment"># 创建协程对象</span></div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line"><span class="comment"># 创建事件循环</span></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"><span class="comment"># 创建task</span></div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line"><span class="comment"># 绑定回调</span></div><div class="line">task.add_done_callback(callback)</div><div class="line"><span class="comment"># 注册事件循环</span></div><div class="line">loop.run_until_complete(task)</div><div class="line"> </div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div><div class="line"><span class="comment"># 回调传入多个参数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">callback</span><span class="params">(t, future)</span>:</span></div><div class="line">    print(<span class="string">'Callback:'</span>, t, future.result())</div><div class="line"><span class="comment"># 回调传入多个参数, 通过偏函数导入</span></div><div class="line">task.add_done_callback(functools.partial(callback, <span class="number">2</span>))</div></pre></td></tr></table></figure><p>可以看到，coroutine执行结束时候会调用回调函数。并通过参数future获取协程执行的结果。<br>我们创建的task和回调里的future对象，实际上是同一个对象。</p><h3 id="future-与-result"><a href="#future-与-result" class="headerlink" title="future 与 result"></a>future 与 result</h3><p>回调一直是很多异步编程的恶梦，程序员更喜欢使用同步的编写方式写异步代码，以避免回调的恶梦。回调中我们使用了future对象的result方法。<br>前面不绑定回调的例子中，我们可以看到task有finished状态。在那个时候，可以直接读取task的result方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting &#123;&#125;'</span>.format(x))</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"> </div><div class="line">start = now()</div><div class="line"> </div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line">loop.run_until_complete(task)</div><div class="line"> </div><div class="line">print(<span class="string">'Task ret: &#123;&#125;'</span>.format(task.result()))</div><div class="line">print(<span class="string">'TIME: &#123;&#125;'</span>.format(now() - start))</div></pre></td></tr></table></figure></p><p>可以看到输出的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Waiting:  2</div><div class="line">Task ret:  Done after 2s</div><div class="line">TIME:  0.0003650188446044922</div></pre></td></tr></table></figure></p><h3 id="阻塞和await"><a href="#阻塞和await" class="headerlink" title="阻塞和await"></a>阻塞和await</h3><p>使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。<br>协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行。<br>耗时的操作一般是一些IO操作，例如网络请求，文件读取等。使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。<br><strong>注意:</strong>asyncio.sleep本身也是一个协程函数,而time.sleep则不是协程函数,而且是阻塞的.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"> </div><div class="line">start = now()</div><div class="line"> </div><div class="line">coroutine = do_some_work(<span class="number">2</span>)</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(coroutine)</div><div class="line">loop.run_until_complete(task)</div><div class="line"> </div><div class="line">print(<span class="string">'Task ret: '</span>, task.result())</div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure></p><p>在 sleep的时候，使用await让出控制权。即当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出，以便loop调用其他的协程。<br>现在我们的例子就用耗时的阻塞操作了。</p><h3 id="并行和并发"><a href="#并行和并发" class="headerlink" title="并行和并发"></a>并行和并发</h3><p>并发和并行一直是容易混淆的概念。</p><ol><li>并发通常指: 有多个任务需要同时进行，</li><li>并行则是: 同一时刻有多个任务执行。<br>用上课来举例就是，并发情况下是一个老师在同一时间段辅助不同的人功课。并行则是好几个老师分别同时辅助多个学生功课。<br>简而言之就是一个人同时吃三个馒头还是三个人同时分别吃一个的情况，吃一个馒头算一个任务。<br>asyncio实现并发，就需要多个协程来完成任务，每当有任务阻塞的时候就await，然后其他协程继续工作。<br>创建多个协程的列表，然后将这些协程注册到事件循环中。<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"> </div><div class="line"><span class="keyword">import</span> time</div><div class="line"> </div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"> </div><div class="line">start = now()</div><div class="line"> </div><div class="line">coroutine1 = do_some_work(<span class="number">1</span>)</div><div class="line">coroutine2 = do_some_work(<span class="number">2</span>)</div><div class="line">coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line"> </div><div class="line">tasks = [</div><div class="line">    asyncio.ensure_future(coroutine1),</div><div class="line">    asyncio.ensure_future(coroutine2),</div><div class="line">    asyncio.ensure_future(coroutine3)</div><div class="line">]</div><div class="line"> </div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(asyncio.wait(tasks))</div><div class="line"> </div><div class="line"><span class="keyword">for</span> task <span class="keyword">in</span> tasks:</div><div class="line">    print(<span class="string">'Task ret: '</span>, task.result())</div><div class="line"> </div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure></li></ol><p>结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Waiting:  1</div><div class="line">Waiting:  2</div><div class="line">Waiting:  4</div><div class="line">Task ret:  Done after 1s</div><div class="line">Task ret:  Done after 2s</div><div class="line">Task ret:  Done after 4s</div><div class="line">TIME:  4.003541946411133</div></pre></td></tr></table></figure></p><p>总时间为4s左右。4s的阻塞时间，足够前面两个协程执行完毕。<br>如果是同步顺序的任务，那么至少需要7s。此时我们使用了aysncio实现了并发。<br>asyncio.wait(tasks) 也可以使用 asyncio.gather(*tasks) ,前者接受一个task列表，后者接收一堆task。</p><h3 id="协程嵌套"><a href="#协程嵌套" class="headerlink" title="协程嵌套"></a>协程嵌套</h3><p>使用async可以定义协程，协程用于耗时的io操作，我们也可以封装更多的io操作过程，<br>这样就实现了嵌套的协程，即一个协程中await了另外一个协程，如此连接起来。</p><p>在main协程函数里处理结果<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">4</span>)</div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3)</div><div class="line">    ]</div><div class="line">    <span class="comment"># 方式一</span></div><div class="line">    dones, pendings = <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> dones:</div><div class="line">        print(<span class="string">'Task ret: '</span>, task.result())</div><div class="line">    <span class="comment"># 方式二:使用asyncio.gather创建协程对象，那么await的返回值就是协程运行的结果。</span></div><div class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line">    <span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">        print(<span class="string">'Task ret: '</span>, result)</div><div class="line">    </div><div class="line">start = now()</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(main())</div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure></p><p>不在main协程函数里处理结果，直接返回await的内容，那么最外层的<code>run_until_complete</code>将会返回main协程的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">2</span>)</div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3)</div><div class="line">    ]</div><div class="line">    <span class="comment"># 不在main协程函数里处理结果，直接返回await的内容</span></div><div class="line">    <span class="comment"># 方式一</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.gather(*tasks)</div><div class="line">    <span class="comment"># 方式二: 返回使用asyncio.wait方式挂起协程。</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    <span class="comment"># 方式三: 使用asyncio的as_completed方法</span></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.as_completed(tasks):</div><div class="line">        result = <span class="keyword">await</span> task</div><div class="line">        print(<span class="string">'Task ret: &#123;&#125;'</span>.format(result))</div><div class="line"> </div><div class="line">start = now()</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"><span class="comment"># 这里获取main协程的结果</span></div><div class="line"><span class="comment"># 方式一处理结果</span></div><div class="line">results = loop.run_until_complete(main())</div><div class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</div><div class="line">    print(<span class="string">'Task ret: '</span>, result)</div><div class="line"><span class="comment"># 方式二处理结果</span></div><div class="line">done, pending = loop.run_until_complete(main())</div><div class="line"><span class="keyword">for</span> task <span class="keyword">in</span> done:</div><div class="line">    print(<span class="string">'Task ret: '</span>, task.result())</div><div class="line"><span class="comment"># 方式三处理结果</span></div><div class="line">done = loop.run_until_complete(main())</div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure></p><p>由此可见，协程的调用和组合十分灵活，尤其是对于结果的处理，如何返回，如何挂起，需要逐渐积累经验和前瞻的设计。</p><h3 id="协程停止"><a href="#协程停止" class="headerlink" title="协程停止"></a>协程停止</h3><p>以上是协程的几种常用的用法，都是协程围绕着<strong>事件循环</strong>进行的操作。future对象有几个状态：</p><ul><li>Pending</li><li>Running</li><li>Done</li><li>Cancelled<br>创建future的时候，task为pending，<br>事件循环调用执行的时候是running，<br>调用完毕就是done，<br>如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"> </div><div class="line">coroutine1 = do_some_work(<span class="number">1</span>)</div><div class="line">coroutine2 = do_some_work(<span class="number">2</span>)</div><div class="line">coroutine3 = do_some_work(<span class="number">2</span>)</div><div class="line"> </div><div class="line">tasks = [</div><div class="line">    asyncio.ensure_future(coroutine1),</div><div class="line">    asyncio.ensure_future(coroutine2),</div><div class="line">    asyncio.ensure_future(coroutine3)</div><div class="line">]</div><div class="line"> </div><div class="line">start = now()</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    loop.run_until_complete(asyncio.wait(tasks))</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    <span class="comment"># print(asyncio.Task.all_tasks())</span></div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> asyncio.Task.all_tasks():</div><div class="line">        print(task.cancel())</div><div class="line">    loop.stop()</div><div class="line">    loop.run_forever()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    loop.close()</div><div class="line"> </div><div class="line">print(<span class="string">'TIME: '</span>, now() - start)</div></pre></td></tr></table></figure></li></ul><p>启动事件循环之后，马上ctrl+c，会触发<code>run_until_complete</code>的执行异常 KeyBorardInterrupt。<br>然后通过循环asyncio.Task取消future。可以看到输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Waiting:  1</div><div class="line">Waiting:  2</div><div class="line">Waiting:  2</div><div class="line">True</div><div class="line">True</div><div class="line">True</div><div class="line">True</div><div class="line">TIME:  0.8858370780944824</div></pre></td></tr></table></figure></p><p>True表示cannel成功，loop stop之后还需要再次开启事件循环，最后在close，不然还会抛出异常：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Task was destroyed but it is pending!</div><div class="line">task: &lt;Task pending coro=&lt;do_some_work() done,</div></pre></td></tr></table></figure></p><p>循环task，逐个cancel是一种方案，可是正如上面我们把task的列表封装在main函数中，main函数外进行事件循环的调用。<br>这个时候，main相当于最外出的一个task，那么处理包装的main函数即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> time</div><div class="line">now = <span class="keyword">lambda</span>: time.time()</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting: '</span>, x)</div><div class="line"> </div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    <span class="keyword">return</span> <span class="string">'Done after &#123;&#125;s'</span>.format(x)</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    coroutine1 = do_some_work(<span class="number">1</span>)</div><div class="line">    coroutine2 = do_some_work(<span class="number">2</span>)</div><div class="line">    coroutine3 = do_some_work(<span class="number">2</span>)</div><div class="line"> </div><div class="line">    tasks = [</div><div class="line">        asyncio.ensure_future(coroutine1),</div><div class="line">        asyncio.ensure_future(coroutine2),</div><div class="line">        asyncio.ensure_future(coroutine3)</div><div class="line">    ]</div><div class="line">    done, pending = <span class="keyword">await</span> asyncio.wait(tasks)</div><div class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> done:</div><div class="line">        print(<span class="string">'Task ret: '</span>, task.result())</div><div class="line"> </div><div class="line">start = now()</div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">task = asyncio.ensure_future(main())</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    loop.run_until_complete(task)</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    print(asyncio.Task.all_tasks())</div><div class="line">    print(asyncio.gather(*asyncio.Task.all_tasks()).cancel())</div><div class="line">    loop.stop()</div><div class="line">    loop.run_forever()</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">    loop.close()</div></pre></td></tr></table></figure></p><h3 id="不同线程的事件循环"><a href="#不同线程的事件循环" class="headerlink" title="不同线程的事件循环"></a>不同线程的事件循环</h3><p>很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。<br>一个简单的方式就是使用多线程: <strong>当前线程创建</strong>一个事件循环，然后在<strong>新建一个线程</strong>，在<strong>新线程中启动事件循环</strong>。当前线程不会被block。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_forever()</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'More work &#123;&#125;'</span>.format(x))</div><div class="line">    time.sleep(x)</div><div class="line">    print(<span class="string">'Finished more work &#123;&#125;'</span>.format(x))</div><div class="line"> </div><div class="line">start = now()</div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line"><span class="comment"># 创建新线程,在新线程中启动事件循环</span></div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line">print(<span class="string">'TIME: &#123;&#125;'</span>.format(time.time() - start))</div><div class="line"> </div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">6</span>)</div><div class="line">new_loop.call_soon_threadsafe(more_work, <span class="number">3</span>)</div></pre></td></tr></table></figure></p><p>启动上述代码之后，当前线程不会被block，新线程中会按照顺序执行<code>call_soon_threadsafe</code>方法注册的<code>more_work</code>方法，<br>后者因为time.sleep操作是同步阻塞的，因此运行完毕more_work需要大致6 + 3</p><p>改进:新线程协程<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_loop</span><span class="params">(loop)</span>:</span></div><div class="line">    asyncio.set_event_loop(loop)</div><div class="line">    loop.run_forever()</div><div class="line"> </div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">do_some_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'Waiting &#123;&#125;'</span>.format(x))</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(x)</div><div class="line">    print(<span class="string">'Done after &#123;&#125;s'</span>.format(x))</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">more_work</span><span class="params">(x)</span>:</span></div><div class="line">    print(<span class="string">'More work &#123;&#125;'</span>.format(x))</div><div class="line">    time.sleep(x)</div><div class="line">    print(<span class="string">'Finished more work &#123;&#125;'</span>.format(x))</div><div class="line"> </div><div class="line">start = now()</div><div class="line"><span class="comment"># 主线程创建一个new_loop</span></div><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line"><span class="comment"># 子线程中启动这个事件循环</span></div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line">t.start()</div><div class="line">print(<span class="string">'TIME: &#123;&#125;'</span>.format(time.time() - start))</div><div class="line"> </div><div class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">6</span>), new_loop)</div><div class="line">asyncio.run_coroutine_threadsafe(do_some_work(<span class="number">4</span>), new_loop)</div></pre></td></tr></table></figure></p><p>上述的例子，主线程中创建一个<code>new_loop</code>，然后在另外的子线程中开启一个无限事件循环。<br>主线程通过<code>run_coroutine_threadsafe</code>新注册协程对象。<br>这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被block。一共执行的时间大概在6s左右。</p><h3 id="master-worker主从模式"><a href="#master-worker主从模式" class="headerlink" title="master-worker主从模式"></a>master-worker主从模式</h3><p>对于并发任务，通常是用生成消费模型，对队列的处理可以使用类似master-worker的方式，master主要用户获取队列的msg，worker用户处理消息。<br>并且协程更适合单线程的方式, 为了简单起见，我们的主线程用来监听队列，子线程用于处理队列。这里使用redis的队列。主线程中有一个是无限循环，用户消费队列。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">   task = rcon.rpop(<span class="string">"queue"</span>)</div><div class="line">   <span class="keyword">if</span> <span class="keyword">not</span> task:</div><div class="line">       time.sleep(<span class="number">1</span>)</div><div class="line">       <span class="keyword">continue</span></div><div class="line">   asyncio.run_coroutine_threadsafe(do_some_work(int(task)), new_loop)</div></pre></td></tr></table></figure></p><h3 id="停止子线程"><a href="#停止子线程" class="headerlink" title="停止子线程"></a>停止子线程</h3><p>如果一切正常，那么上面的例子很完美。可是，需要停止程序，直接ctrl+c，会抛出KeyboardInterrupt错误，我们修改一下主循环：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        task = rcon.rpop(<span class="string">"queue"</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> task:</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        asyncio.run_coroutine_threadsafe(do_some_work(int(task)), new_loop)</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    print(e)</div><div class="line">    new_loop.stop()</div></pre></td></tr></table></figure></p><p>可是实际上并不好使，虽然主线程try了KeyboardInterrupt异常，但是子线程并没有退出，<br>为了解决这个问题，可以设置子线程为守护线程，这样当主线程结束的时候，子线程也随之退出。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">new_loop = asyncio.new_event_loop()</div><div class="line">t = Thread(target=start_loop, args=(new_loop,))</div><div class="line"><span class="comment"># 设置子线程为守护线程</span></div><div class="line">t.setDaemon(<span class="keyword">True</span>)</div><div class="line">t.start()</div><div class="line"> </div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        <span class="comment"># print('start rpop')</span></div><div class="line">        task = rcon.rpop(<span class="string">"queue"</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> task:</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line">            <span class="keyword">continue</span></div><div class="line">        asyncio.run_coroutine_threadsafe(do_some_work(int(task)), new_loop)</div><div class="line"><span class="keyword">except</span> KeyboardInterrupt <span class="keyword">as</span> e:</div><div class="line">    print(e)</div><div class="line">    new_loop.stop()</div></pre></td></tr></table></figure></p><h3 id="关于队列的task-done-join"><a href="#关于队列的task-done-join" class="headerlink" title="关于队列的task_done, join"></a>关于队列的task_done, join</h3><p>q.task_done(): 每次从queue中get一个数据之后，当处理好相关问题后，<strong>才调用该方法</strong>，以提示q.join()是否停止阻塞，让线程向前执行或者退出；<br>如果每从队列里取一次，但没有执行<code>task_done()</code>，则join无法判断队列到底有没有结束，在最后执行个join()是等不到结果的，会一直挂起。<br>可以理解为，每<code>task_done</code>一次 就从队列里删掉一个元素，这样在最后join的时候根据队列长度是否为零来判断队列是否结束，从而执行主线程。<br>q.join(): 阻塞，直到queue中的数据均被删除或者处理。为队列中的每一项都调用一次。<br>对于生产者-消费者模型，这样做还是有问题的，因为如果queue初始为空，q.join()会直接停止阻塞，继而执行后续语句；<br>如果有多个消费者，没有生产者，且queue始初化为一定的数据量，则可以正常执行。</p><p>注意点: </p><ol><li>put队列完成的时候千万不能用<code>task_done()</code>，否则会报错：<code>task_done() called too many times</code>, 因为该方法仅仅表示get成功后，执行的一个标记。</li></ol><h3 id="关于守护线程和线程的join"><a href="#关于守护线程和线程的join" class="headerlink" title="关于守护线程和线程的join"></a>关于守护线程和线程的join</h3><p>threading：<br>守护线程不同于linux中守护进程的概念<br>t.setDaemon(True)  将线程设置成守护线程，主进行结束后，此线程也会被强制结束。如果线程没有设置此值，则主线程执行完毕后还会等待此线程执行。</p><p>t.join() 线程阻塞，只有当线程运行结束后才会继续执行后续语句</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://python.jobbole.com/87310/" target="_blank" rel="external">Python黑魔法—异步IO（ asyncio）协程</a></li><li><a href="http://blog.csdn.net/qq_35304570/article/details/78209612" target="_blank" rel="external">Python异步处理中的async with 和async for 用法说明</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;关于协程&quot;&gt;&lt;a href=&quot;#关于协程&quot; class=&quot;headerlink&quot; title=&quot;关于协程&quot;&gt;&lt;/a&gt;关于协程&lt;/h2&gt;&lt;p&gt;协程，又称微线程，纤程。英文名Coroutine。&lt;br&gt;python中的协程发展有3个阶段:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;最
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>全站爬虫</title>
    <link href="http://arvin-he.github.io/2018/02/01/spiderallsite-2018-02-01/"/>
    <id>http://arvin-he.github.io/2018/02/01/spiderallsite-2018-02-01/</id>
    <published>2018-02-01T03:14:30.000Z</published>
    <updated>2018-02-01T03:24:26.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全站爬虫简介"><a href="#全站爬虫简介" class="headerlink" title="全站爬虫简介"></a>全站爬虫简介</h2><p>python version: 3.6, 爬取全站url,并保存html到mongodb.</p><h2 id="爬虫功能"><a href="#爬虫功能" class="headerlink" title="爬虫功能"></a>爬虫功能</h2><ul><li>生产者消费者模式</li><li>支持协程并发</li><li>爬取深度可配置</li><li>爬取总量可配置</li><li>自动过滤无关URL</li></ul><h2 id="相关代码段"><a href="#相关代码段" class="headerlink" title="相关代码段"></a>相关代码段</h2><p>allsitepider.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> chardet</div><div class="line"><span class="keyword">import</span> requests</div><div class="line"><span class="keyword">import</span> requests.exceptions</div><div class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</div><div class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</div><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"><span class="keyword">import</span> traceback</div><div class="line"></div><div class="line"><span class="keyword">try</span>:</div><div class="line">    <span class="keyword">from</span> .config <span class="keyword">import</span> get_header, func_timer, connect_mongo</div><div class="line">    <span class="keyword">from</span> .config <span class="keyword">import</span> TIMEOUT, DEPTH, MONGODB, AMOUNTS, CONTENT_LENGTH, DELAY, QUEUE_SIZE</div><div class="line">    <span class="keyword">from</span> .logger <span class="keyword">import</span> Logging</div><div class="line"><span class="keyword">except</span> ImportError:</div><div class="line">    <span class="keyword">from</span> config <span class="keyword">import</span> get_header, func_timer, connect_mongo</div><div class="line">    <span class="keyword">from</span> config <span class="keyword">import</span> TIMEOUT, DEPTH, MONGODB, AMOUNTS, CONTENT_LENGTH, DELAY, QUEUE_SIZE</div><div class="line">    <span class="keyword">from</span> logger <span class="keyword">import</span> Logging</div><div class="line"></div><div class="line">_logger = Logging(os.path.splitext(os.path.basename(__file__))[<span class="number">0</span>]).logObject</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Url</span><span class="params">(object)</span>:</span></div><div class="line">    url = <span class="string">''</span></div><div class="line">    end_type = <span class="string">'WEB'</span></div><div class="line">    parent_url = <span class="string">''</span></div><div class="line">    depth = <span class="number">0</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url, end_type, parent_url_obj=None)</span>:</span></div><div class="line">        self.url = url</div><div class="line">        self.end_type = end_type</div><div class="line">        <span class="keyword">if</span> parent_url_obj:</div><div class="line">            self.parent_url = parent_url_obj.url</div><div class="line">            self.depth = parent_url_obj.depth + <span class="number">1</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllSiteSpider</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">        self.client = connect_mongo(MONGODB)</div><div class="line">        self.movie = self.client[MONGODB[<span class="string">'collection'</span>]]</div><div class="line">        self.filter_set = set()</div><div class="line">        self.q = asyncio.Queue(maxsize=QUEUE_SIZE)</div><div class="line">        self.consume_num = <span class="number">0</span></div><div class="line">        self.produce_num = <span class="number">0</span></div><div class="line">        self.stop_extract_links = <span class="keyword">False</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_crawl</span><span class="params">(self, start_url, end_type)</span>:</span></div><div class="line">        self.domain = getattr(urlparse(start_url), <span class="string">'netloc'</span>, <span class="string">''</span>)</div><div class="line">        self.end_type = end_type</div><div class="line">        url = start_url.strip()</div><div class="line">        <span class="keyword">if</span> url.endswith(<span class="string">'/'</span>):</div><div class="line">            url = url[:<span class="number">-1</span>]</div><div class="line">        self.filter_set.add(url)</div><div class="line">        start_url_obj = Url(url, self.end_type)</div><div class="line">        self.q.put_nowait(start_url_obj)</div><div class="line">        event_loop = asyncio.get_event_loop()</div><div class="line">        _logger.info(<span class="string">'开始全站爬取:start_url=[&#123;&#125;], Depth=&#123;&#125;, end_type=&#123;&#125;, parent_url=None'</span>.format(</div><div class="line">            start_url_obj.url, start_url_obj.depth, start_url_obj.end_type))</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            event_loop.run_until_complete(self.run(event_loop))</div><div class="line">        <span class="keyword">finally</span>:</div><div class="line">            event_loop.close()</div><div class="line"></div><div class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, loop)</span>:</span></div><div class="line">        consumers = [loop.create_task(self.consumer(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>)]</div><div class="line">        <span class="keyword">await</span> asyncio.wait(consumers)</div><div class="line"></div><div class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(self, num)</span>:</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                url_obj = <span class="keyword">await</span> self.q.get()</div><div class="line">                self.consume_num += <span class="number">1</span></div><div class="line">                _logger.info(<span class="string">'消费者&#123;&#125;:开始消耗第 &#123;&#125; 个, QSize=&#123;&#125;, Depth=&#123;&#125;, URL=[&#123;&#125;]'</span>.format(</div><div class="line">                    num, self.consume_num, self.q.qsize(), url_obj.depth, url_obj.url))</div><div class="line">                self.q.task_done()</div><div class="line">                <span class="keyword">await</span> self.producer(url_obj)</div><div class="line">            <span class="keyword">finally</span>:</div><div class="line">                <span class="keyword">if</span> self.q.empty():</div><div class="line">                    _logger.info(<span class="string">'队列已空,任务结束,退出EventLoop.'</span>)</div><div class="line">                    <span class="keyword">break</span></div><div class="line">        <span class="keyword">await</span> self.q.join()</div><div class="line"></div><div class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(self, url_obj)</span>:</span></div><div class="line">        self.produce_num += <span class="number">1</span></div><div class="line">        _logger.info(<span class="string">'生产者:开始生产第 &#123;&#125; 个, QSize=&#123;&#125;, Depth=&#123;&#125;, URL=[&#123;&#125;]'</span>.format(</div><div class="line">            self.produce_num, self.q.qsize(), url_obj.depth, url_obj.url))</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            response = self.download_html(url_obj.url)</div><div class="line">            self.save_html(response)</div><div class="line">            <span class="keyword">await</span> asyncio.sleep(DELAY)</div><div class="line">            <span class="keyword">if</span> url_obj.depth &lt; DEPTH:</div><div class="line">                <span class="keyword">if</span> <span class="keyword">not</span> self.stop_extract_links:</div><div class="line">                    links = self.extract_links(response, url_obj)</div><div class="line">                    <span class="keyword">if</span> (self.consume_num+self.q.qsize()) &lt; AMOUNTS:</div><div class="line">                        <span class="keyword">for</span> url_obj <span class="keyword">in</span> links:</div><div class="line">                            <span class="keyword">await</span> self.q.put(url_obj)</div><div class="line">                        _logger.info(<span class="string">'向当前队列Put &#123;&#125; 个url, 当前队列QSize=&#123;&#125;'</span>.format(len(links) <span class="keyword">if</span> links <span class="keyword">else</span> <span class="number">0</span>, self.q.qsize()))</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        _logger.info(<span class="string">'当前已消耗URL + 当前队列QSize为&#123;&#125;,大于全站爬取最大限制数目&#123;&#125;,停止向队列Put URL,丢弃提取的 &#123;&#125; 个url,并停止解析提取之后的所有页面链接'</span>.format(</div><div class="line">                            self.consume_num+self.q.qsize(), AMOUNTS, len(links) <span class="keyword">if</span> links <span class="keyword">else</span> <span class="number">0</span>))</div><div class="line">                        self.stop_extract_links = <span class="keyword">True</span></div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                _logger.warning(<span class="string">'当前URL深度为 &#123;&#125;, 达到最大深度限制,不再提取页面URL,当前URL=[&#123;&#125;]'</span>.format(url_obj.depth, url_obj.url))</div><div class="line">            _logger.info(<span class="string">'当前全局set共有 &#123;&#125; 个url'</span>.format(len(self.filter_set)))</div><div class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">            _logger.error(<span class="string">'生产者异常:&#123;&#125;'</span>.format(traceback.format_exc()))</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download_html</span><span class="params">(self, url, retry=<span class="number">2</span>)</span>:</span></div><div class="line">        _logger.info(<span class="string">'下载页面:开始下载HTML页面...'</span>)</div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            response = requests.get(url, headers=get_header(self.end_type), stream=<span class="keyword">True</span>, timeout=TIMEOUT)</div><div class="line">            <span class="keyword">if</span> int(response.headers.get(<span class="string">'Content-Length'</span>, <span class="number">0</span>)) &lt; CONTENT_LENGTH:</div><div class="line">                response.encoding = chardet.detect(response.content)[<span class="string">'encoding'</span>]</div><div class="line">                <span class="keyword">return</span> response</div><div class="line">        <span class="keyword">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</div><div class="line">            _logger.error(<span class="string">'访问链接失败: &#123;&#125;, ERROR: &#123;&#125;'</span>.format(url, e))</div><div class="line">            <span class="keyword">if</span> retry &gt; <span class="number">0</span>:</div><div class="line">                _logger.info(<span class="string">'链接: &#123;&#125; 准备重试倒数第 &#123;&#125; 次'</span>.format(url, retry+<span class="number">1</span>))</div><div class="line">                self.download_html(url, retry<span class="number">-1</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_html</span><span class="params">(self, response)</span>:</span></div><div class="line">        doc = &#123;&#125;</div><div class="line">        <span class="keyword">if</span> response <span class="keyword">and</span> response.status_code <span class="keyword">not</span> <span class="keyword">in</span> range(<span class="number">400</span>, <span class="number">600</span>):</div><div class="line">            doc[<span class="string">'request'</span>] = &#123;</div><div class="line">                <span class="string">'url'</span>: response.url,</div><div class="line">                <span class="string">'headers'</span>: response.request.headers,</div><div class="line">                <span class="string">'method'</span>: response.request.method</div><div class="line">            &#125;</div><div class="line">            doc[<span class="string">'response'</span>] = &#123;</div><div class="line">                <span class="string">'headers'</span>: response.headers,</div><div class="line">                <span class="string">'content'</span>: response.content,</div><div class="line">                <span class="string">'status_code'</span>: response.status_code</div><div class="line">            &#125;</div><div class="line">            doc[<span class="string">'end_type'</span>] = self.end_type</div><div class="line">            doc[<span class="string">'domain'</span>] = getattr(urlparse(response.url), <span class="string">'netloc'</span>, <span class="string">''</span>)</div><div class="line">            doc[<span class="string">'insert_time'</span>] = format((time.time() * <span class="number">1000</span>), <span class="string">'0.0f'</span>)</div><div class="line"></div><div class="line">        <span class="keyword">if</span> doc:</div><div class="line">            _logger.info(<span class="string">'保存数据:解析并保存数据到MONGODB数据库...'</span>)</div><div class="line">            self.movie.insert(doc)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="keyword">if</span> response:</div><div class="line">                _logger.warning(<span class="string">'没有解析到数据, status_code=&#123;&#125;, url=&#123;&#125;'</span>.format(</div><div class="line">                    response.status_code, response.url))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                _logger.warning(<span class="string">'没有解析到数据'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">record_urls</span><span class="params">(self, filename, url)</span>:</span></div><div class="line">        <span class="keyword">with</span> open(filename, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</div><div class="line">            f.write(url + <span class="string">'\n'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">filter_url</span><span class="params">(self, url, parent_url_obj, filtered_num, record=False)</span>:</span></div><div class="line">        url_obj = <span class="keyword">None</span></div><div class="line">        new_url = url.strip()</div><div class="line">        <span class="keyword">if</span> new_url.endswith(<span class="string">'/'</span>):</div><div class="line">            new_url = new_url[:<span class="number">-1</span>]</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.filter_set.__contains__(new_url) <span class="keyword">and</span> self.domain <span class="keyword">in</span> new_url:</div><div class="line">            self.filter_set.add(new_url)</div><div class="line">            url_obj = Url(new_url, self.end_type, parent_url_obj)</div><div class="line">            <span class="keyword">if</span> record:</div><div class="line">                self.record_urls(<span class="string">'unique.txt'</span>, new_url)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            filtered_num += <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> record:</div><div class="line">                self.record_urls(<span class="string">'filtered.txt'</span>, new_url)</div><div class="line">        <span class="keyword">return</span> url_obj, filtered_num</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">extract_links</span><span class="params">(self, response, url_obj)</span>:</span></div><div class="line">        <span class="keyword">if</span> response:</div><div class="line">            link_list = []</div><div class="line">            filtered_num = <span class="number">0</span></div><div class="line">            parent_url_obj = url_obj</div><div class="line">            parent_url = parent_url_obj.url</div><div class="line">            soup = BeautifulSoup(response.text, <span class="string">'lxml'</span>)</div><div class="line">            tags = soup.find_all(<span class="keyword">True</span>)</div><div class="line">            <span class="keyword">for</span> tag <span class="keyword">in</span> tags:</div><div class="line">                url = tag.get(<span class="string">'href'</span>, <span class="keyword">None</span>)</div><div class="line">                <span class="keyword">if</span> url <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    <span class="keyword">if</span> url.startswith(<span class="string">'javascript'</span>) <span class="keyword">or</span> url.startswith(<span class="string">'index'</span>):</div><div class="line">                        <span class="keyword">continue</span></div><div class="line">                    <span class="keyword">elif</span> url.startswith(<span class="string">'//'</span>):</div><div class="line">                        url = <span class="string">'&#123;&#125;:&#123;&#125;'</span>.format(getattr(urlparse(parent_url), <span class="string">'scheme'</span>, <span class="string">''</span>), url)</div><div class="line">                    <span class="keyword">elif</span> url.startswith(<span class="string">'/'</span>):</div><div class="line">                        url = <span class="string">'&#123;&#125;://&#123;&#125;&#123;&#125;'</span>.format(getattr(urlparse(parent_url), <span class="string">'scheme'</span>, <span class="string">''</span>),</div><div class="line">                                                 getattr(urlparse(parent_url), <span class="string">'netloc'</span>, <span class="string">''</span>), url)</div><div class="line">                    url_obj, filtered_num = self.filter_url(url, parent_url_obj, filtered_num)</div><div class="line">                    <span class="keyword">if</span> url_obj:</div><div class="line">                        link_list.append(url_obj)</div><div class="line">            _logger.info(<span class="string">'提取Urls:该页面共提取 &#123;&#125; 个, 过滤 &#123;&#125; 个'</span>.format(len(link_list), filtered_num))</div><div class="line">            <span class="keyword">return</span> link_list</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            _logger.error(<span class="string">"该页面为None"</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># if __name__ == '__main__':</span></div><div class="line"><span class="comment">#     # start_url = 'http://www.tongfudun.com'</span></div><div class="line"><span class="comment">#     # start_url = 'https://www.baidu.com'</span></div><div class="line"><span class="comment">#     # start_url = 'http://www.tcnet.com.cn/'</span></div><div class="line"><span class="comment">#     start_url = 'https://www.douban.com'</span></div><div class="line"><span class="comment">#     allsiteSpider = AllSiteSpider()</span></div><div class="line"><span class="comment">#     allsiteSpider.start_crawl(start_url, 'WEB')</span></div></pre></td></tr></table></figure></p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>config.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</div><div class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> MongoClient</div><div class="line"></div><div class="line"><span class="comment"># 爬取深度</span></div><div class="line">DEPTH = <span class="number">3</span></div><div class="line"><span class="comment"># 单个HTML的Content-Length为1M</span></div><div class="line">CONTENT_LENGTH = <span class="number">1</span>*<span class="number">1024</span>*<span class="number">1024</span></div><div class="line"><span class="comment"># 整站爬取总量</span></div><div class="line">AMOUNTS = <span class="number">500</span></div><div class="line"><span class="comment"># 网络请求超时</span></div><div class="line">TIMEOUT = <span class="number">10</span></div><div class="line"><span class="comment"># 爬取延时</span></div><div class="line">DELAY = <span class="number">1</span></div><div class="line"><span class="comment"># 队列大小</span></div><div class="line">QUEUE_SIZE = <span class="number">500</span></div><div class="line"><span class="comment"># 域名允许控制</span></div><div class="line">ALLOWED_DOMAINS = [</div><div class="line"></div><div class="line">]</div><div class="line"><span class="comment"># MONGODB参数</span></div><div class="line">MONGODB = &#123;</div><div class="line">    <span class="string">"user"</span>: <span class="string">"Goshawk"</span>,</div><div class="line">    <span class="string">"passwd"</span>: <span class="string">"yYZmrjJ8xauAe#t7"</span>,</div><div class="line">    <span class="string">"host"</span>: <span class="string">"192.168.1.141:27017"</span>,</div><div class="line">    <span class="string">"dbname"</span>: <span class="string">"Goshawk"</span>,</div><div class="line">    <span class="string">"collection"</span>: <span class="string">"my_mainurls"</span></div><div class="line">&#125;</div><div class="line"><span class="comment"># WEB端user-agent代理头</span></div><div class="line">WEB_USER_AGENTS = [</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)"</span>,</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0; Acoo Browser; SLCC1; .NET CLR 2.0.50727; Media Center PC 5.0; .NET CLR 3.0.04506)"</span>,</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; AOL 9.5; AOLBuild 4337.35; Windows NT 5.1; .NET CLR 1.1.4322; .NET CLR 2.0.50727)"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows; U; MSIE 9.0; Windows NT 9.0; en-US)"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 2.0.50727; Media Center PC 6.0)"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; .NET CLR 1.0.3705; .NET CLR 1.1.4322)"</span>,</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0b; Windows NT 5.2; .NET CLR 1.1.4322; .NET CLR 2.0.50727; InfoPath.2; .NET CLR 3.0.04506.30)"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN) AppleWebKit/523.15 (KHTML, like Gecko, Safari/419.3) Arora/0.3 (Change: 287 c9dfb30)"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (X11; U; Linux; en-US) AppleWebKit/527+ (KHTML, like Gecko, Safari/419.3) Arora/0.6"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.2pre) Gecko/20070215 K-Ninja/2.1.1"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9) Gecko/20080705 Firefox/3.0 Kapiko/3.0"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (X11; Linux i686; U;) Gecko/20070322 Kazehakase/0.4.5"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (X11; U; Linux i686; en-US; rv:1.9.0.8) Gecko Fedora/1.9.0.8-1.fc10 Kazehakase/0.5.6"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_3) AppleWebKit/535.20 (KHTML, like Gecko) Chrome/19.0.1036.7 Safari/535.20"</span>,</div><div class="line">    <span class="string">"Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; fr) Presto/2.9.168 Version/11.52"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)"</span>,</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E; LBBROWSER)"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 LBBROWSER"</span>,</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; QQBrowser/7.0.3698.400)"</span>,</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)"</span>,</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; 360SE)"</span>,</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; QQDownload 732; .NET4.0C; .NET4.0E)"</span>,</div><div class="line">    <span class="string">"Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows NT 5.1) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.89 Safari/537.1"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (iPad; U; CPU OS 4_2_1 like Mac OS X; zh-cn) AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8C148 Safari/6533.18.5"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:2.0b13pre) Gecko/20110307 Firefox/4.0b13pre"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:16.0) Gecko/20100101 Firefox/16.0"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11"</span>,</div><div class="line">    <span class="string">"Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10"</span></div><div class="line">]</div><div class="line"><span class="comment"># 移动端user-agent代理头</span></div><div class="line">MOBILE_USER_AGENTS = [</div><div class="line"></div><div class="line">]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_header</span><span class="params">(end_type)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    :param end_type: WEB/MOBILE</span></div><div class="line"><span class="string">    :return: header</span></div><div class="line"><span class="string">    """</span></div><div class="line">    <span class="keyword">if</span> end_type == <span class="string">'WEB'</span>:</div><div class="line">        user_agent = random.choice(WEB_USER_AGENTS)</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        user_agent = random.choice(MOBILE_USER_AGENTS)</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="string">'User-Agent'</span>: user_agent,</div><div class="line">        <span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8'</span>,</div><div class="line">        <span class="string">'Accept-Language'</span>: <span class="string">'en-US,en;q=0.5'</span>,</div><div class="line">        <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</div><div class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate'</span>&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_timer</span><span class="params">(function)</span>:</span></div><div class="line"><span class="meta">    @wraps(function)</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">function_timer</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">        print(<span class="string">'[Function: &#123;name&#125; start...]'</span>.format(name = function.__name__))</div><div class="line">        t0 = time.time()</div><div class="line">        result = function(*args, **kwargs)</div><div class="line">        t1 = time.time()</div><div class="line">        print(<span class="string">'[Function: &#123;name&#125; finished, spent time: &#123;time:.2f&#125;s]'</span>.format(name = function.__name__,time = t1 - t0))</div><div class="line">        <span class="keyword">return</span> result</div><div class="line">    <span class="keyword">return</span> function_timer</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect_mongo</span><span class="params">(MONGODB)</span>:</span></div><div class="line">    <span class="string">"""</span></div><div class="line"><span class="string">    :param MONGODB: dict type</span></div><div class="line"><span class="string">    :return: db object</span></div><div class="line"><span class="string">    """</span></div><div class="line">    client = MongoClient(</div><div class="line">        <span class="string">'mongodb://&#123;&#125;:&#123;&#125;@&#123;&#125;/&#123;&#125;'</span>.format(MONGODB[<span class="string">'user'</span>],</div><div class="line">                                       MONGODB[<span class="string">'passwd'</span>],</div><div class="line">                                       MONGODB[<span class="string">'host'</span>],</div><div class="line">                                       MONGODB[<span class="string">'dbname'</span>]))</div><div class="line">    <span class="keyword">return</span> client[MONGODB[<span class="string">'dbname'</span>]]</div></pre></td></tr></table></figure></p><h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><p>logger.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> logging</div><div class="line"><span class="keyword">import</span> logging.handlers</div><div class="line"></div><div class="line">LOG_FORMAT = <span class="string">"%(asctime)s [%(levelname)s] [%(filename)s] [line:%(lineno)d]: %(message)s"</span></div><div class="line">DATA_LOG_FORMAT = <span class="string">"%m/%d/%Y %H:%M:%S"</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 使用root_logger</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_root_logger_settings</span><span class="params">(logConsole=True)</span>:</span></div><div class="line">    formatter = logging.Formatter(fmt=LOG_FORMAT, datefmt=DATA_LOG_FORMAT)</div><div class="line">    log_dir = os.path.join(os.path.dirname(os.path.abspath(__file__)), <span class="string">"logs"</span>)</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(log_dir):</div><div class="line">        os.mkdir(log_dir)</div><div class="line">    logging.getLogger().setLevel(logging.INFO)</div><div class="line">    log_name = os.path.join(log_dir, __name__.replace(<span class="string">'_'</span>, <span class="string">''</span>) <span class="keyword">if</span> <span class="string">'_'</span> <span class="keyword">in</span> __name__ <span class="keyword">else</span> __name__)</div><div class="line">    <span class="comment"># 文件输出日志</span></div><div class="line">    fh = logging.handlers.TimedRotatingFileHandler(</div><div class="line">        filename=log_name, when=<span class="string">'midnight'</span>, interval=<span class="number">1</span>, encoding=<span class="string">'utf-8'</span>)</div><div class="line">    fh.setLevel(logging.INFO)</div><div class="line">    fh.suffix = <span class="string">"%Y-%m-%d.log"</span></div><div class="line">    fh.setFormatter(formatter)</div><div class="line">    logging.getLogger().addHandler(fh)</div><div class="line">    <span class="comment"># 控制台输出日志</span></div><div class="line">    <span class="keyword">if</span> logConsole:</div><div class="line">        ch = logging.StreamHandler()</div><div class="line">        ch.setLevel(logging.DEBUG)</div><div class="line">        ch.setFormatter(formatter)</div><div class="line">        logging.getLogger().addHandler(ch)</div><div class="line"></div><div class="line">      </div><div class="line"><span class="comment"># 生成指定名称的logger</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logging</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, log_name=None, log_level=<span class="string">"info"</span>, console=True)</span>:</span></div><div class="line">        log_dir = os.path.join(os.path.dirname((os.path.dirname(os.path.abspath(__file__)))), <span class="string">"logs"</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(log_dir):</div><div class="line">            os.mkdir(log_dir)</div><div class="line">        <span class="keyword">if</span> log_name <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">            _log_name = os.path.join(log_dir, __name__.replace(<span class="string">'_'</span>, <span class="string">''</span>) <span class="keyword">if</span> <span class="string">'_'</span> <span class="keyword">in</span> __name__ <span class="keyword">else</span> __name__)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            _log_name = os.path.join(log_dir, log_name)</div><div class="line">        self.logObject = logging.getLogger(_log_name)</div><div class="line">        self._set_level(log_level)</div><div class="line">        <span class="comment"># 文件输出日志</span></div><div class="line">        fh = logging.handlers.TimedRotatingFileHandler(filename=_log_name,</div><div class="line">                                                       when=<span class="string">'midnight'</span>,</div><div class="line">                                                       interval=<span class="number">1</span>,</div><div class="line">                                                       encoding=<span class="string">'utf-8'</span>)</div><div class="line">        fh.suffix = <span class="string">"%Y-%m-%d.log"</span></div><div class="line">        formatter = logging.Formatter(fmt=LOG_FORMAT, datefmt=DATA_LOG_FORMAT)</div><div class="line">        fh.setLevel(logging.INFO)</div><div class="line">        fh.setFormatter(formatter)</div><div class="line">        self.logObject.addHandler(fh)</div><div class="line">        <span class="comment"># 控制台输出日志</span></div><div class="line">        <span class="keyword">if</span> console:</div><div class="line">            ch = logging.StreamHandler()</div><div class="line">            ch.setLevel(logging.DEBUG)</div><div class="line">            ch.setFormatter(formatter)</div><div class="line">            self.logObject.addHandler(ch)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_set_level</span><span class="params">(self, log_level)</span>:</span></div><div class="line">        <span class="keyword">if</span> log_level == <span class="string">"warning"</span>:</div><div class="line">            self.logObject.setLevel(logging.WARNING)</div><div class="line">        <span class="keyword">elif</span> log_level == <span class="string">"debug"</span>:</div><div class="line">            self.logObject.setLevel(logging.DEBUG)</div><div class="line">        <span class="keyword">elif</span> log_level == <span class="string">"error"</span>:</div><div class="line">            self.logObject.setLevel(logging.ERROR)</div><div class="line">        <span class="keyword">elif</span> log_level == <span class="string">"critical"</span>:</div><div class="line">            self.logObject.setLevel(logging.CRITICAL)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            self.logObject.setLevel(logging.INFO)</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全站爬虫简介&quot;&gt;&lt;a href=&quot;#全站爬虫简介&quot; class=&quot;headerlink&quot; title=&quot;全站爬虫简介&quot;&gt;&lt;/a&gt;全站爬虫简介&lt;/h2&gt;&lt;p&gt;python version: 3.6, 爬取全站url,并保存html到mongodb.&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="爬虫" scheme="http://arvin-he.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>linux之crontab使用</title>
    <link href="http://arvin-he.github.io/2018/01/25/linux-crontab-2018-01-25/"/>
    <id>http://arvin-he.github.io/2018/01/25/linux-crontab-2018-01-25/</id>
    <published>2018-01-25T05:43:48.000Z</published>
    <updated>2018-01-25T06:23:55.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="crond简介"><a href="#crond简介" class="headerlink" title="crond简介"></a>crond简介</h2><p>linux 系统则是由 cron (crond) 这个系统服务来控制的, 这个系统服务是默认启动的。<br>另外, 用户也可以设置计划任务，Linux 系统提供了用户控制计划任务的命令 :crontab 命令。</p><p>crond 是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，<br>当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，<br>如果有要执行的任务，则自动执行该任务。</p><p>Linux下的任务调度分为两类:系统任务调度和用户任务调度。</p><h3 id="系统任务调度"><a href="#系统任务调度" class="headerlink" title="系统任务调度"></a>系统任务调度</h3><p>系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># /etc/crontab文件包括下面几行：</span></div><div class="line">cat /etc/crontab</div><div class="line">SHELL=/bin/bash</div><div class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</div><div class="line">MAILTO=HOME=/</div><div class="line"><span class="comment"># run-parts</span></div><div class="line">51 * * * * root run-parts /etc/cron.hourly</div><div class="line">24 7 * * * root run-parts /etc/cron.daily</div><div class="line">22 4 * * 0 root run-parts /etc/cron.weekly</div><div class="line">42 4 1 * * root run-parts /etc/cron.monthly</div></pre></td></tr></table></figure></p><p>前四行是用来配置crond任务运行的环境变量，<br>第一行SHELL变量指定了系统要使用哪个shell，这里是bash，<br>第二行PATH变量指定了系统执行 命令的路径，<br>第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务 执行信息给用户，<br>第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。</p><h3 id="用户任务调度"><a href="#用户任务调度" class="headerlink" title="用户任务调度"></a>用户任务调度</h3><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。<br>用户可以使用 crontab 工具来定制自己的计划任务。<br>所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。</p><p>使用者权限文件：<br>文件：/etc/cron.deny<br>说明：该文件中所列用户不允许使用crontab命令<br>文件：/etc/cron.allow<br>说明：该文件中所列用户允许使用crontab命令<br>文件：/var/spool/cron/<br>说明：所有用户crontab文件存放的目录,以用户名命名</p><p>crontab文件的含义：<br>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：<code>minute hour day month week command</code><br>其中：<br>minute： 表示分钟，可以是从0到59之间的任何整数。<br>hour：表示小时，可以是从0到23之间的任何整数。<br>day：表示日期，可以是从1到31之间的任何整数。<br>month：表示月份，可以是从1到12之间的任何整数。<br>week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。<br>command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件,如python脚本。<br><img src="/2018/01/25/linux-crontab-2018-01-25/1.png" alt=""></p><p>在以上各个字段中，还可以使用以下特殊字符：<br>星号（<em>）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。<br>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”<br>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”<br>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如</em>/10，如果用在minute字段，表示每十分钟执行一次。</p><h2 id="crond服务"><a href="#crond服务" class="headerlink" title="crond服务"></a>crond服务</h2><p>安装crontab：<code>yum install crontabs</code><br>服务操作说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/sbin/service crond start //启动服务</div><div class="line">/sbin/service crond stop //关闭服务</div><div class="line">/sbin/service crond restart //重启服务</div><div class="line">/sbin/service crond reload //重新载入配置</div><div class="line">/sbin/service crond status //启动服务</div></pre></td></tr></table></figure></p><p>查看crontab服务是否已设置为开机启动，执行命令：<code>ntsysv</code><br>加入开机自动启动：<code>chkconfig –level 35 crond on</code></p><h2 id="crontab命令详解"><a href="#crontab命令详解" class="headerlink" title="crontab命令详解"></a>crontab命令详解</h2><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">crontab [-u user] file</div><div class="line">crontab [-u user] [ -e | -l | -r ]</div></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。<br>时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。<br>这个命令非常设合周期性的日志分析或数据备份等工作。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p><code>-u user</code>：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。<br><code>file</code>：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。<br>如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。<br>-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。<br>-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。<br>-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。<br>-i：在删除用户的crontab文件时给确认提示。</p><h3 id="4．常用方法："><a href="#4．常用方法：" class="headerlink" title="4．常用方法："></a>4．常用方法：</h3><h3 id="1-创建一个新的crontab文件"><a href="#1-创建一个新的crontab文件" class="headerlink" title="1). 创建一个新的crontab文件"></a>1). 创建一个新的crontab文件</h3><p>在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑 crontab文件。99%的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑<code>$HOME</code>目录下的<code>.profile</code>文件，在其 中加入这样一行：<code>EDITOR=vi; export EDITOR</code>, 然后保存并退出。不妨创建一个名为<code>&lt;user&gt;</code> cron的文件，其中<code>&lt;user&gt;</code>是用户名，例如，davecron。在该文件中加入如下的内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># (put your own initials here)echo the date to the console every</div><div class="line"># 15minutes between 6pm and 6am</div><div class="line">0,15,30,45 18-06 * * * /bin/echo ‘date’ &gt; /dev/console</div></pre></td></tr></table></figure></p><p>保存并退出。确信前面5个域用空格分隔。<br>在上面的例子中，系统将每隔15分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些 系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为 cron命令的参数：<code>$ crontab davecron</code>, 现在该文件已经提交给cron进程，它将每隔15分钟运行一次。同时，新创建文件的一个副本已经被放在<code>/var/spool/cron</code>目录中，文件名就是用户名(即dave)。</p><h3 id="2-列出crontab文件"><a href="#2-列出crontab文件" class="headerlink" title="2). 列出crontab文件"></a>2). 列出crontab文件</h3><p>为了列出crontab文件，可以用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ crontab -l</div><div class="line">0,15,30,45,18-06 * * * /bin/echo `date` &gt; dev/tty1</div></pre></td></tr></table></figure></p><p>你将会看到和上面类似的内容。可以使用这种方法在<code>$HOME</code>目录中对crontab文件做一备份：<br><code>$ crontab -l &gt; $HOME/mycron</code>,这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p><h3 id="3-编辑crontab文件"><a href="#3-编辑crontab文件" class="headerlink" title="3). 编辑crontab文件"></a>3). 编辑crontab文件</h3><p>如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件，相应的命令为：<code>$ crontab -e</code><br>可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时，cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。<br>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</div><div class="line">30 3 1,7,14,21,26 * * /bin/find -name “core’ -exec rm &#123;&#125; \;</div></pre></td></tr></table></figure></p><p>现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。</p><p>现在让我们使用前面讲过的crontab -l命令列出它的全部信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ crontab -l</div><div class="line"># (crondave installed on Tue May 4 13:07:43 1999)</div><div class="line"># DT:ech the date to the console every 30 minites</div><div class="line">0,15,30,45 18-06 * * * /bin/echo `date` &gt; /dev/tty1</div><div class="line"># DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</div><div class="line">30 3 1,7,14,21,26 * * /bin/find -name “core’ -exec rm &#123;&#125; \;</div></pre></td></tr></table></figure></p><h3 id="4-删除crontab文件"><a href="#4-删除crontab文件" class="headerlink" title="4). 删除crontab文件"></a>4). 删除crontab文件</h3><p>要删除crontab文件，可以用：<code>$ crontab -r</code></p><h3 id="5-恢复丢失的crontab文件"><a href="#5-恢复丢失的crontab文件" class="headerlink" title="5). 恢复丢失的crontab文件"></a>5). 恢复丢失的crontab文件</h3><p>如果不小心误删了crontab文件，假设你在自己的<code>$HOME</code>目录下还有一个备份，那么可以将其拷贝到<code>/var/spool/cron/&lt;username&gt;</code>，其中<code>&lt;username&gt;</code>是用户名。如果由于权限问题无法完成拷贝，可以用：<code>$ crontab &lt;filename&gt;</code>.其中，<code>&lt;filename&gt;</code>是你在$HOME目录中副本的文件名。</p><p>我建议你在自己的<code>$HOME</code>目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。</p><p>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<ctrl-d>，否则你将丢失crontab文件。</ctrl-d></p><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>实例1：每1分钟执行一次command<br>命令：<code>* * * * * command</code><br>实例2：每小时的第3和第15分钟执行<br>命令：<code>3,15 * * * * command</code><br>实例3：在上午8点到11点的第3和第15分钟执行<br>命令：<code>3,15 8-11 * * * command</code><br>实例4：每隔两天的上午8点到11点的第3和第15分钟执行<br>命令：<code>3,15 8-11 */2 * * command</code><br>实例5：每个星期一的上午8点到11点的第3和第15分钟执行<br>命令：<code>3,15 8-11 * * 1 command</code><br>实例6：每晚的21:30重启smb<br>命令：<code>30 21 * * * /etc/init.d/smb restart</code><br>实例7：每月1、10、22日的4 : 45重启smb<br>命令：<code>45 4 1,10,22 * * /etc/init.d/smb restart</code><br>实例8：每周六、周日的1 : 10重启smb<br>命令：<code>10 1 * * 6,0 /etc/init.d/smb restart</code><br>实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb<br>命令：<code>0,30 18-23 * * * /etc/init.d/smb restart</code><br>实例10：每星期六的晚上11 : 00 pm重启smb<br>命令：<code>0 23 * * 6 /etc/init.d/smb restart</code><br>实例11：每一小时重启smb<br>命令：<code>* */1 * * * /etc/init.d/smb restart</code><br>实例12：晚上11点到早上7点之间，每隔一小时重启smb<br>命令：<code>* 23-7/1 * * * /etc/init.d/smb restart</code><br>实例13：每月的4号与每周一到周三的11点重启smb<br>命令：<code>0 11 4 * mon-wed /etc/init.d/smb restart</code><br>实例14：一月一号的4点重启smb<br>命令：<code>0 4 1 jan * /etc/init.d/smb restart</code><br>实例15：每小时执行/etc/cron.hourly目录内的脚本<br>命令：<code>01 * * * * root run-parts /etc/cron.hourly</code><br>说明：run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</p><h2 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h2><ul><li><p>注意环境变量问题, 有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。</p></li><li><p>在 crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程 序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这 样，系统执行任务调度时就没有问题了。</p></li><li><p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p><ol><li>脚本中涉及文件路径时写全局路径；</li><li>脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># cat start_cbp.sh</span></div><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"><span class="built_in">source</span> /etc/profile</div><div class="line"><span class="built_in">export</span> RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</div><div class="line">/usr/<span class="built_in">local</span>/jboss-4.0.5/bin/run.sh -c mev &amp;</div></pre></td></tr></table></figure></li></ol></li><li><p>当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</div></pre></td></tr></table></figure></li><li><p>注意清理系统用户的邮件日志,每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。例如，可以在crontab文件中设置如下形式，忽略日志输出：<code>0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</code>“/dev/null 2&gt;&amp;1”表示先将标准输出重定向到/dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。</p></li><li><p>系统级任务调度与用户级任务调度,系 统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么 做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc /crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个 定时重启系统的任务也是无效的。</p></li></ul><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ol><li><p>新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。</p></li><li><p>当crontab突然失效时，可以尝试<code>/etc/init.d/crond restart</code>解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。</p></li><li><p>千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义\%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+\%Y\%m\%d’。</p></li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://www.cnblogs.com/intval/p/5763929.html" target="_blank" rel="external">Linux定时任务Crontab命令详解</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;crond简介&quot;&gt;&lt;a href=&quot;#crond简介&quot; class=&quot;headerlink&quot; title=&quot;crond简介&quot;&gt;&lt;/a&gt;crond简介&lt;/h2&gt;&lt;p&gt;linux 系统则是由 cron (crond) 这个系统服务来控制的, 这个系统服务是默认启动的。
      
    
    </summary>
    
      <category term="linux" scheme="http://arvin-he.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="http://arvin-he.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>scrapy笔记</title>
    <link href="http://arvin-he.github.io/2018/01/16/py-scrapy2-2018-01-16/"/>
    <id>http://arvin-he.github.io/2018/01/16/py-scrapy2-2018-01-16/</id>
    <published>2018-01-16T08:01:23.000Z</published>
    <updated>2018-01-16T09:51:54.739Z</updated>
    
    <content type="html"><![CDATA[<h2 id="scrapy命令行工具-command-line-tools"><a href="#scrapy命令行工具-command-line-tools" class="headerlink" title="scrapy命令行工具(command line tools)"></a>scrapy命令行工具(command line tools)</h2><h3 id="查看scrapy所有可用的命令"><a href="#查看scrapy所有可用的命令" class="headerlink" title="查看scrapy所有可用的命令"></a>查看scrapy所有可用的命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy -h</div></pre></td></tr></table></figure><h3 id="查看某个命令具体用法-以startproject为例子"><a href="#查看某个命令具体用法-以startproject为例子" class="headerlink" title="查看某个命令具体用法,以startproject为例子"></a>查看某个命令具体用法,以startproject为例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject -h</div></pre></td></tr></table></figure><h3 id="创建爬虫项目"><a href="#创建爬虫项目" class="headerlink" title="创建爬虫项目"></a>创建爬虫项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy startproject myproject</div></pre></td></tr></table></figure><h3 id="创建一个新的spider"><a href="#创建一个新的spider" class="headerlink" title="创建一个新的spider"></a>创建一个新的spider</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scrapy genspider mydomain mydomain.com</div></pre></td></tr></table></figure><h3 id="启动终端"><a href="#启动终端" class="headerlink" title="启动终端"></a>启动终端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scrapy shell &lt;url&gt;</div><div class="line">如: scrapy shell https://www.baidu.com</div></pre></td></tr></table></figure><h3 id="针对通用爬虫设定的一些建议"><a href="#针对通用爬虫设定的一些建议" class="headerlink" title="针对通用爬虫设定的一些建议"></a>针对通用爬虫设定的一些建议</h3><p>增加并发<br>并发是指同时处理的 request 的数量。其有全局限制和局部(每个网站)的限制。<br>Scrapy 默认的全局并发限制对同时爬取大量网站的情况并不适用，因此需要增加这个值。<br>增加全局并发数<br>CONCURRENT_REQUESTS = 100<br>设置 Log 级别：<br>LOG_LEVEL = ‘INFO’<br>禁止 cookies,禁止 cookies 能减少 CPU 使用率及 Scrapy 爬虫在内存中记录的踪迹，提高性能。<br>COOKIES_ENABLED = False<br>禁止重试,当站点响应很慢(甚至失败)时， 访问这样的站点会造成超时并重试多次。这是不必要的，同时也占用了爬虫爬取其他站点的能力。<br>RETRY_ENABLED = False<br>减小下载超时,减小下载超时能让卡住的连接能被快速的放弃并解放处理其他站点的能力。<br>DOWNLOAD_TIMEOUT = 15<br>禁止重定向,当进行通用爬取时，一般的做法是保存重定向的地址，并在之后的爬取进行解析。否则重定向循环可能会导致爬虫在某个站点耗费过多资源。<br>REDIRECT_ENABLED = False<br>启用 “Ajax Crawlable Pages” 爬取,有些站点声明其为 ajax crawlabl。这意味着该网站提供了原本只有 ajax 获取到的数据的纯 HTML 版本。网站通过两种方法声明：<br>(1)在 url 中使用#! - 这是默认的方式;<br>(2)使用特殊的 meta 标签 - 这在”main”, “index” 页面中使用。<br>Scrapy 自动解决(1)；解决(2)您需要启用 AjaxCrawlMiddleware：<br>AJAXCRAWL_ENABLED = True</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;scrapy命令行工具-command-line-tools&quot;&gt;&lt;a href=&quot;#scrapy命令行工具-command-line-tools&quot; class=&quot;headerlink&quot; title=&quot;scrapy命令行工具(command line tools)&quot;
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="scrapy" scheme="http://arvin-he.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>scrapy笔记-安装</title>
    <link href="http://arvin-he.github.io/2018/01/15/py-scrapy1-2018-01-15/"/>
    <id>http://arvin-he.github.io/2018/01/15/py-scrapy1-2018-01-15/</id>
    <published>2018-01-15T09:32:19.000Z</published>
    <updated>2018-01-16T08:01:57.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="windows下scrapy安装"><a href="#windows下scrapy安装" class="headerlink" title="windows下scrapy安装"></a>windows下scrapy安装</h2><h3 id="下载依赖的第三方离线包"><a href="#下载依赖的第三方离线包" class="headerlink" title="下载依赖的第三方离线包"></a>下载依赖的第三方离线包</h3><p>到 <a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#twisted" target="_blank" rel="external">这个地址</a>下载一些在windows平台编译的第三方库.</p><ol><li>pywin32</li><li>twisted<br><strong>注意:</strong> 根据python的版本下载对应的离线包.</li></ol><h3 id="安装或更新依赖的第三方离线包"><a href="#安装或更新依赖的第三方离线包" class="headerlink" title="安装或更新依赖的第三方离线包"></a>安装或更新依赖的第三方离线包</h3><p>下载好后就安装</p><ol><li>在控制台切换目录到离线包所在的目录</li><li>安装离线包<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install pywin32</div><div class="line">pip install twisted</div></pre></td></tr></table></figure></li></ol><p>如果是更新包则:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install pywin32 -U</div><div class="line">pip install twisted -U</div></pre></td></tr></table></figure></p><h3 id="安装或更新scrapy"><a href="#安装或更新scrapy" class="headerlink" title="安装或更新scrapy"></a>安装或更新scrapy</h3><p>下载安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install scrapy</div></pre></td></tr></table></figure></p><p>下载更新<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install scrapy -U</div></pre></td></tr></table></figure></p><h3 id="import-win32api-出现ImportError-DLL-load-failed-错误的解决方法"><a href="#import-win32api-出现ImportError-DLL-load-failed-错误的解决方法" class="headerlink" title="import win32api 出现ImportError: DLL load failed 错误的解决方法"></a>import win32api 出现ImportError: DLL load failed 错误的解决方法</h3><p>windows下使用scrapy,出现出现ImportError: DLL load failed 错误,网上解决方法大多是安装pywin32,可是安装后还是会出错.<br>之后又试了一下网上的方法:将\Lib\site-packages\pywin32_system32*拷贝至C:\Windows\System32目录下,仍然出错.<br>最后,找到一个好方法:安装pypiwin32<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pypiwin32</div></pre></td></tr></table></figure></p><p>然后再开始执行scrapy就顺利运行了.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;windows下scrapy安装&quot;&gt;&lt;a href=&quot;#windows下scrapy安装&quot; class=&quot;headerlink&quot; title=&quot;windows下scrapy安装&quot;&gt;&lt;/a&gt;windows下scrapy安装&lt;/h2&gt;&lt;h3 id=&quot;下载依赖的第三方离
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="scrapy" scheme="http://arvin-he.github.io/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>python之pip常用命令</title>
    <link href="http://arvin-he.github.io/2018/01/15/py-pipcmds-2018-01-15/"/>
    <id>http://arvin-he.github.io/2018/01/15/py-pipcmds-2018-01-15/</id>
    <published>2018-01-15T09:08:06.000Z</published>
    <updated>2018-01-15T09:15:40.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pip常用命令"><a href="#pip常用命令" class="headerlink" title="pip常用命令"></a>pip常用命令</h2><h3 id="1-安装第三方库"><a href="#1-安装第三方库" class="headerlink" title="1. 安装第三方库"></a>1. 安装第三方库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip install scrapy</div><div class="line">python -m pip install scrapy</div></pre></td></tr></table></figure><h3 id="2-更新第三方库"><a href="#2-更新第三方库" class="headerlink" title="2. 更新第三方库"></a>2. 更新第三方库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install scrapy -U</div></pre></td></tr></table></figure><h3 id="3-制作本地-whl安装离线包"><a href="#3-制作本地-whl安装离线包" class="headerlink" title="3. 制作本地*.whl安装离线包"></a>3. 制作本地*.whl安装离线包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip wheel pycrpyo</div></pre></td></tr></table></figure><h3 id="4-导出pip-list列表到requirements-txt"><a href="#4-导出pip-list列表到requirements-txt" class="headerlink" title="4. 导出pip list列表到requirements.txt"></a>4. 导出pip list列表到requirements.txt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip freeze &gt; requirements.txt</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pip常用命令&quot;&gt;&lt;a href=&quot;#pip常用命令&quot; class=&quot;headerlink&quot; title=&quot;pip常用命令&quot;&gt;&lt;/a&gt;pip常用命令&lt;/h2&gt;&lt;h3 id=&quot;1-安装第三方库&quot;&gt;&lt;a href=&quot;#1-安装第三方库&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>css笔记1</title>
    <link href="http://arvin-he.github.io/2018/01/11/css-note1-2018-01-11/"/>
    <id>http://arvin-he.github.io/2018/01/11/css-note1-2018-01-11/</id>
    <published>2018-01-11T13:19:50.000Z</published>
    <updated>2018-01-15T09:47:58.272Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS样式优先级"><a href="#CSS样式优先级" class="headerlink" title="CSS样式优先级"></a>CSS样式优先级</h3><p>*(通配符) &lt; tag(标签) &lt; class &lt; 行间<br>style与class<br>元素.style.属性 = xxx 是修改行间样式<br>之后再修改className不会有效果</p><p>建议:<br>要么统一用style,要么统一用className,混用则容易产生错乱,也很难排查问题.</p><p>行为,样式,结构三者分离</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CSS样式优先级&quot;&gt;&lt;a href=&quot;#CSS样式优先级&quot; class=&quot;headerlink&quot; title=&quot;CSS样式优先级&quot;&gt;&lt;/a&gt;CSS样式优先级&lt;/h3&gt;&lt;p&gt;*(通配符) &amp;lt; tag(标签) &amp;lt; class &amp;lt; 行间&lt;br&gt;styl
      
    
    </summary>
    
      <category term="web" scheme="http://arvin-he.github.io/categories/web/"/>
    
    
      <category term="css" scheme="http://arvin-he.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>selenium-phatomjs使用</title>
    <link href="http://arvin-he.github.io/2017/12/11/selenium-phatomjs-2017-12-11/"/>
    <id>http://arvin-he.github.io/2017/12/11/selenium-phatomjs-2017-12-11/</id>
    <published>2017-12-11T12:42:16.000Z</published>
    <updated>2018-01-15T09:47:58.285Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用selenium和phantomjs爬取动态网页"><a href="#使用selenium和phantomjs爬取动态网页" class="headerlink" title="使用selenium和phantomjs爬取动态网页"></a>使用selenium和phantomjs爬取动态网页</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line">url = <span class="string">"http://www.dangniao.com/mh/22996/392953.html"</span></div><div class="line">browser = webdriver.PhantomJS(<span class="string">"/usr/local/mysoft/phantomjs-2.1.1/bin/phantomjs"</span>)</div><div class="line">browser.get(url)</div><div class="line"><span class="comment"># 模拟用户点击</span></div><div class="line">browser.find_element_by_class_name(<span class="string">"zsxiaye"</span>).click()</div><div class="line">src = browser.find_element_by_css_selector(<span class="string">"#wdwailian img"</span>).get_attribute(<span class="string">"src"</span>)</div></pre></td></tr></table></figure><h3 id="常用的phantomJS配置选项"><a href="#常用的phantomJS配置选项" class="headerlink" title="常用的phantomJS配置选项"></a>常用的phantomJS配置选项</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"><span class="comment"># 引入配置对象DesiredCapabilities</span></div><div class="line"><span class="keyword">from</span> selenium.webdriver.common.desired_capabilities <span class="keyword">import</span> DesiredCapabilities</div><div class="line">dcap = dict(DesiredCapabilities.PHANTOMJS)</div><div class="line"><span class="comment">#从USER_AGENTS列表中随机选一个浏览器头，伪装浏览器</span></div><div class="line">dcap[<span class="string">"phantomjs.page.settings.userAgent"</span>] = (random.choice(USER_AGENTS))</div><div class="line"><span class="comment"># 不载入图片，爬页面速度会快很多</span></div><div class="line">dcap[<span class="string">"phantomjs.page.settings.loadImages"</span>] = <span class="keyword">False</span></div><div class="line"><span class="comment"># 设置代理</span></div><div class="line">service_args = [<span class="string">'--proxy=127.0.0.1:9999'</span>,<span class="string">'--proxy-type=socks5'</span>]</div><div class="line"><span class="comment">#打开带配置信息的phantomJS浏览器</span></div><div class="line">driver = webdriver.PhantomJS(phantomjs_driver_path, desired_capabilities=dcap,service_args=service_args)                </div><div class="line"><span class="comment"># 隐式等待5秒，可以自己调节</span></div><div class="line">driver.implicitly_wait(<span class="number">5</span>)</div><div class="line"><span class="comment"># 设置10秒页面超时返回，类似于requests.get()的timeout选项，driver.get()没有timeout选项</span></div><div class="line"><span class="comment"># 以前遇到过driver.get(url)一直不返回，但也不报错的问题，这时程序会卡住，设置超时选项能解决这个问题。</span></div><div class="line">driver.set_page_load_timeout(<span class="number">10</span>)</div><div class="line"><span class="comment"># 设置10秒脚本超时时间</span></div><div class="line">driver.set_script_timeout(<span class="number">10</span>)</div></pre></td></tr></table></figure><h3 id="phantomJS的并发问题"><a href="#phantomJS的并发问题" class="headerlink" title="phantomJS的并发问题"></a>phantomJS的并发问题</h3><p>phantomJS本身在多线程方面还有很多bug，建议使用多进程,关于多进程，推荐使用multiprocessing库，简洁、高效.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</div><div class="line">pool = Pool(<span class="number">8</span>)</div><div class="line">data_list = pool.map(get, url_list)</div><div class="line">pool.close()</div><div class="line">pool.join()</div></pre></td></tr></table></figure></p><h3 id="phantomJS进程不自动退出问题"><a href="#phantomJS进程不自动退出问题" class="headerlink" title="phantomJS进程不自动退出问题"></a>phantomJS进程不自动退出问题</h3><p>主程序退出后，selenium不保证phantomJS也成功退出，最好手动关闭phantomJS进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span>:</div><div class="line">    self.driver.get(url)</div><div class="line">    self.wait_()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">    <span class="comment"># 手动关闭phantomjs进程</span></div><div class="line">    self.driver.quit()</div><div class="line">    <span class="keyword">return</span> <span class="keyword">False</span></div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用selenium和phantomjs爬取动态网页&quot;&gt;&lt;a href=&quot;#使用selenium和phantomjs爬取动态网页&quot; class=&quot;headerlink&quot; title=&quot;使用selenium和phantomjs爬取动态网页&quot;&gt;&lt;/a&gt;使用seleni
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>jQuery笔记</title>
    <link href="http://arvin-he.github.io/2017/12/08/jQuery-notes1-2017-12-08/"/>
    <id>http://arvin-he.github.io/2017/12/08/jQuery-notes1-2017-12-08/</id>
    <published>2017-12-08T09:31:58.000Z</published>
    <updated>2017-12-08T09:59:27.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="jQuery介绍"><a href="#jQuery介绍" class="headerlink" title="jQuery介绍"></a>jQuery介绍</h3><p>jQuery是JavaScript世界中使用最广泛的一个库。<br>jQuery能帮我们干这些事情：</p><ul><li>消除浏览器差异：你不需要自己写冗长的代码来针对不同的浏览器来绑定事件，编写AJAX等代码；</li><li>简洁的操作DOM的方法：写$(‘#test’)肯定比document.getElementById(‘test’)来得简洁；</li><li>轻松实现动画、修改CSS等各种操作。<br>jQuery的理念“Write Less, Do More“，让你写更少的代码，完成更多的工作！</li></ul><p>目前jQuery有1.x和2.x两个主要版本，区别在于2.x移除了对古老的IE 6、7、8的支持，<br>因此2.x的代码更精简。选择哪个版本主要取决于你是否想支持IE 6~8。<br>jQuery只是一个jquery-xxx.js文件，但你会看到有compressed（已压缩）和uncompressed（未压缩）两种版本，使用时完全一样，<br>但如果你想深入研究jQuery源码，那就用uncompressed版本。</p><h3 id="jQuery使用"><a href="#jQuery使用" class="headerlink" title="jQuery使用"></a>jQuery使用</h3><p>$是著名的jQuery符号。jQuery把所有功能全部封装在一个全局变量jQuery中，而$也是一个合法的变量名，它是变量jQuery的别名：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.jQuery; <span class="comment">// jQuery(selector, context)</span></div><div class="line"><span class="built_in">window</span>.$; <span class="comment">// jQuery(selector, context)</span></div><div class="line">$ === jQuery; <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span>($); <span class="comment">// 'function'</span></div></pre></td></tr></table></figure></p><p>$本质上就是一个函数，但是函数也是对象，于是$除了可以直接调用外，也可以有很多其他属性。</p><p><strong>注意:</strong> 你看到的$函数名可能不是jQuery(selector, context)，因为很多JavaScript压缩工具可以对函数名和参数改名，<br>压缩过的jQuery源码$函数可能变成a(b, c)。这也被叫做代码混淆,也起到一定的安全作用.</p><p>绝大多数时候，直接用$,但是，如果$这个变量被占用了，而且还不能改，那我们就只能让jQuery把$变量交出来，然后就只能使用jQuery这个变量.</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>选择器是jQuery的核心。一个选择器写出来类似$(‘#dom-id’)。<br>Query的选择器就是帮助我们快速定位到一个或多个DOM节点。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 按ID查找,注意: #abc以#开头。返回的对象是jQuery对象。</span></div><div class="line"><span class="comment">// 查找&lt;div id="abc"&gt;:</span></div><div class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>);</div><div class="line"></div><div class="line"><span class="comment">// 按tag查找</span></div><div class="line"><span class="keyword">var</span> ps = $(<span class="string">'p'</span>); <span class="comment">// 返回所有&lt;p&gt;节点</span></div><div class="line">ps.length; <span class="comment">// 数一数页面有多少个&lt;p&gt;节点</span></div><div class="line"></div><div class="line"><span class="comment">// 按class查找, 按class查找注意在class名称前加一个.</span></div><div class="line"><span class="keyword">var</span> a = $(<span class="string">'.red'</span>); <span class="comment">// 所有节点包含`class="red"`都将返回</span></div><div class="line"><span class="comment">// 例如:</span></div><div class="line"><span class="comment">// &lt;div class="red"&gt;...&lt;/div&gt;</span></div><div class="line"><span class="comment">// &lt;p class="green red"&gt;...&lt;/p&gt;</span></div><div class="line"><span class="comment">// 节点有多个class，我们可以查找同时包含red和green的节点：</span></div><div class="line"><span class="keyword">var</span> a = $(<span class="string">'.red.green'</span>); <span class="comment">// 注意没有空格！</span></div><div class="line"><span class="comment">// 符合条件的节点：</span></div><div class="line"><span class="comment">// &lt;div class="red green"&gt;...&lt;/div&gt;</span></div><div class="line"><span class="comment">// &lt;div class="blue green red"&gt;...&lt;/div&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// 按属性查找</span></div><div class="line"><span class="keyword">var</span> email = $(<span class="string">'[name=email]'</span>); <span class="comment">// 找出&lt;??? name="email"&gt;</span></div><div class="line"><span class="keyword">var</span> icons = $(<span class="string">'[name^=icon]'</span>); <span class="comment">// 找出所有name属性值以icon开头的DOM</span></div><div class="line"><span class="keyword">var</span> names = $(<span class="string">'[name$=with]'</span>); <span class="comment">// 找出所有name属性值以with结尾的DOM</span></div><div class="line"><span class="keyword">var</span> icons = $(<span class="string">'[class^="icon-"]'</span>); <span class="comment">// 找出所有class包含至少一个以`icon-`开头的DOM</span></div></pre></td></tr></table></figure></p><p>组合查找<br><code>var emailInput = $(&#39;input[name=email]&#39;); // 不会找出&lt;div name=&quot;email&quot;&gt;</code><br><code>var tr = $(&#39;tr.red&#39;); // 找出&lt;tr class=&quot;red ...&quot;&gt;...&lt;/tr&gt;</code></p><p>多项选择器<br>多项选择器就是把多个选择器用,组合起来一块选：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">'p,div'</span>); <span class="comment">// 把&lt;p&gt;和&lt;div&gt;都选出来</span></div><div class="line">$(<span class="string">'p.red,p.green'</span>); <span class="comment">// 把&lt;p class="red"&gt;和&lt;p class="green"&gt;都选出来</span></div></pre></td></tr></table></figure></p><p>总之jQuery的选择器不会返回undefined或者null，这样的好处是你不必在下一行判断if (div === undefined)。<br>jQuery对象和DOM对象之间可以互相转化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> div = $(<span class="string">'#abc'</span>); <span class="comment">// jQuery对象</span></div><div class="line"><span class="keyword">var</span> divDom = div.get(<span class="number">0</span>); <span class="comment">// 假设存在div，获取第1个DOM元素</span></div><div class="line"><span class="keyword">var</span> another = $(divDom); <span class="comment">// 重新把DOM包装为jQuery对象</span></div></pre></td></tr></table></figure></p><p>通常情况下你不需要获取DOM对象，直接使用jQuery对象更加方便。<br>如果你拿到了一个DOM对象，那可以简单地调用$(aDomObject)把它变成jQuery对象，这样就可以方便地使用jQuery的API了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;jQuery介绍&quot;&gt;&lt;a href=&quot;#jQuery介绍&quot; class=&quot;headerlink&quot; title=&quot;jQuery介绍&quot;&gt;&lt;/a&gt;jQuery介绍&lt;/h3&gt;&lt;p&gt;jQuery是JavaScript世界中使用最广泛的一个库。&lt;br&gt;jQuery能帮我们干这
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>javascript之DOM操作</title>
    <link href="http://arvin-he.github.io/2017/12/08/js-dom-2017-12-08/"/>
    <id>http://arvin-he.github.io/2017/12/08/js-dom-2017-12-08/</id>
    <published>2017-12-08T08:00:15.000Z</published>
    <updated>2017-12-08T09:30:35.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><p>DOM是一个树形结构, 常用操作有:更新, 遍历, 添加, 删除</p><p>获取dom节点的方法:<br>document.getElementById()<br>document.getElementsByTagName()<br>document.getElementsByClassName() //CSS选择器<br>可以连续调用: <code>var trs = document.getElementById(&#39;test-table&#39;).getElementsByTagName(&#39;tr&#39;);</code></p><p>使用selector语法:<br>querySelector()<br>querySelectorAll()<br><strong>注意:</strong> 低版本的IE&lt;8不支持querySelector和querySelectorAll。IE8仅有限支持。</p><p>根节点Document已经自动绑定为全局变量document。<br>严格地讲，我们这里的DOM节点是指Element，但是DOM节点实际上是Node，<br>在HTML中，Node包括Element、Comment、CDATA_SECTION等很多种，以及根节点Document类型，但是，绝大多数时候我们只关心Element.</p><h3 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h3><p>直接修改节点的文本，方法有两种:</p><ol><li><p>修改innerHTML属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树.<br><strong>注意:</strong> 在写入HTML。如果写入的字符串是通过网络拿到了，要注意对字符编码来避免XSS攻击。</p></li><li><p>修改innerText或textContent属性，这样可以自动对字符串进行HTML编码，保证无法设置任何HTML标签.<br>innerText不返回隐藏元素的文本，而textContent返回所有文本。另外注意IE&lt;9不支持textContent。</p></li></ol><p>DOM节点的style属性对应所有的CSS，可以直接获取或设置。<br><strong>注意:</strong>CSS允许font-size这样的名称，但它并非JavaScript有效的属性名，需要在JavaScript中改写为驼峰式命名fontSize.</p><h3 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h3><p>两个办法可以插入新的节点</p><ol><li>使用appendChild，把一个子节点添加到父节点的最后一个子节点</li><li>使用insertBefore, 使用parentElement.insertBefore(newElement, referenceElement);，子节点会插入到referenceElement之前。</li></ol><h3 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h3><ol><li>调用父节点的removeChild把当前节点删掉<br><strong>注意:</strong>删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置</li></ol><p>当遍历一个父节点的子节点并进行删除操作时，要注意，children属性是一个<strong>只读</strong>属性，并且它在子节点变化时会实时更新<br>删除多个节点时，要注意children属性时刻都在变化, 容易造成index溢出.</p><h3 id="表单操作"><a href="#表单操作" class="headerlink" title="表单操作"></a>表单操作</h3><p>HTML表单的输入控件主要有以下几种：</p><ul><li>文本框，对应的<input type="text">，用于输入文本；</li><li>口令框，对应的<input type="password">，用于输入口令；</li><li>单选框，对应的<input type="radio">，用于选择一项；</li><li>复选框，对应的<input type="checkbox">，用于选择多项；</li><li>下拉框，对应的<select>，用于选择一项；</select></li><li>隐藏文本，对应的<input type="hidden">，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li></ul><p>直接调用value获得对应的用户输入值, <code>input.value; // &#39;用户输入的值&#39;</code><br>对于单选框和复选框，value属性返回的永远是HTML预设的值，要获得的实际是用户是否“勾上了”选项，应该用checked判断.</p><h3 id="HTML5控件"><a href="#HTML5控件" class="headerlink" title="HTML5控件"></a>HTML5控件</h3><p>HTML5新增了大量标准控件，常用的包括date、datetime、datetime-local、color等，它们都使用<code>&lt;input&gt;</code>标签.<br>不支持HTML5的浏览器无法识别新的控件，会把它们当做type=”text”来显示。支持HTML5的浏览器将获得格式化的字符串</p><h3 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h3><p>第一种方式:通过<code>&lt;form&gt;</code>元素的submit()方法提交一个表单, 这种方式的缺点是扰乱了浏览器对form的正常提交。<br>浏览器默认点击<code>&lt;button type=&quot;submit&quot;&gt;</code>或用户在最后一个输入框按回车键时提交表单。</p><p>第二种方式:响应<code>&lt;form&gt;</code>本身的onsubmit事件，在提交form时作修改.<br>出于安全考虑，提交表单时不传输明文口令，而是口令的MD5, 口令框的显示会突然从几个<code>*</code>变成32个<code>*</code>,(MD5有32个字符)<br>要想不改变用户的输入，可以利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现.</p><p>注意到id为md5-password的<code>&lt;input&gt;</code>标记了name=”password”，而用户输入的id为input-password的<code>&lt;input&gt;</code>没有name属性。<br>没有name属性的<code>&lt;input&gt;</code>的数据不会被提交。</p><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code><br><strong>注意：</strong> 当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的enctype必须指定为multipart/form-data，method必须指定为post，<br>这样浏览器才能正确编码并以multipart/form-data格式发送表单的数据。<br>出于安全考虑，浏览器只允许用户点击<code>&lt;input type=&quot;file&quot;&gt;</code>来选择本地文件，用JavaScript对<code>&lt;input type=&quot;file&quot;&gt;</code>的value赋值是没有任何效果的。当用户选择了上传某个文件后，JavaScript也无法获得该文件的真实路径</p><p>File API<br>随着HTML5的普及，新增的File API允许JavaScript读取文件内容，获得更多的文件信息。<br>HTML5的File API提供了File和FileReader两个主要对象，可以获得文件信息并读取文件。</p><h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，<br>也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行.<br>在JavaScript中，执行多任务实际上都是异步调用.</p><h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>Asynchronous JavaScript and XML，意思就是用JavaScript执行异步网络请求。<br>通过检测window对象是否有XMLHttpRequest属性来确定浏览器是否支持标准的XMLHttpRequest,<br>不要根据浏览器的navigator.userAgent来检测浏览器是否支持某个JavaScript特性.</p><h3 id="安全限制"><a href="#安全限制" class="headerlink" title="安全限制"></a>安全限制</h3><p>由于浏览器的同源策略,默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致,<br>即域名,协议和端口号要一致.有的浏览器可能允许端口不同.<br>那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：<br>一是: 通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。<br>二是:通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器,代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。<br>第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源.JSONP通常以函数调用的形式返回</p><p>CORS(Cross-Origin Resource Sharing): 是HTML5规范定义的如何跨域访问资源<br>Origin表示本域，也就是浏览器当前页面的域。当JavaScript向外域（如sina.com）发起请求后，浏览器收到响应后，首先检查Access-Control-Allow-Origin是否包含本域，如果是，则此次跨域请求成功，如果不是，则请求失败，JavaScript将无法获取到响应的任何数据。<br>假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。<br>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的Access-Control-Allow-Origin，决定权始终在对方手中。</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了.<br>Promise还可以做更多的事情，比如，有若干个异步任务，需要先做任务1，如果成功后再做任务2，任何任务失败则不再继续并执行错误处理函数。<br><code>job1.then(job2).then(job3).catch(handleError);</code> ,其中，job1、job2和job3都是Promise对象。</p><h3 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h3><p>Canvas是HTML5新增的组件，它就像一块幕布，可以用JavaScript在上面绘制各种图表、动画等。<br>没有Canvas的年代，绘图只能借助Flash插件实现，页面不得不用JavaScript和Flash进行交互。<br>有了Canvas，我们就再也不需要Flash了，直接使用JavaScript完成绘制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DOM操作&quot;&gt;&lt;a href=&quot;#DOM操作&quot; class=&quot;headerlink&quot; title=&quot;DOM操作&quot;&gt;&lt;/a&gt;DOM操作&lt;/h3&gt;&lt;p&gt;DOM是一个树形结构, 常用操作有:更新, 遍历, 添加, 删除&lt;/p&gt;
&lt;p&gt;获取dom节点的方法:&lt;br&gt;doc
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Appium笔记</title>
    <link href="http://arvin-he.github.io/2017/12/08/appium-notes1-2017-12-08/"/>
    <id>http://arvin-he.github.io/2017/12/08/appium-notes1-2017-12-08/</id>
    <published>2017-12-08T06:22:04.000Z</published>
    <updated>2018-01-25T08:15:52.335Z</updated>
    
    <content type="html"><![CDATA[<h3 id="关于appium"><a href="#关于appium" class="headerlink" title="关于appium"></a>关于appium</h3><p>手机app自动化测试，现有支持的app的手机平台（Andriod和IOS）, 选择Appium工具。因为Andriod和IOS，Appium都支持。</p><p>web自动化测试的路线是这样的：<br>编程语言基础—&gt;测试框架—&gt;webdriver API（selenium2）—&gt;开发自动化测试项目。</p><p>移动自动化的测试的路线则是这样的：<br>编程语言基础—&gt;测试框架—&gt;android/IOS开发测试基础—&gt;appium API —&gt;开发移动自动化项目。</p><p>appium就是node的其中一个开源项目，appiun server端是用node实现，遵循了REST架构，所以appium可以用node的包管理工具npm来进行安装。</p><h3 id="安装appium"><a href="#安装appium" class="headerlink" title="安装appium"></a>安装appium</h3><ol><li>使用淘宝镜像安装, 输入”cnpm install -g appium” 即可在线安装.</li><li>安装appium的客户端，基于python的开发环境，可以用pip安装appium客户端, 输入”pip install Appium-Python-Client”，</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;关于appium&quot;&gt;&lt;a href=&quot;#关于appium&quot; class=&quot;headerlink&quot; title=&quot;关于appium&quot;&gt;&lt;/a&gt;关于appium&lt;/h3&gt;&lt;p&gt;手机app自动化测试，现有支持的app的手机平台（Andriod和IOS）, 选择Appiu
      
    
    </summary>
    
      <category term="node" scheme="http://arvin-he.github.io/categories/node/"/>
    
    
      <category term="node" scheme="http://arvin-he.github.io/tags/node/"/>
    
  </entry>
  
  <entry>
    <title>javascript 标准对象</title>
    <link href="http://arvin-he.github.io/2017/12/08/js-object-2017-12-08/"/>
    <id>http://arvin-he.github.io/2017/12/08/js-object-2017-12-08/</id>
    <published>2017-12-08T01:04:29.000Z</published>
    <updated>2017-12-08T01:08:46.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="javascript标准对象"><a href="#javascript标准对象" class="headerlink" title="javascript标准对象"></a>javascript标准对象</h3><ol><li>不要使用new Number()、new Boolean()、new String()创建包装对象；</li><li>用parseInt()或parseFloat()来转换任意类型到number；</li><li>用String()来转换任意类型到string，或者直接调用某个对象的toString()方法；</li><li>通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {…}；</li><li>typeof操作符可以判断出number、boolean、string、function和undefined；</li><li>判断Array要使用Array.isArray(arr)；</li><li>判断null请使用myVar === null；</li><li>判断某个全局变量是否存在用typeof window.myVar === ‘undefined’；</li><li>函数内部判断某个变量是否存在用typeof myVar === ‘undefined’。</li><li>不是任何对象都有toString()方法, null和undefined就没有！这两个特殊值要除外，虽然null还伪装成了object类型。</li><li>number对象调用toString()需要特殊处理,<code>123..toString(); // &#39;123&#39;, 注意是两个点！</code> 或 <code>(123).toString(); // &#39;123&#39;</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;javascript标准对象&quot;&gt;&lt;a href=&quot;#javascript标准对象&quot; class=&quot;headerlink&quot; title=&quot;javascript标准对象&quot;&gt;&lt;/a&gt;javascript标准对象&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;不要使用new Number()
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>selenium笔记</title>
    <link href="http://arvin-he.github.io/2017/12/07/selenium-notes1-2017-12-07/"/>
    <id>http://arvin-he.github.io/2017/12/07/selenium-notes1-2017-12-07/</id>
    <published>2017-12-07T13:39:06.000Z</published>
    <updated>2017-12-08T06:01:11.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="selenium使用"><a href="#selenium使用" class="headerlink" title="selenium使用"></a>selenium使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line">driver = webdriver.Firefox()</div><div class="line">driver.get(<span class="string">"http://www.python.org"</span>)</div><div class="line"><span class="keyword">assert</span> <span class="string">"Python"</span> <span class="keyword">in</span> driver.title</div><div class="line">elem = driver.find_element_by_name(<span class="string">"q"</span>)</div><div class="line">elem.send_keys(<span class="string">"pycon"</span>)</div><div class="line">elem.send_keys(Keys.RETURN)</div><div class="line"><span class="keyword">assert</span> <span class="string">"No results found."</span> <span class="keyword">not</span> <span class="keyword">in</span> driver.page_source</div><div class="line">driver.close()</div></pre></td></tr></table></figure><h3 id="使用selenium登陆淘宝"><a href="#使用selenium登陆淘宝" class="headerlink" title="使用selenium登陆淘宝"></a>使用selenium登陆淘宝</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</div><div class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</div><div class="line"></div><div class="line">driver = webdriver.Firefox()</div><div class="line">driver.get(<span class="string">'https://www.taobao.com/'</span>)</div><div class="line"><span class="keyword">assert</span> <span class="string">"淘宝"</span> <span class="keyword">in</span> driver.title</div><div class="line">elem = driver.find_element_by_class_name(<span class="string">'member-ft'</span>)</div><div class="line">tags = elem.find_elements_by_tag_name(<span class="string">'a'</span>)</div><div class="line">login_url = <span class="string">''</span></div><div class="line"><span class="keyword">for</span> tag <span class="keyword">in</span> tags:</div><div class="line">    <span class="keyword">if</span> <span class="string">'login'</span> <span class="keyword">in</span> tag.get_attribute(<span class="string">'href'</span>):</div><div class="line">        login_url = tag.get_attribute(<span class="string">'href'</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> login_url:</div><div class="line">    driver.get(login_url)</div><div class="line">    driver.find_element_by_id(<span class="string">'J_Quick2Static'</span>).click()</div><div class="line">    elem = driver.find_element_by_id(<span class="string">'TPL_username_1'</span>)</div><div class="line">    elem.send_keys(<span class="string">'淘宝账号'</span>)</div><div class="line">    elem2 = driver.find_element_by_id(<span class="string">'TPL_password_1'</span>)</div><div class="line">    elem2.send_keys(<span class="string">'淘宝账号密码'</span>)</div><div class="line">    driver.find_element_by_id(<span class="string">'J_SubmitStatic'</span>).click()</div><div class="line">    <span class="keyword">assert</span> <span class="string">"No results found."</span> <span class="keyword">not</span> <span class="keyword">in</span> driver.page_source</div><div class="line">    cookies = driver.get_cookies()</div><div class="line">    pprint(cookies)</div><div class="line"><span class="comment"># driver.close()</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;selenium使用&quot;&gt;&lt;a href=&quot;#selenium使用&quot; class=&quot;headerlink&quot; title=&quot;selenium使用&quot;&gt;&lt;/a&gt;selenium使用&lt;/h3&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://arvin-he.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>javascript笔记(二)</title>
    <link href="http://arvin-he.github.io/2017/12/04/js-notes2-2017-12-04/"/>
    <id>http://arvin-he.github.io/2017/12/04/js-notes2-2017-12-04/</id>
    <published>2017-12-04T01:34:52.000Z</published>
    <updated>2017-12-08T07:56:05.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ol><li>局部作用域<br>var 声明局部变量,生命周期在函数内部. 而JavaScript的变量作用域实际上是函数内部，以及变量提升的作用,<br>我们在for循环等语句块中是无法定义具有局部作用域的变量的：<br>为了解决块级作用域，(如for循环), ES6引入了新的关键字let，用let替代var可以申明一个块级作用域的变量：</li></ol><ol><li>全局作用域<br>不在任何函数内定义的变量就具有全局作用域。<br>JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的course属性.<br>以变量方式<code>var foo = function () {}</code>定义的函数实际上也是一个全局变量，<br>因此，顶层函数的定义也被视为一个全局变量，并绑定到window对象.<br>JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。</li></ol><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。<br>减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个自定义的全局变量中.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 唯一的全局变量MYAPP:</span></div><div class="line"><span class="keyword">var</span> MYAPP = &#123;&#125;;</div><div class="line"><span class="comment">// 其他变量:</span></div><div class="line">MYAPP.name = <span class="string">'myapp'</span>;</div><div class="line">MYAPP.version = <span class="number">1.0</span>;</div><div class="line"><span class="comment">// 其他函数:</span></div><div class="line">MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">'foo'</span>;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示这是一个常量，不要修改它的值：<br>ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域</p><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>ES6开始，JavaScript引入了解构赋值，可以同时对一组变量进行赋值。<br>解构赋值在很多时候可以大大简化代码. 但是，需要在支持ES6解构赋值特性的现代浏览器中才能正常运行<br><strong>注意:</strong></p><ol><li>对数组元素进行解构赋值时，多个变量要用[]括起来。</li><li>如果数组本身还有嵌套，也可以通过下面的形式进行解构赋值，注意嵌套层次和位置要保持一致</li><li>如果需要从一个对象中取出若干属性，也可以使用解构赋值，便于快速获取对象的指定属性</li><li>对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的</li><li>使用解构赋值对对象属性进行赋值时，如果要使用的变量名和属性名不一致，可以用下面的语法获取</li><li>解构赋值还可以使用默认值，这样就避免了不存在的属性返回undefined的问题</li><li>如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误, 这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> [x, y, z] = [<span class="string">'hello'</span>, <span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>];</div><div class="line"><span class="keyword">let</span> [x, [y, z]] = [<span class="string">'hello'</span>, [<span class="string">'JavaScript'</span>, <span class="string">'ES6'</span>]];</div><div class="line"><span class="keyword">var</span> &#123;name, age, passport&#125; = person;</div><div class="line"><span class="keyword">var</span> &#123;name, <span class="attr">address</span>: &#123;city, zip&#125;&#125; = person;</div><div class="line"><span class="comment">// 把passport属性赋值给变量id:</span></div><div class="line"><span class="keyword">let</span> &#123;name, <span class="attr">passport</span>:id&#125; = person;</div><div class="line"><span class="comment">// 如果person对象没有single属性，默认赋值为true:</span></div><div class="line"><span class="keyword">var</span> &#123;name, single=<span class="literal">true</span>&#125; = person;</div><div class="line"><span class="keyword">var</span> x, y;</div><div class="line"><span class="comment">// 解构赋值:</span></div><div class="line">&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;; <span class="comment">// 语法错误: Uncaught SyntaxError: Unexpected token =</span></div><div class="line">(&#123;x, y&#125; = &#123; <span class="attr">name</span>: <span class="string">'小明'</span>, <span class="attr">x</span>: <span class="number">100</span>, <span class="attr">y</span>: <span class="number">200</span>&#125;); <span class="comment">//正确</span></div></pre></td></tr></table></figure></li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>绑定到对象上的函数称为方法，和普通函数也没啥区别，但是它在内部使用了一个this关键字，这个this怎么理解？<br>在一个方法内部，this是一个特殊变量，它始终指向当前的调用对象.<br>JavaScript的函数内部如果调用了this，那么这个this到底指向谁？<br>答案是，视情况而定,根据当前调用者来确定. 且必须保证this指向正确，必须用obj.xxx()的形式调用！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fn = xiaoming.age; <span class="comment">// 先拿到xiaoming的age函数</span></div><div class="line">fn(); <span class="comment">// NaN</span></div><div class="line"></div><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"><span class="keyword">var</span> fn = xiaoming.age;</div><div class="line">fn(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></div></pre></td></tr></table></figure></p><p>这是一个设计错误，ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误.<br>这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。<br>修复的办法:用一个that变量首先捕获this,用<code>var that = this;</code>，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。</p><p>另一个解决办法:apply<br>指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数:<br>第一个参数就是需要绑定的this变量，<br>第二个参数是Array，表示函数本身的参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">    <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> xiaoming = &#123;</div><div class="line">    name: <span class="string">'小明'</span>,</div><div class="line">    birth: <span class="number">1990</span>,</div><div class="line">    age: getAge</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xiaoming.age(); <span class="comment">// 25</span></div><div class="line">getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure></p><p>另一个与apply()类似的方法是call()，唯一区别是：<br>apply()把参数打包成Array再传入；<br>call()把参数按顺序传入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></div><div class="line"><span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure></p><p>对普通函数调用，我们通常把this绑定为null。</p><h3 id="原型链继承方式"><a href="#原型链继承方式" class="headerlink" title="原型链继承方式"></a>原型链继承方式</h3><p>JavaScript的原型继承实现方式就是：</p><ol><li>定义新的构造函数，并在内部用call()调用希望“继承”的构造函数，并绑定this；</li><li>借助中间函数F实现原型链继承，最好通过封装的inherits函数完成；</li><li>继续在新的构造函数的原型上定义新方法。</li></ol><h3 id="类class"><a href="#类class" class="headerlink" title="类class"></a>类class</h3><p>从ES6开始新的关键字class正式被引入到JavaScript中,class的目的就是让定义类更简单。<br>类的继承使用通过extends来实现.</p><h3 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h3><p>JavaScript可以获取浏览器提供的很多对象，并进行操作。<br>常用的浏览器对象有: window, navigator, screen, location, document, history</p><p>window对象充当全局作用域，且表示浏览器窗口. 兼容性：IE&lt;=8不支持。<br>有innerWidth和innerHeight属性，可以获取浏览器窗口的内部宽度和高度。<br>内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。<br>outerWidth和outerHeight属性，可以获取浏览器窗口的整个宽高。</p><p>navigator对象表示浏览器的信息，最常用的属性包括：<br>navigator.appName：浏览器名称；<br>navigator.appVersion：浏览器版本；<br>navigator.language：浏览器设置的语言；<br>navigator.platform：操作系统类型；<br>navigator.userAgent：浏览器设定的User-Agent字符串。<br><strong>注意:</strong> navigator的信息可以很容易地被用户修改，所以JavaScript读取的值不一定是正确的.</p><p>screen对象表示屏幕的信息，常用的属性有：<br>screen.width：屏幕宽度，以像素为单位；<br>screen.height：屏幕高度，以像素为单位；<br>screen.colorDepth：返回颜色位数，如8、16、24。</p><p>location对象表示当前页面的URL信息<br>location.protocol; // ‘http’<br>location.host; // ‘www.example.com’<br>location.port; // ‘8080’<br>location.pathname; // ‘/path/index.html’<br>location.search; // ‘?a=1&amp;b=2’<br>location.hash; // ‘TOP’<br>要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，则调用location.reload()方法.</p><p>document对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，document对象就是整个DOM树的根节点。<br>document的title属性是从HTML文档中的<code>&lt;title&gt;xxx&lt;/title&gt;</code>读取的，但是可以动态改变.<br>document对象提供的getElementById()和getElementsByTagName()可以按ID获得一个DOM节点和按Tag名称获得一组DOM节点.<br>document对象还有一个cookie属性，通过document.cookie读取到当前页面的Cookie.<br>由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，<br>因为在HTML页面中引入第三方的JavaScript代码是允许的,为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，<br>设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。<br>为确保安全，服务器端在设置Cookie时，应该始终坚持使用httpOnly。</p><p>history对象保存了浏览器的历史记录，JavaScript可以调用history对象的back()或forward ()，相当于用户点击了浏览器的“后退”或“前进”按钮。<br>新手开始设计Web页面时喜欢在登录页登录成功时调用history.back()，试图回到登录前的页面。这是一种错误的方法。<br>任何情况，你都不应该使用history这个对象了。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><img src="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499832124d97d77b00706461f9daf1a390b75ade1000" alt="廖雪峰官方网站"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;变量作用域&quot;&gt;&lt;a href=&quot;#变量作用域&quot; class=&quot;headerlink&quot; title=&quot;变量作用域&quot;&gt;&lt;/a&gt;变量作用域&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;局部作用域&lt;br&gt;var 声明局部变量,生命周期在函数内部. 而JavaScript的变量作用域实际上是
      
    
    </summary>
    
      <category term="js" scheme="http://arvin-he.github.io/categories/js/"/>
    
    
      <category term="js" scheme="http://arvin-he.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>proxy一些知识</title>
    <link href="http://arvin-he.github.io/2017/11/28/proxy-2017-11-28/"/>
    <id>http://arvin-he.github.io/2017/11/28/proxy-2017-11-28/</id>
    <published>2017-11-28T14:04:44.000Z</published>
    <updated>2017-11-29T01:09:30.919Z</updated>
    
    <content type="html"><![CDATA[<h3 id="代理有什么用处"><a href="#代理有什么用处" class="headerlink" title="代理有什么用处"></a>代理有什么用处</h3><ul><li>对游戏，通过第三方代理，可以提高游戏流畅速度</li><li>对师生，通过代理访问国外论文，获取最新研究成果</li><li>对开发者，通过代理爬取采集大数据，防止被屏蔽</li><li>对极客，通过代理(高匿)隐藏访问痕迹，防止被跟踪</li><li>对个人，通过代理自由上网保护隐私，了解外面的世界</li></ul><h3 id="代理应具有哪些信息"><a href="#代理应具有哪些信息" class="headerlink" title="代理应具有哪些信息"></a>代理应具有哪些信息</h3><ul><li>IP：Port（IP和端口号，默认必选）</li><li>类型（协议类型，HTTP/HTTPS/Socks4/Socks5，默认必选）</li><li>国家（例如：中国/美国/日本等）</li><li>响应时间（ping代理服务器的时间，单位秒）</li><li>传输速度（数据请求和返回的时间，单位秒）</li><li>验证日期（验证代理可用的时间）</li><li>检测成功率（成功率 = 代理检测的可用次数 / 检测总数，衡量代理的可靠性）</li></ul><h3 id="什么是代理的类型"><a href="#什么是代理的类型" class="headerlink" title="什么是代理的类型"></a>什么是代理的类型</h3><p>代理的类型，具体是指代理协议类型，常见的有HTTP、HTTPS、Socks4、Socks5等四种协议类型</p><ul><li>HTTP，全称超文本传输协议（HyperText Transfer Protocol)，是互联网数据传输的一种协议；</li><li>HTTPS，是在HTTP协议基础上加入了SSL加密协议，以https开头，确保传输过程的数据安全；</li><li>Socks4，是全能代理，支持HTTP，FTP等多种协议请求，传输层只支持UDP协议，数据可能会丢失；</li><li>Socks5，类似于Socks4，差别是传输层同时支持UDP和TCP协议，支持可靠的身份验证等机制。<br>Socks4和Socks5，都是通过代理IP:Port利用底层传输协议进行网络通信，因此都可视为匿名代理。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>HTTP：适合一般的网页浏览，例如：浏览新闻，观看视频等；</li><li>HTTPS：适合一些需要安全验证的场合，例如：网银登录，购物付款等；</li><li>Socks4：适合一些对数据完整性不高的场合，例如：网络电话，视频聊天等；</li><li>Socks5：适合对数据完整性较高的场合，例如：网络游戏，微信接入，移动支付等。</li></ul><h3 id="HTTP和Socks代理有何区别？"><a href="#HTTP和Socks代理有何区别？" class="headerlink" title="HTTP和Socks代理有何区别？"></a>HTTP和Socks代理有何区别？</h3><p>HTTP和HTTPS，都是基于可靠的TCP/IP协议，对传输数据都有校验，保障数据不丢失。<br>Socks4和Socks5，分别是基于UDP，UDP和TCP传输协议，通过代理IP:Port请求转发数据。<br>HTTP和HTTPS是在Socks基础上，进行了数据封装，只专注业务，不必考虑底层的数据传输。<br>Socks是基于IP:Port套接字进行底层的数据传输，支持多种HTTP、FTP、ICMP等上层协议。<br>适用场景：对于普通用户，一般使用HTTP/HTTPS即可；对于开发者用户，推荐Socks，如微信开发。</p><h3 id="什么是代理的匿名度"><a href="#什么是代理的匿名度" class="headerlink" title="什么是代理的匿名度"></a>什么是代理的匿名度</h3><p>代理的匿名度，一般分为透明，匿名，高匿，其中匿名又分为普通匿名和欺骗匿名。</p><ul><li>透明，代理服务器只是转发请求，并把你的真实IP地址传给服务器，不会隐藏或改变你的IP；</li><li>普通匿名，代理服务器转发请求，并把代理服务器的IP地址传给服务器，隐藏了你的真实IP；</li><li>欺骗匿名，代理服务器转发请求，并编造了一个假的IP地址传给服务器，隐藏了你的真实IP；</li><li>高匿，代理服务器转发请求，并完全隐藏了你的真实IP和其它信息，就像另外一个人在访问。</li></ul><p>代理匿名度优先级： 高匿 &gt; 欺骗代理 &gt; 普通匿名 &gt; 透明 &gt; 不使用代理</p><p>如果不使用代理，你的请求数据，真实IP地址，以及其它信息（如浏览器参数，cookie等），都会毫无保留的暴露给了远程服务器，<br>他人可以利用这些访问痕迹，跟踪你的位置（如城市/地区/街道），以及盗取你请求数据中的敏感信息（如银行卡帐号和密码，QQ号和密码等），以及你的访问喜好和习惯等个人隐私。</p><p>使用代理(高匿)和加密协议(HTTPS)，可以大大提高您访问网络的安全性，有效保护您的个人隐私等敏感信息</p><h3 id="高匿、匿名和透明有何区别？"><a href="#高匿、匿名和透明有何区别？" class="headerlink" title="高匿、匿名和透明有何区别？"></a>高匿、匿名和透明有何区别？</h3><p>高匿，匿名和透明，是针对隐藏用户请求数据而言，例如：隐藏IP地址，隐藏浏览器参数，Cookie等<br>对于一般的访问网络，一共有五种方式：无代理、透明、普通匿名、欺骗匿名、高匿（Elite）<br>五种方式及判断原理如下：</p><ol><li><p>无代理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 您的真实IP</div><div class="line">HTTP_VIA = 没数值或不显示</div><div class="line">HTTP_X_FORWARDED_FOR = 没数值或不显示</div></pre></td></tr></table></figure></li><li><p>透明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 最后一个代理服务器IP</div><div class="line">HTTP_VIA = 代理服务器IP</div><div class="line">HTTP_X_FORWARDED_FOR = 您的真实IP，经过多个代理服务器时，这个值类似：123.57.78.101, 120.24.177.48, 47.88.76.11</div></pre></td></tr></table></figure></li><li><p>普通匿名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 最后一个代理服务器IP</div><div class="line">HTTP_VIA = 代理服务器IP</div><div class="line">HTTP_X_FORWARDED_FOR = 代理服务器IP，经过多个代理服务器时，这个值类似：123.57.78.101, 120.24.177.48, 47.88.76.11</div></pre></td></tr></table></figure></li><li><p>欺骗匿名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 最后一个代理服务器IP</div><div class="line">HTTP_VIA = 代理服务器IP</div><div class="line">HTTP_X_FORWARDED_FOR = 随机的IP，经过多个代理服务器时，这个值类似：123.57.78.101, 120.24.177.48, 47.88.76.11</div></pre></td></tr></table></figure></li><li><p>高匿(Elite)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">REMOTE_ADDR = 代理服务器IP</div><div class="line">HTTP_VIA = 没数值或不显示</div><div class="line">HTTP_X_FORWARDED_FOR = 没数值或不显示</div></pre></td></tr></table></figure></li></ol><h3 id="代理的国家-地区"><a href="#代理的国家-地区" class="headerlink" title="代理的国家/地区"></a>代理的国家/地区</h3><p>代理的国家，具体是指代理IP所属的国家，例如：中国，美国，英国，日本，韩国，俄罗斯等<br>代理的地区，具体是指代理IP所属国家的地区，只支持中国34个省市(含港澳台)，例如：中国北京，中国香港</p><h3 id="代理的运营商"><a href="#代理的运营商" class="headerlink" title="代理的运营商"></a>代理的运营商</h3><p>代理的运营商，具体是指提供代理服务器的运营商，因为大部分的的代理IP，是由电信运营商搭建提供。<br>代理的运营商，主要有移动、铁通、联通、网通、电信，以及其它（主要是一些大公司和港澳台电信运营商，例如：阿里巴巴、中华电信、腾讯集团、鹏博士、教育网等）</p><h3 id="代理的响应时间"><a href="#代理的响应时间" class="headerlink" title="代理的响应时间"></a>代理的响应时间</h3><p>代理的响应时间，具体是指代理检测服务器Ping通代理服务器的时间。<br>Ping命令的原理，是发送一个ICMP(因特网控制报文协议)给远程服务器，并回声收到目标ICMP的应答时间。<br>如: 米扑代理的响应时间，分为五个等级，从低到高依次为： 0 ~ 0.1 ~ 0.3 ~ 1 ~ 5 ~ 9，单位秒</p><h3 id="代理的传输速度"><a href="#代理的传输速度" class="headerlink" title="代理的传输速度"></a>代理的传输速度</h3><p>代理的传输速度，具体是指代理检测服务器发送请求到目标服务器并返回数据到本地的总时间。<br>总时间，包括本地发送请求 -&gt; 代理服务器 -&gt; 目标服务器 -&gt; 返回数据到代理服务器 -&gt; 本地的全部时间。<br>如: 米扑代理的传输速度，分为五个等级，从低到高依次为： 0 ~ 0.3 ~ 1 ~ 5 ~ 10 ~ 30，单位秒。</p><h3 id="代理的验证日期"><a href="#代理的验证日期" class="headerlink" title="代理的验证日期"></a>代理的验证日期</h3><p>代理的验证日期，具体是指检测代理可用的最后时间，<br>必须满足:<br>1）代理可用；<br>2）检测为可用的最后时间。<br>例如：代理 100.12.25.10:8080 可用，最后一次检测日期为 2015-05-20 10:12:56，即为验证日期。</p><h3 id="提取的代理都可以用吗？"><a href="#提取的代理都可以用吗？" class="headerlink" title="提取的代理都可以用吗？"></a>提取的代理都可以用吗？</h3><p>代理的实效性很强，当时提取的可用代理可能一会儿就失效了，因此检测代理的最后验证日期，非常重要！</p><h3 id="如何获取高可靠的代理？"><a href="#如何获取高可靠的代理？" class="headerlink" title="如何获取高可靠的代理？"></a>如何获取高可靠的代理？</h3><p>高可靠代理，计算公式：代理的检测可用次数 / 总检测次数 = 可靠率，如:米扑代理独创的检测技术。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;代理有什么用处&quot;&gt;&lt;a href=&quot;#代理有什么用处&quot; class=&quot;headerlink&quot; title=&quot;代理有什么用处&quot;&gt;&lt;/a&gt;代理有什么用处&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;对游戏，通过第三方代理，可以提高游戏流畅速度&lt;/li&gt;
&lt;li&gt;对师生，通过代理访问国外
      
    
    </summary>
    
      <category term="web" scheme="http://arvin-he.github.io/categories/web/"/>
    
    
      <category term="web" scheme="http://arvin-he.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>redis笔记</title>
    <link href="http://arvin-he.github.io/2017/11/25/redis-note1-2017-11-25/"/>
    <id>http://arvin-he.github.io/2017/11/25/redis-note1-2017-11-25/</id>
    <published>2017-11-25T13:45:48.000Z</published>
    <updated>2017-11-27T01:06:11.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="redis下载与安装"><a href="#redis下载与安装" class="headerlink" title="redis下载与安装"></a>redis下载与安装</h3><ol><li><p>windows下redis下载地址:<br><img src="https://github.com/MicrosoftArchive/redis/releases" alt="https://github.com/MicrosoftArchive/redis/releases"></p></li><li><p>下载zip版本,在C盘根目录下(或者你想安装的目录下)解压</p></li><li><p>添加redis环境变量</p></li><li><p>注册redis服务<br><code>redis-server.exe --service-install redis.windows.conf --loglevel verbose</code></p></li><li><p>启动redis服务<br><code>redis-server.exe --service-start</code></p></li><li><p>下载redis可视化客户端软件RedisDesktopManager</p></li></ol><p>下载地址:<br><img src="https://redisdesktop.com/download" alt="https://redisdesktop.com/download"></p><h3 id="python下安装redis绑定包"><a href="#python下安装redis绑定包" class="headerlink" title="python下安装redis绑定包"></a>python下安装redis绑定包</h3><p><code>pip install redis</code></p><h3 id="redis-mongodb与memcache对比"><a href="#redis-mongodb与memcache对比" class="headerlink" title="redis, mongodb与memcache对比"></a>redis, mongodb与memcache对比</h3><p>mongodb 直接持久化<br>redis 半持久化<br>memcache 只能在内存，轻量级缓存</p><h3 id="redis简介"><a href="#redis简介" class="headerlink" title="redis简介"></a>redis简介</h3><p>redis是一个key-value存储系统。和Memcached类似,支持的类型操作有: String操作, Hash操作, List操作, Set操作, Sort Set操作(zset)<br>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的.<br>redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。<br>区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p><h3 id="python操作redis"><a href="#python操作redis" class="headerlink" title="python操作redis"></a>python操作redis</h3><p>edis-py提供两个类Redis和StrictRedis用于实现Redis的命令，<br>StrictRedis用于实现大部分官方的命令，并使用官方的语法和命令，<br>Redis是StrictRedis的子类，用于向后兼容旧版本的redis-py。</p><p>redis-py使用connection pool来管理对一个redis server的所有连接，避免每次建立、释放连接的开销。<br>默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数Redis，这样就可以实现多个Redis实例共享一个连接池。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> redis</div><div class="line"></div><div class="line">r = redis.Redis(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</div><div class="line">r.set(<span class="string">'foo'</span>, <span class="string">'Bar'</span>)</div><div class="line"><span class="keyword">print</span> (r.get(<span class="string">'foo'</span>))</div><div class="line"><span class="comment"># 使用连接池</span></div><div class="line">pool = redis.ConnectionPool(host=<span class="string">'127.0.0.1'</span>, port=<span class="number">6379</span>)</div><div class="line">r = redis.Redis(connection_pool=pool)</div><div class="line">r.set(<span class="string">'foo'</span>, <span class="string">'Bar'</span>)</div><div class="line"><span class="keyword">print</span> r.get(<span class="string">'foo'</span>)</div></pre></td></tr></table></figure></p><h3 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h3><p>set(name, value, ex=None, px=None, nx=False, xx=False)<br>setnx 、 setex 、 psetex<br>在Redis中设置值，默认，不存在则创建，存在则修改<br>参数：<br>     ex，过期时间（秒）<br>     px，过期时间（毫秒）<br>     nx，如果设置为True，则只有name不存在时，当前set操作才执行<br>     xx，如果设置为True，则只有name存在时，当前set操作才执行</p><p>批量设置<br>mset(<em>args, **kwargs)<br>批量获取<br>mget(keys, </em>args)<br>设置新值并获取原来的值<br>getset(name, value)<br>获取子序列（根据字节获取，非字符）<br>getrange(key, start, end)<br>修改字符串内容，从指定字符串索引开始向后替换（新值太长时，则向后添加）<br>setrange(name, offset, value)<br>对name对应值的二进制进行位操作。<br>setbit(name, offset, value)<br>获取name对应的值的二进制表示中 1 的个数,应用场景:统计在线用户数有多少<br>bitcount(key, start=None, end=None)<br>自增 name对应的值，当name不存在时，则创建name＝amount，否则，则自增。<br>incr(self, name, amount=1)<br>incrbyfloat(self, name, amount=1.0)<br>自减 name对应的值，当name不存在时，则创建name＝amount，否则，则自减。<br>decr(self, name, amount=1)<br>在redis name对应的值后面追加内容<br>append(key, value)</p><h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><p>Hash操作，redis中Hash在内存中的存储格式如下图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">name                hash</div><div class="line">               |````````````|</div><div class="line">n1   --------&gt; | k1 --&gt; v1  |</div><div class="line">               | k2 --&gt; v2  |</div><div class="line">               |____________|</div><div class="line">               |````````````|</div><div class="line">n2   --------&gt; | k7 --&gt; v7  |</div><div class="line">               |____________|</div></pre></td></tr></table></figure></p><p>name对应的hash中设置一个键值对（不存在，则创建；否则，修改）<br>hset(name, key, value)<br>在name对应的hash中批量设置键值对<br>hmset(name, mapping)<br>在name对应的hash中获取多个key的值<br>hmget(name, keys, <em>args)<br>获取name对应的hash中键值对的个数<br>hlen(name)<br>检查name对应的hash是否存在当前传入的key<br>hexists(name, key)<br>将name对应的hash中指定key的键值对删除<br>hdel(name,</em>keys)<br>自增name对应的hash中的指定key的值，不存在则创建key=amount<br>hincrby(name, key, amount=1)<br>hincrbyfloat(name, key, amount=1.0)<br>过滤,增量式迭代获取，对于数据大的数据非常有用，hscan可以实现分片的获取数据，并非一次性将数据全部获取完，从而放置内存被撑爆<br>hscan(name, cursor=0, match=None, count=None)<br>利用yield封装hscan创建生成器，实现分批去redis中获取数据<br>hscan_iter(name, match=None, count=None)</p><h3 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h3><p>lpush, lrange, rpush, lpushx, llen, linsert, lset, lrem, lpop, lindex, ltrim, rpoplpush, blpop, brpoplpush</p><h3 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h3><p>sadd, scard, sdiff, sdiffstore, sinter, sinterstore, sismenber, smove, spop, srandmenber, srem, sunion, sunionstore</p><h3 id="有序集合-zset"><a href="#有序集合-zset" class="headerlink" title="有序集合(zset)"></a>有序集合(zset)</h3><p>zadd, zcount, zincrby, zrank, zrem, zremrangebyrank, zremrankbyscore, zremrangebylex, zscore, zinterstore, zunionstore</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">zunionstore(dest, keys, aggregate=None)</div><div class="line"># 获取两个有序集合的并集</div><div class="line"># aggregate的值为:  SUM  MIN  MAX</div></pre></td></tr></table></figure><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">del(*names)</div><div class="line"># 根据删除redis中的任意数据类型</div><div class="line"></div><div class="line">exists(name)</div><div class="line"># 检测redis的name是否存在</div><div class="line"></div><div class="line">keys(pattern=&apos;*&apos;)</div><div class="line"># 根据模型获取redis的name</div><div class="line"># 更多：</div><div class="line">    # KEYS * 匹配数据库中所有 key 。</div><div class="line">    # KEYS h?llo 匹配 hello ， hallo 和 hxllo 等。</div><div class="line">    # KEYS h*llo 匹配 hllo 和 heeeeello 等。</div><div class="line">    # KEYS h[ae]llo 匹配 hello 和 hallo ，但不匹配 hillo</div><div class="line"></div><div class="line">expire(name ,time)</div><div class="line"># 为某个redis的某个name设置超时时间</div><div class="line"></div><div class="line">rename(src, dst)</div><div class="line"># 对redis的name重命名</div><div class="line"></div><div class="line">move(name, db))</div><div class="line"># 将redis的某个值移动到指定的db下，若有则不移动</div><div class="line"></div><div class="line">select db_name</div><div class="line"># 切换到其他db，redis有16个db</div><div class="line"></div><div class="line">randomkey()</div><div class="line"># 随机获取一个redis的name（不删除）</div><div class="line"></div><div class="line">type(name)</div><div class="line"># 获取name对应值的类型</div><div class="line"></div><div class="line">scan(cursor=0, match=None, count=None)</div><div class="line">scan_iter(match=None, count=None)</div><div class="line"># 同字符串操作，用于增量迭代获取key</div></pre></td></tr></table></figure><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>redis-py默认在执行每次请求都会创建（连接池申请连接）和断开（归还连接池）一次连接操作，<br>如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令，并且默认情况下一次pipline 是原子性操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import redis</div><div class="line">import time</div><div class="line"></div><div class="line">pool = redis.ConnectionPool(host=&apos;10.211.55.4&apos;, port=6379, db=5)</div><div class="line">r = redis.Redis(connection_pool=pool)</div><div class="line"># pipe = r.pipeline(transaction=False)</div><div class="line">pipe = r.pipeline(transaction=True)</div><div class="line"></div><div class="line">pipe.set(&apos;name&apos;, &apos;alex&apos;)</div><div class="line">time.sleep(60)</div><div class="line">pipe.set(&apos;role&apos;, &apos;sb&apos;)</div><div class="line"></div><div class="line">pipe.execute()</div></pre></td></tr></table></figure><h3 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h3><p>收音机举例发布订阅<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">import redis</div><div class="line"></div><div class="line">class RedisHelper:</div><div class="line"></div><div class="line">    def __init__(self):</div><div class="line">        self.__conn = redis.Redis(host=&apos;10.211.55.4&apos;)</div><div class="line">        self.chan_sub = &apos;fm104.5&apos;</div><div class="line">        self.chan_pub = &apos;fm104.5&apos;</div><div class="line"></div><div class="line">    def public(self, msg):</div><div class="line">        self.__conn.publish(self.chan_pub, msg)</div><div class="line">        return True</div><div class="line"></div><div class="line">    def subscribe(self):</div><div class="line">        pub = self.__conn.pubsub()  # 打开收音机</div><div class="line">        pub.subscribe(self.chan_sub) # 调频道</div><div class="line">        pub.parse_response()  # 准备接收</div><div class="line">        return pub</div></pre></td></tr></table></figure></p><p>订阅方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">from RedisHelper import RedisHelper</div><div class="line"></div><div class="line">obj = RedisHelper()</div><div class="line">redis_sub = obj.subscribe()</div><div class="line"></div><div class="line">while True:</div><div class="line">    msg= redis_sub.parse_response()</div><div class="line">    print (msg)</div></pre></td></tr></table></figure></p><p>发布方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">from RedisHelper import RedisHelper</div><div class="line"></div><div class="line">obj = RedisHelper()</div><div class="line">obj.public(&apos;hello&apos;)</div></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><img src="http://blog.csdn.net/fgf00/article/details/52917154" alt="http://blog.csdn.net/fgf00/article/details/52917154"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;redis下载与安装&quot;&gt;&lt;a href=&quot;#redis下载与安装&quot; class=&quot;headerlink&quot; title=&quot;redis下载与安装&quot;&gt;&lt;/a&gt;redis下载与安装&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;windows下redis下载地址:&lt;br&gt;&lt;img sr
      
    
    </summary>
    
      <category term="数据库" scheme="http://arvin-he.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="redis" scheme="http://arvin-he.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>tornado学习笔记(二)</title>
    <link href="http://arvin-he.github.io/2017/11/16/tornado-note2-2017-11-16/"/>
    <id>http://arvin-he.github.io/2017/11/16/tornado-note2-2017-11-16/</id>
    <published>2017-11-16T13:40:47.000Z</published>
    <updated>2017-11-27T01:06:11.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h3><p>ornado 所谓的异步：就是你调用我之后，我发现数据没准备好，那我就不处理，而是跳到程序的其他地方继续执行，等数据准备好之后再切回来继续执行。Tornado 的 IOLoop 就是一个总调度器，汇总了所有的 events 和 callbacks，然后同步执行。这会整体生提升性能，但不会降低单个请求的响应时间。</p><h2 id="一些接口说明"><a href="#一些接口说明" class="headerlink" title="一些接口说明"></a>一些接口说明</h2><h3 id="tornado-web-asynchronous"><a href="#tornado-web-asynchronous" class="headerlink" title="tornado.web.asynchronous"></a>tornado.web.asynchronous</h3><p>其中 tornado.web.asynchronous 装饰器很简单，就是设置 <code>self._auto_finish = False</code>，<br>这样当 AsyncHandler.get() 执行完之后，connection socket 不会被 close，需要主动调用 self.finish()。<br>在保持连接不关闭的情况下，把控制权让出去，等数据就绪之后再切回来，使异步实现成为可能。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncHandler</span><span class="params">(tornado.web.RequestHandler)</span>:</span></div><div class="line"><span class="meta">    @tornado.web.asynchronous</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></div><div class="line">        http_client = AsyncHTTPClient()</div><div class="line">        http_client.fetch(<span class="string">"http://example.com"</span>,</div><div class="line">                          callback=self.on_fetch)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">on_fetch</span><span class="params">(self, response)</span>:</span></div><div class="line">        self.write(<span class="string">"Downloaded!"</span>)</div><div class="line">        self.finish()</div></pre></td></tr></table></figure></p><h3 id="SimpleAsyncHTTPClient"><a href="#SimpleAsyncHTTPClient" class="headerlink" title="SimpleAsyncHTTPClient"></a>SimpleAsyncHTTPClient</h3><p>AsyncHTTPClient 的处理流程，简单概括就是：与 HTTP Server 建立连接，等拿到 response 后再来调用回调函数 on_fetch。首先通过创建非阻塞的 socket 连接，然后放入到 ioloop 中，当数据可写/可读之后再接着处理。</p><h3 id="gen-engine-的实现："><a href="#gen-engine-的实现：" class="headerlink" title="gen.engine 的实现："></a>gen.engine 的实现：</h3><p>gen.engine 的作用就是把异步中 callback 的写法通过 yield 替代。<br>以下的代码分析都是基于 Tornado 3.0。<br>tornado.ioloop.IOLoop.current() 创建一个ioloop实例</p><p>###IOLoop 为何没有 <code>__init__</code>函数<br>其实是因为要初始化成为单例，IOLoop 的 new 函数已经被改写了，同时指定了 initialize 做为它的初始化方法，所以没有 <code>__init__</code> 。 </p><h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>Future在tornado中是一个很奇妙的对象，它是一个穿梭于协程和调度器之间的信使。提供了回调函数注册(当异步事件完成后，调用注册的回调)、中间结果保存、嵌套协程唤醒父协程(通过Runner实现)等功能。Coroutine和Future是一一对应的，可以从上节gen.coroutine装饰器的实现中看到。每调用一个协程，表达式所返回的就是一个Future对象，它所表达的意义为：这个协程的内部各种异步逻辑执行完毕后，会把结果保存在这个Future中，同时调用这个Future中指定的回调函数，而future中的回调函数是什么时候被注册的呢？那就是当前——你通过调用协程，返回了这个future对象的时候：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一些说明&quot;&gt;&lt;a href=&quot;#一些说明&quot; class=&quot;headerlink&quot; title=&quot;一些说明&quot;&gt;&lt;/a&gt;一些说明&lt;/h3&gt;&lt;p&gt;ornado 所谓的异步：就是你调用我之后，我发现数据没准备好，那我就不处理，而是跳到程序的其他地方继续执行，等数据准备好之
      
    
    </summary>
    
      <category term="python" scheme="http://arvin-he.github.io/categories/python/"/>
    
    
      <category term="tornado" scheme="http://arvin-he.github.io/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>如何去阅读源码</title>
    <link href="http://arvin-he.github.io/2017/11/16/howtoreadsource-2017-11-16/"/>
    <id>http://arvin-he.github.io/2017/11/16/howtoreadsource-2017-11-16/</id>
    <published>2017-11-16T13:34:20.000Z</published>
    <updated>2017-11-27T01:06:11.171Z</updated>
    
    <content type="html"><![CDATA[<h3 id="阅读源码的方法"><a href="#阅读源码的方法" class="headerlink" title="阅读源码的方法"></a>阅读源码的方法</h3><p>源码分析的时候，一定要有层级和模块的概念，任何一个系统都可以被认为是许多个层级或者模块通过向外界暴露接口或者调用其他层级模块接口的方式连接在一起。所以没有必要上来就把每一个细节的实现搞明白，这是低效不科学的方法。正确的方法是首先从宏观上对整体框架有一个认识，划分出层级和模块，然后再具体把每一个模块搞透彻。</p><h3 id="学习新框架的方法"><a href="#学习新框架的方法" class="headerlink" title="学习新框架的方法"></a>学习新框架的方法</h3><p>学一个新的框架，文档先浏览一下，然后就是照着教程的例子运行，接着弄懂例子的运行原理（看源码）。抓住在使用框架过程中遇到的问题，并以那个问题为切入点深入分析，这样一方面能解决问题；另一方面能借机对框架有更深入的了解，因为框架内容那么多，也不可能面面俱到，但是至少遇到问题的地方你深挖是有价值的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;阅读源码的方法&quot;&gt;&lt;a href=&quot;#阅读源码的方法&quot; class=&quot;headerlink&quot; title=&quot;阅读源码的方法&quot;&gt;&lt;/a&gt;阅读源码的方法&lt;/h3&gt;&lt;p&gt;源码分析的时候，一定要有层级和模块的概念，任何一个系统都可以被认为是许多个层级或者模块通过向外界暴露
      
    
    </summary>
    
      <category term="思想" scheme="http://arvin-he.github.io/categories/%E6%80%9D%E6%83%B3/"/>
    
    
      <category term="方法" scheme="http://arvin-he.github.io/tags/%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
</feed>
