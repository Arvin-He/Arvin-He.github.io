<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Simple & Freedom" type="application/atom+xml" />






<meta name="description" content="Learn and live.">
<meta property="og:type" content="website">
<meta property="og:title" content="Simple &amp; Freedom">
<meta property="og:url" content="http://arvin-he.github.io/page/17/index.html">
<meta property="og:site_name" content="Simple &amp; Freedom">
<meta property="og:description" content="Learn and live.">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Simple &amp; Freedom">
<meta name="twitter:description" content="Learn and live.">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://arvin-he.github.io/page/17/"/>





  <title>Simple & Freedom</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Simple & Freedom</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Learn and live.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/06/03/node-notes3-2017-06-03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/03/node-notes3-2017-06-03/" itemprop="url">Node笔记3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-03T11:44:53+08:00">
                2017-06-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="更有用的场景"><a href="#更有用的场景" class="headerlink" title="更有用的场景"></a>更有用的场景</h3><p>服务器，请求路由以及请求处理程序都已经完成了，下面让我们按照此前的用例给网站添加交互：用户选择一个文件，上传该文件，然后在浏览器中看到上传的文件。 为了保持简单，我们假设用户只会上传图片，然后我们应用将该图片显示到浏览器中。</p>
<p>要实现该功能，分为如下两步：<br>首先，让我们来看看如何处理POST请求（非文件上传），<br>然后，使用Node.js的一个用于文件上传的外部模块。</p>
<h3 id="处理POST请求"><a href="#处理POST请求" class="headerlink" title="处理POST请求"></a>处理POST请求</h3><p>下面显示一个文本区（textarea）供用户输入内容，然后通过POST请求提交给服务器。最后，服务器接受到请求，通过处理程序将输入的内容展示到浏览器中。</p>
<p>/start请求处理程序用于生成带文本区的表单，因此，我们将requestHandlers.js修改为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> body = <span class="string">'&lt;html&gt;'</span>+</div><div class="line">    <span class="string">'&lt;head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;meta http-equiv="Content-Type" content="text/html; '</span>+</div><div class="line">    <span class="string">'charset=UTF-8" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;form action="/upload" method="post"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="submit" value="Submit text" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/form&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/html&gt;'</span>;</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</div><div class="line">    response.write(body);</div><div class="line">    response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">  response.write(<span class="string">"Hello Upload"</span>);</div><div class="line">  response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure></p>
<p>重启服务器,就可以看到效果了.虽然直接将视觉元素放在请求处理程序中的方式太丑陋了。但是，这里不会讲述MVC之类的模式，因为这对于你了解JavaScript或者Node.js环境来说没多大关系。</p>
<p>接下来探讨 当用户提交表单时，触发/upload请求处理程序处理POST请求的问题。<br>这里采用异步回调来实现非阻塞地处理POST请求的数据。因为POST请求一般都比较“重” —— 用户可能会输入大量的内容。用阻塞的方式处理大数据量的请求必然会导致用户操作的阻塞。</p>
<p>为了使整个过程非阻塞，Node.js会将POST数据拆分成很多小的数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。</p>
<p>我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。</p>
<p>如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">request.addListener(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</div><div class="line">  <span class="comment">// called when a new chunk of data was received</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">request.addListener(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// called when all chunks of data have been received</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>问题来了，这部分逻辑写在哪里呢？ 我们现在只是在服务器中获取到了request对象 —— 我们并没有像之前response对象那样，把 request 对象传递给请求路由和请求处理程序。</p>
<p>在我看来，获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情。因此，我建议，我们直接在服务器中处理POST数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。</p>
<p>因此，实现思路就是： 将data和end事件的回调函数直接放在服务器中，在data事件回调中收集所有的POST数据，当接收到所有数据，触发end事件后，其回调函数调用请求路由，并将数据传递给它，然后，请求路由再将该数据传递给请求处理程序。</p>
<p>先从server.js开始：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> postData = <span class="string">""</span>;</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line"></div><div class="line">    request.setEncoding(<span class="string">"utf8"</span>);</div><div class="line">    <span class="comment">// 注册监听器</span></div><div class="line">    request.addListener(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">postDataChunk</span>) </span>&#123;</div><div class="line">      postData += postDataChunk;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"Received POST data chunk '"</span>+</div><div class="line">      postDataChunk + <span class="string">"'."</span>);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    request.addListener(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// 将请求路由的调用移到end事件处理程序中, 同时还把POST数据传递给请求路由</span></div><div class="line">      route(handle, pathname, response, postData);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure></p>
<p>上述代码做了三件事情：<br>首先，我们设置了接收数据的编码格式为UTF-8，<br>然后注册了“data”事件的监听器,用于收集每次接收到的新数据块,并将其赋值给postData变量.<br>最后，我们将请求路由的调用移到end事件处理程序中，以确保它只会当所有数据接收完毕后才触发，并且只触发一次。我们同时还把POST数据传递给请求路由，因为这些数据，请求处理程序会用到。</p>
<p>上述代码在每个数据块到达的时候输出了日志，这对于最终生产环境来说，是很不好的（数据量可能会很大，还记得吧？），但是，在开发阶段是很有用的，有助于让我们看到发生了什么。</p>
<p>我建议可以尝试下，尝试着去输入一小段文本，以及大段内容，当大段内容的时候，就会发现data事件会触发多次。</p>
<p>接下来在/upload页面，展示用户输入的内容。要实现该功能，我们需要将postData传递给请求处理程序，修改router.js为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname, response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;</div><div class="line">    handle[pathname](response, postData);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);</div><div class="line">    response.writeHead(<span class="number">404</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">    response.write(<span class="string">"404 Not found"</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure></p>
<p>然后，在requestHandlers.js中，我们将数据包含在对upload请求的响应中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> body = <span class="string">'&lt;html&gt;'</span>+</div><div class="line">    <span class="string">'&lt;head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;meta http-equiv="Content-Type" content="text/html; '</span>+</div><div class="line">    <span class="string">'charset=UTF-8" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;form action="/upload" method="post"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="submit" value="Submit text" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/form&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/html&gt;'</span>;</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</div><div class="line">    response.write(body);</div><div class="line">    response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">  response.write(<span class="string">"You've sent: "</span> + postData);</div><div class="line">  response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure></p>
<p>好了，我们现在可以接收POST数据并在请求处理程序中处理该数据了。</p>
<p>我们最后要做的是： 当前我们是把请求的整个消息体传递给了请求路由和请求处理程序。我们应该只把POST数据中，我们感兴趣的部分传递给请求路由和请求处理程序。在我们这个例子中，我们感兴趣的其实只是text字段。</p>
<p>我们可以使用此前介绍过的querystring模块来实现：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">"querystring"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> body = <span class="string">'&lt;html&gt;'</span>+</div><div class="line">    <span class="string">'&lt;head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;meta http-equiv="Content-Type" content="text/html; '</span>+</div><div class="line">    <span class="string">'charset=UTF-8" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;form action="/upload" method="post"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="submit" value="Submit text" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/form&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/html&gt;'</span>;</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</div><div class="line">    response.write(body);</div><div class="line">    response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">  response.write(<span class="string">"You've sent the text: "</span>+</div><div class="line">  querystring.parse(postData).text);</div><div class="line">  response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure></p>
<p>好了，以上就是关于处理POST数据的全部内容。</p>
<h3 id="处理文件上传"><a href="#处理文件上传" class="headerlink" title="处理文件上传"></a>处理文件上传</h3><p>最终的用例：允许用户上传图片，并将该图片在浏览器中显示出来。</p>
<p>这里要用到的外部模块是Felix Geisendörfer开发的node-formidable模块。它对解析上传的文件数据做了很好的抽象。 其实说白了，处理文件上传“就是”处理POST数据 —— 但是，麻烦的是在具体的处理细节，所以，这里采用现成的方案更合适点。</p>
<p>使用该模块，首先需要安装该模块。Node.js有它自己的包管理器，叫NPM。它可以让安装Node.js的外部模块变得非常方便。通过如下一条命令就可以完成该模块的安装：<code>npm install formidable</code>.<br>现在可以用formidable模块了——使用外部模块与内部模块类似，用require语句将其引入即可：<br><code>var formidable = require(&quot;formidable&quot;);</code>,这里该模块做的就是将通过HTTP POST请求提交的表单，在Node.js中可以被解析。我们要做的就是创建一个新的IncomingForm，它是对提交表单的抽象表示，之后，就可以用它解析request对象，获取表单中需要的数据字段。</p>
<p>node-formidable官方的例子展示了这两部分是如何融合在一起工作的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> formidable = <span class="built_in">require</span>(<span class="string">'formidable'</span>),</div><div class="line">    http = <span class="built_in">require</span>(<span class="string">'http'</span>),</div><div class="line">    util = <span class="built_in">require</span>(<span class="string">'util'</span>);</div><div class="line"></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (req.url == <span class="string">'/upload'</span> &amp;&amp; req.method.toLowerCase() == <span class="string">'post'</span>) &#123;</div><div class="line">    <span class="comment">// parse a file upload</span></div><div class="line">    <span class="keyword">var</span> form = <span class="keyword">new</span> formidable.IncomingForm();</div><div class="line">    form.parse(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, fields, files</span>) </span>&#123;</div><div class="line">      res.writeHead(<span class="number">200</span>, &#123;<span class="string">'content-type'</span>: <span class="string">'text/plain'</span>&#125;);</div><div class="line">      res.write(<span class="string">'received upload:\n\n'</span>);</div><div class="line">      res.end(util.inspect(&#123;<span class="attr">fields</span>: fields, <span class="attr">files</span>: files&#125;));</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// show a file upload form</span></div><div class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'content-type'</span>: <span class="string">'text/html'</span>&#125;);</div><div class="line">  res.end(</div><div class="line">    <span class="string">'&lt;form action="/upload" enctype="multipart/form-data" '</span>+</div><div class="line">    <span class="string">'method="post"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="text" name="title"&gt;&lt;br&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="file" name="upload" multiple="multiple"&gt;&lt;br&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="submit" value="Upload"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/form&gt;'</span></div><div class="line">  );</div><div class="line">&#125;).listen(<span class="number">8888</span>);</div></pre></td></tr></table></figure></p>
<p>如果我们将上述代码，保存到一个文件中，并通过node来执行，就可以进行简单的表单提交了，包括文件上传。然后，可以看到通过调用form.parse传递给回调函数的files对象的内容，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">received upload:</div><div class="line"></div><div class="line">&#123; fields: &#123; title: &apos;Hello World&apos; &#125;,</div><div class="line">  files:</div><div class="line">   &#123; upload:</div><div class="line">      &#123; size: 1558,</div><div class="line">        path: &apos;/tmp/1c747974a27a6292743669e91f29350b&apos;,</div><div class="line">        name: &apos;us-flag.png&apos;,</div><div class="line">        type: &apos;image/png&apos;,</div><div class="line">        lastModifiedDate: Tue, 21 Jun 2011 07:02:41 GMT,</div><div class="line">        _writeStream: [Object],</div><div class="line">        length: [Getter],</div><div class="line">        filename: [Getter],</div><div class="line">        mime: [Getter] &#125; &#125; &#125;</div></pre></td></tr></table></figure></p>
<p>为了实现我们的功能，我们需要将上述代码应用到我们的应用中，另外，我们还要考虑如何将上传文件的内容（保存在/tmp目录中）显示到浏览器中。</p>
<p>我们先来解决后面那个问题： 对于保存在本地硬盘中的文件，如何才能在浏览器中看到呢？</p>
<p>显然，我们需要将该文件读取到我们的服务器中，使用一个叫fs的模块。</p>
<p>我们来添加/showURL的请求处理程序，该处理程序直接硬编码将文件/tmp/test.png内容展示到浏览器中。当然了，首先需要将该图片保存到这个位置才行。</p>
<p>将requestHandlers.js修改为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">"querystring"</span>),</div><div class="line">    fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> body = <span class="string">'&lt;html&gt;'</span>+</div><div class="line">    <span class="string">'&lt;head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;meta http-equiv="Content-Type" '</span>+</div><div class="line">    <span class="string">'content="text/html; charset=UTF-8" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;form action="/upload" method="post"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;textarea name="text" rows="20" cols="60"&gt;&lt;/textarea&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="submit" value="Submit text" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/form&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/html&gt;'</span>;</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</div><div class="line">    response.write(body);</div><div class="line">    response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">  response.write(<span class="string">"You've sent the text: "</span>+</div><div class="line">  querystring.parse(postData).text);</div><div class="line">  response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'show' was called."</span>);</div><div class="line">  fs.readFile(<span class="string">"/tmp/test.png"</span>, <span class="string">"binary"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(error) &#123;</div><div class="line">      response.writeHead(<span class="number">500</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">      response.write(error + <span class="string">"\n"</span>);</div><div class="line">      response.end();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"image/png"</span>&#125;);</div><div class="line">      response.write(file, <span class="string">"binary"</span>);</div><div class="line">      response.end();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div><div class="line">exports.show = show;</div></pre></td></tr></table></figure></p>
<p>我们还需要将这新的请求处理程序，添加到index.js中的路由映射表中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</div><div class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</div><div class="line"><span class="keyword">var</span> requestHandlers = <span class="built_in">require</span>(<span class="string">"./requestHandlers"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> handle = &#123;&#125;</div><div class="line">handle[<span class="string">"/"</span>] = requestHandlers.start;</div><div class="line">handle[<span class="string">"/start"</span>] = requestHandlers.start;</div><div class="line">handle[<span class="string">"/upload"</span>] = requestHandlers.upload;</div><div class="line">handle[<span class="string">"/show"</span>] = requestHandlers.show;</div><div class="line"></div><div class="line">server.start(router.route, handle);</div></pre></td></tr></table></figure></p>
<p>重启服务器之后，通过访问<a href="http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。" target="_blank" rel="external">http://localhost:8888/show，就可以看到保存在/tmp/test.png的图片了。</a></p>
<p>好，最后我们要的就是：</p>
<ul>
<li>在/start表单中添加一个文件上传元素</li>
<li>将node-formidable整合到我们的upload请求处理程序中，用于将上传的图片保存到/tmp/test.png</li>
<li>将上传的图片内嵌到/uploadURL输出的HTML中</li>
</ul>
<p>第一项很简单。只需要在HTML表单中，添加一个multipart/form-data的编码类型，移除此前的文本区，添加一个文件上传组件，并将提交按钮的文案改为“Upload file”即可。 如下requestHandler.js所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">"querystring"</span>),</div><div class="line">    fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> body = <span class="string">'&lt;html&gt;'</span>+</div><div class="line">    <span class="string">'&lt;head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;meta http-equiv="Content-Type" '</span>+</div><div class="line">    <span class="string">'content="text/html; charset=UTF-8" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;form action="/upload" enctype="multipart/form-data" '</span>+</div><div class="line">    <span class="string">'method="post"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="file" name="upload"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="submit" value="Upload file" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/form&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/html&gt;'</span>;</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</div><div class="line">    response.write(body);</div><div class="line">    response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">  response.write(<span class="string">"You've sent the text: "</span>+</div><div class="line">  querystring.parse(postData).text);</div><div class="line">  response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">response, postData</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'show' was called."</span>);</div><div class="line">  fs.readFile(<span class="string">"/tmp/test.png"</span>, <span class="string">"binary"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(error) &#123;</div><div class="line">      response.writeHead(<span class="number">500</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">      response.write(error + <span class="string">"\n"</span>);</div><div class="line">      response.end();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"image/png"</span>&#125;);</div><div class="line">      response.write(file, <span class="string">"binary"</span>);</div><div class="line">      response.end();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div><div class="line">exports.show = show;</div></pre></td></tr></table></figure></p>
<p>下一步相对比较复杂。这里有这样一个问题： 我们需要在upload处理程序中对上传的文件进行处理，这样的话，我们就需要将request对象传递给node-formidable的form.parse函数。</p>
<p>但是，我们有的只是response对象和postData数组。看样子，我们只能不得不将request对象从服务器开始一路通过请求路由，再传递给请求处理程序。 或许还有更好的方案，但是，不管怎么说，目前这样做可以满足我们的需求。</p>
<p>到这里，我们可以将postData从服务器以及请求处理程序中移除了 —— 一方面，对于我们处理文件上传来说已经不需要了，另外一方面，它甚至可能会引发这样一个问题： 我们已经“消耗”了request对象中的数据，这意味着，对于form.parse来说，当它想要获取数据的时候就什么也获取不到了。（因为Node.js不会对数据做缓存）</p>
<p>我们从server.js开始 —— 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line">    route(handle, pathname, response, request);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure></p>
<p>接下来是 router.js —— 我们不再需要传递postData了，这次要传递request对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname, response, request</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;</div><div class="line">    handle[pathname](response, request);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);</div><div class="line">    response.writeHead(<span class="number">404</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</div><div class="line">    response.write(<span class="string">"404 Not found"</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure>
<p>现在，request对象就可以在我们的upload请求处理程序中使用了。node-formidable会处理将上传的文件保存到本地/tmp目录中，而我们需要做的是确保该文件保存成/tmp/test.png。 没错，我们保持简单，并假设只允许上传PNG图片。</p>
<p>这里采用fs.renameSync(path1,path2)来实现。要注意的是，正如其名，该方法是同步执行的， 也就是说，如果该重命名的操作很耗时的话会阻塞。 这块我们先不考虑。</p>
<p>接下来，我们把处理文件上传以及重命名的操作放到一起，如下requestHandlers.js所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">"querystring"</span>),</div><div class="line">    fs = <span class="built_in">require</span>(<span class="string">"fs"</span>),</div><div class="line">    formidable = <span class="built_in">require</span>(<span class="string">"formidable"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> body = <span class="string">'&lt;html&gt;'</span>+</div><div class="line">    <span class="string">'&lt;head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;meta http-equiv="Content-Type" content="text/html; '</span>+</div><div class="line">    <span class="string">'charset=UTF-8" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/head&gt;'</span>+</div><div class="line">    <span class="string">'&lt;body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;form action="/upload" enctype="multipart/form-data" '</span>+</div><div class="line">    <span class="string">'method="post"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="file" name="upload" multiple="multiple"&gt;'</span>+</div><div class="line">    <span class="string">'&lt;input type="submit" value="Upload file" /&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/form&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/body&gt;'</span>+</div><div class="line">    <span class="string">'&lt;/html&gt;'</span>;</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</div><div class="line">    response.write(body);</div><div class="line">    response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response, request</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line"></div><div class="line">  <span class="keyword">var</span> form = <span class="keyword">new</span> formidable.IncomingForm();</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"about to parse"</span>);</div><div class="line">  form.parse(request, <span class="function"><span class="keyword">function</span>(<span class="params">error, fields, files</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"parsing done"</span>);</div><div class="line">    fs.renameSync(files.upload.path, <span class="string">"/tmp/test.png"</span>);</div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>&#125;);</div><div class="line">    response.write(<span class="string">"received image:&lt;br/&gt;"</span>);</div><div class="line">    response.write(<span class="string">"&lt;img src='/show' /&gt;"</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'show' was called."</span>);</div><div class="line">  fs.readFile(<span class="string">"/tmp/test.png"</span>, <span class="string">"binary"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, file</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span>(error) &#123;</div><div class="line">      response.writeHead(<span class="number">500</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">      response.write(error + <span class="string">"\n"</span>);</div><div class="line">      response.end();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"image/png"</span>&#125;);</div><div class="line">      response.write(file, <span class="string">"binary"</span>);</div><div class="line">      response.end();</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div><div class="line">exports.show = show;</div></pre></td></tr></table></figure></p>
<p>好了，重启服务器，我们应用所有的功能就可以用了。选择一张本地图片，将其上传到服务器，然后浏览器就会显示该图片。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/06/02/python-coroutine-2017-06-02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/02/python-coroutine-2017-06-02/" itemprop="url">Python之coroutine</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-02T13:57:23+08:00">
                2017-06-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Coroutine概念"><a href="#Coroutine概念" class="headerlink" title="Coroutine概念"></a>Coroutine概念</h3><p>Coroutine，又称作协程。即协同运行的例程，它是比是线程（thread）更细量级的用户态线程.特点是允许用户的主动调用和主动退出，挂起当前的例程然后返回值或去执行其他任务，接着返回原来停下的点继续执行。</p>
<p>一般函数都是线性执行的，不可能说执行到一半返回，等会儿又跑到原来的地方继续执行。但python（or其他动态语言）可以做到，答案是用yield语句。</p>
<p>其实是操作系统（OS）为我们做的工作，因为它具有getcontext和swapcontext这些特性，通过系统调用，我们可以把上下文和状态保存起来，切换到其他的上下文，这些特性为coroutine的实现提供了底层的基础。操作系统的Interrupts和Traps机制则为这种实现提供了可能性，因此它看起来可能是下面这样的:</p>
<p><img src="/2017/06/02/python-coroutine-2017-06-02/1.png" alt=""></p>
<h3 id="理解生成器（generator）"><a href="#理解生成器（generator）" class="headerlink" title="理解生成器（generator）"></a>理解生成器（generator）</h3><p>python有yield这个关键字，它能把一个函数变成一个generator，与return不同，yield在函数中返回值时会保存函数的状态，使下一次调用函数时会从上一次的状态继续执行，即从yield的下一条语句开始执行，节省存储空间，提高运行效率。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(max)</span>:</span></div><div class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></div><div class="line">    <span class="keyword">while</span> n  max:</div><div class="line">        <span class="keyword">yield</span> b</div><div class="line">        a, b = b, a + b</div><div class="line">        n = n + <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>注意: yield 对应的值在函数被调用时不会立刻返回，而是调用next方法时（本质上 for 循环也是调用 next 方法）才返回.</p>
<h3 id="生产者-消费者协程"><a href="#生产者-消费者协程" class="headerlink" title="生产者-消费者协程"></a>生产者-消费者协程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#-*- coding:utf-8</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></div><div class="line">    status = <span class="keyword">True</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        n = <span class="keyword">yield</span> status</div><div class="line">        print(<span class="string">"我拿到了&#123;&#125;!"</span>.format(n))</div><div class="line">        <span class="keyword">if</span> n == <span class="number">3</span>:</div><div class="line">            status = <span class="keyword">False</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">(consumer)</span>:</span></div><div class="line">    n = <span class="number">5</span></div><div class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</div><div class="line">        <span class="comment"># yield给主程序返回消费者的状态</span></div><div class="line">        <span class="keyword">yield</span> consumer.send(n)</div><div class="line">        n -= <span class="number">1</span></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    c = consumer()</div><div class="line">    c.send(<span class="keyword">None</span>)</div><div class="line">    p = producer(c)</div><div class="line">    <span class="keyword">for</span> status <span class="keyword">in</span> p:</div><div class="line">        <span class="keyword">if</span> status == <span class="keyword">False</span>:</div><div class="line">            print(<span class="string">"我只要3,4,5就行啦"</span>)</div><div class="line">            <span class="keyword">break</span></div><div class="line">    print(<span class="string">"程序结束"</span>)</div><div class="line"></div><div class="line"></div><div class="line">我拿到了<span class="number">5</span>!</div><div class="line">我拿到了<span class="number">4</span>!</div><div class="line">我拿到了<span class="number">3</span>!</div><div class="line">我只要<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>就行啦</div><div class="line">程序结束</div></pre></td></tr></table></figure>
<p>分析:<br>从主程序中开始看，第一句<code>c = consumer()</code>，因为consumer函数中存在yield语句，python会把它当成一个generator（生成器，注意：生成器和协程的概念区别很大,千万别混淆了两者），因此在运行这条语句后，python并不会像执行函数一样，而是返回了一个generator object。</p>
<p>第二条语句<code>c.send(None)</code>，这条语句的作用是将consumer（即变量c，它是一个generator）中的语句推进到第一个yield语句出现的位置，在例子中，consumer中的<code>status = True</code>和<code>while True:</code>都已经被执行了，程序停留在<code>n = yield status</code>的位置（注意：此时这条语句还没有被执行），上面说的send(None)语句十分重要，如果漏写这一句，那么程序直接报错。</p>
<p>下面第三句<code>p = producer(c)</code>，这里像上面一样定义了producer的生成器，注意:这里我们传入了消费者的生成器，来让producer跟consumer通信。</p>
<p>第四句<code>for status in p:</code>，这条语句会循环地运行producer和获取它yield回来的状态。</p>
<p>现在我们要让生产者发送1,2,3,4,5给消费者，消费者接受数字，返回状态给生产者，而我们的消费者只需要3,4,5就行了，当数字等于3时，会返回一个错误的状态。最终我们需要由主程序来监控生产者－消费者的过程状态，调度结束程序。</p>
<p>现在程序流进入了producer里面，我们直接看yield consumer.send(n)，生产者调用了消费者的send()方法，把n发送给consumer（即c），在consumer中的n = yield status，n拿到的是消费者发送的数字，同时，consumer用yield的方式把状态（status）返回给消费者，注意：这时producer（即消费者）的consumer.send()调用返回的就是consumer中yield的status！消费者马上将status返回给调度它的主程序，主程序获取状态，判断是否错误，若错误，则终止循环，结束程序。上面看起来有点绕，其实这里面generator.send(n)的作用是：把n发送generator(生成器)中yield的赋值语句中，同时返回generator中yield的变量（结果）。</p>
<p>于是程序便一直运作，直至consumer中获取的n的值变为3！此时consumer把status变为False，最后返回到主程序，主程序中断循环，程序结束。（观察输出结果，是否如你所想？）</p>
<h3 id="Coroutine与Generator区别"><a href="#Coroutine与Generator区别" class="headerlink" title="Coroutine与Generator区别"></a>Coroutine与Generator区别</h3><p>最重要的区别：</p>
<ul>
<li>generator总是生成值，一般是迭代的序列</li>
<li>coroutine关注的是消耗值，是数据(data)的消费者</li>
<li>coroutine不会与迭代操作关联，而generator会</li>
<li>coroutine强调协同控制程序流，generator强调保存状态和产生数据</li>
</ul>
<p>相似的是，它们都是不用return来实现重复调用的函数/对象，都用到了yield(中断/恢复)的方式来实现。</p>
<h3 id="asyncio与gevent"><a href="#asyncio与gevent" class="headerlink" title="asyncio与gevent"></a>asyncio与gevent</h3><p>asyncio是python 3.4中新增的模块，它提供了一种机制，使得你可以用协程（coroutines）、IO复用（multiplexing I/O）在单线程环境中编写并发模型。</p>
<p>asyncio模块主要包括了：</p>
<ul>
<li>具有特定系统实现的事件循环（event loop）;</li>
<li>数据通讯和协议抽象（类似Twisted中的部分);</li>
<li>TCP，UDP,SSL，子进程管道，延迟调用和其他;</li>
<li>Future类;</li>
<li>yield from的支持;</li>
<li>同步的支持;</li>
<li>提供向线程池转移作业的接口;</li>
</ul>
<p>下面来看下asyncio的一个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> asyncio</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(x, y)</span>:</span></div><div class="line">    print(<span class="string">"Compute %s + %s ..."</span> % (x, y))</div><div class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1.0</span>)</div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"></div><div class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">print_sum</span><span class="params">(x, y)</span>:</span></div><div class="line">    result = <span class="keyword">await</span> compute(x, y)</div><div class="line">    print(<span class="string">"%s + %s = %s"</span> % (x, y, result))</div><div class="line"></div><div class="line">loop = asyncio.get_event_loop()</div><div class="line">loop.run_until_complete(print_sum(<span class="number">1</span>, <span class="number">2</span>))</div><div class="line">loop.close()</div></pre></td></tr></table></figure></p>
<p>当事件循环开始运行时，它会在Task中寻找coroutine来执行调度，因为事件循环注册了<code>print_sum()</code>，因此<code>print_sum()</code>被调用，执行<code>result = await compute(x, y)</code>这条语句（等同于<code>result = yield from compute(x, y)</code>），因为<code>compute()</code>自身就是一个coroutine，因此<code>print_sum()</code>这个协程就会暂时被挂起，<code>compute()</code>被加入到事件循环中，程序流执行<code>compute()</code>中的print语句，打印”Compute %s + %s …”，然后执行了<code>await asyncio.sleep(1.0)</code>，因为<code>asyncio.sleep()</code>也是一个coroutine，接着<code>compute()</code>就会被挂起，等待计时器读秒，在这1秒的过程中，事件循环会在队列中查询可以被调度的coroutine，而因为此前<code>print_sum()</code>与<code>compute()</code>都被挂起了，因此事件循环会停下来等待协程的调度，当计时器读秒结束后，程序流便会返回到<code>compute()</code>中执行return语句，结果会返回到<code>print_sum()</code>中的result中，最后打印result，事件队列中没有可以调度的任务了，此时<code>loop.close()</code>把事件队列关闭，程序结束。</p>
<p>Gevent是一个基于libv的封装了greenlet的网络库，主要用于协程以及并发的处理。</p>
<p>gevent的基本原理：</p>
<p>当一个greenlet遇到IO操作时，比如访问网络，就自动切换到其他的greenlet，等到IO操作完成，再在适当的时候切换回来继续执行。由于IO操作非常耗时，经常使程序处于等待状态，有了gevent为我们自动切换协程，就保证总有greenlet在运行，而不是等待IO。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.jianshu.com/p/afa86801c038" target="_blank" rel="external">理解python coroutine</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/06/01/node-notes2-2017-06-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/01/node-notes2-2017-06-01/" itemprop="url">Node笔记2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-01T17:43:53+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于函数式编程"><a href="#关于函数式编程" class="headerlink" title="关于函数式编程"></a>关于函数式编程</h3><p>将函数作为参数传递并不仅仅出于技术上的考量。对软件设计来说，这其实是个哲学问题。</p>
<p>想想这样的场景：在index文件中，我们可以将router对象传递进去，服务器随后可以调用这个对象的route函数。就像这样，我们传递一个东西，然后服务器利用这个东西来完成一些事。然后,那个叫路由的东西，能帮我把这个路由一下吗？但是服务器其实不需要这样的东西。它只需要把事情做完就行，其实为了把事情做完，你根本不需要东西，你需要的是动作。</p>
<p>也就是说，你不需要名词，你需要动词。理解了这个概念里最核心、最基本的思想转换后，我自然而然地理解了函数编程。也就是说我直接执行动作,不必给动作定一个名称,然后让那个对象根据动作名称再去执行动作,有的时候不觉得这很啰嗦么?哈哈…</p>
<h3 id="路由给真正的请求处理程序"><a href="#路由给真正的请求处理程序" class="headerlink" title="路由给真正的请求处理程序"></a>路由给真正的请求处理程序</h3><p>路由: 是指我们要针对不同的URL有不同的处理方式。<br>我们暂时把作为路由目标的函数称为请求处理程序。现在我们不要急着来开发路由模块，因为如果请求处理程序没有就绪的话，再怎么完善路由模块也没有多大意义。<br>现在给应用程序增加一个新的部件。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// requestHandlers.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure>
<p>这样就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。</p>
<p>在requestHandlers模块添加一点依赖,使用依赖注入可以让路由和请求处理程序之间的耦合更加松散，也因此能让路由的重用性更高。</p>
<p>那么什么是依赖注入?<br>依赖注入（Dependency Injection）是用于实现控制反转（Inversion of Control）的最常见的方式之一。依赖注入不是目的，它是一系列工具和手段，最终的目的是帮助我们开发出松散耦合(loose coupled)、可维护、可测试的代码和程序。</p>
<p>这意味着我们得将请求处理程序(即handle)从服务器传递到路由中，但感觉上这么做更离谱了，我们得一路把这堆请求处理程序(handle)从我们的主文件(index.js)传递到服务器中(server.start函数)，再将hangle从服务器(server.start函数)传递到路由(route函数)。</p>
<p>那么我们要怎么传递这些请求处理程序呢？我们不想每次有一个新的URL或请求处理程序时，都要为了在路由里完成请求到处理程序的映射而反复折腾。除此之外，在路由里有一大堆<code>if request == x then call handler y</code>也使得系统丑陋不堪。</p>
<p>仔细想想，每个都要映射到一个字符串（就是请求的URL）上？似乎关联数组（associative array）能完美胜任。不过JavaScript没提供关联数组,事实上，在JavaScript中，真正能提供此类功能的是它的对象, 在python中是字典.不过javascript的对象更加强大.</p>
<blockquote>
<p>在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 – 你可以把JavaScript的对象想象成一个键为字符串类型的字典。</p>
</blockquote>
<p>JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？<br>这里的值可以是字符串、数字或者函数.</p>
<p>现在我们已经确定将一系列请求处理程序通过一个对象(即handle)来传递，并且需要使用松耦合的方式将这个对象注入到route()函数中。<br>我们先将这个对象引入到主文件index.js中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// index.js</span></div><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</div><div class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</div><div class="line"><span class="keyword">var</span> requestHandlers = <span class="built_in">require</span>(<span class="string">"./requestHandlers"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 请求处理程序对象</span></div><div class="line"><span class="keyword">var</span> handle = &#123;&#125;;</div><div class="line">handle[<span class="string">"/"</span>] = requestHandlers.start;</div><div class="line">handle[<span class="string">"/start"</span>] = requestHandlers.start;</div><div class="line">handle[<span class="string">"/upload"</span>] = requestHandlers.upload;</div><div class="line"></div><div class="line">server.start(router.route, handle);</div></pre></td></tr></table></figure></p>
<p>将不同的URL映射到相同的请求处理程序上是很容易的：只要在对象中添加一个键为”/“的属性，对应requestHandlers.start即可，这样就可以干净简洁地配置/start和/的请求都交由start这一处理程序处理。</p>
<p>在完成了对象的定义后，我们把它作为额外的参数传递给服务器，为此将server.js修改如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// server.js</span></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line"></div><div class="line">    route(handle, pathname);</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">    response.write(<span class="string">"Hello World"</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure></p>
<p>在start()函数里添加了handle参数,并把handle对象作为第一个参数传递给了route()回调函数。<br>然后我们相应地在route.js文件中修改route()函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// route.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;</div><div class="line">    handle[pathname]();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure></p>
<p>在命令行运行:<code>node index.js</code>, 通过以上代码，首先检查给定的路径对应的请求处理程序是否存在，如果存在直接调用相应的函数。我们可以用从关联数组中获取元素一样的方式从传递的对象中获取请求处理函数，因此就有了简洁流畅的形如<code>handle[pathname]();</code>的表达式，这个感觉就像在前方中提到的那样：“嗨，请帮我处理了这个路径”。</p>
<h3 id="让请求处理程序作出响应"><a href="#让请求处理程序作出响应" class="headerlink" title="让请求处理程序作出响应"></a>让请求处理程序作出响应</h3><p>其实“处理请求”说白了就是“对请求作出响应”，因此，我们需要让请求处理程序能够像onRequest函数那样可以和浏览器进行“对话”。</p>
<p>不好的实现方式<br>不好的实现方式是指:让请求处理程序通过onRequest函数直接返回（return()）他们要展示给用户的信息。</p>
<p>我们先就这样去实现，然后再来看为什么这不是一种很好的实现方式。</p>
<p>让我们从让请求处理程序返回需要在浏览器中显示的信息开始。我们需要将requestHandler.js修改为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line">  <span class="keyword">return</span> <span class="string">"Hello Start"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure></p>
<p>同样请求路由需要将请求处理程序返回给它的信息返回给服务器。因此，我们需要将router.js修改为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> handle[pathname]();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);</div><div class="line">    <span class="keyword">return</span> <span class="string">"404 Not found"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure></p>
<p>正如上述代码所示，当请求无法路由的时候，我们也返回了一些相关的错误信息。</p>
<p>最后，对server.js进行重构以使得它能够将请求处理程序通过请求路由返回的内容响应给浏览器，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">    <span class="keyword">var</span> content = route(handle, pathname);</div><div class="line">    response.write(content);</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure></p>
<p>运行重构后的应用，一切都会工作的很好：<br>请求<a href="http://localhost:8888/start,浏览器会输出“Hello" target="_blank" rel="external">http://localhost:8888/start,浏览器会输出“Hello</a> Start”，<br>请求<a href="http://localhost:8888/upload会输出“Hello" target="_blank" rel="external">http://localhost:8888/upload会输出“Hello</a> Upload”,<br>请求<a href="http://localhost:8888/foo" target="_blank" rel="external">http://localhost:8888/foo</a> 会输出“404 Not found”。</p>
<p>那么问题在哪里呢？<br>简单的说就是： 当未来有请求处理程序需要进行非阻塞的操作的时候，我们的应用就“挂”了。<br>为什么呢?</p>
<h3 id="阻塞与非阻塞"><a href="#阻塞与非阻塞" class="headerlink" title="阻塞与非阻塞"></a>阻塞与非阻塞</h3><p>直接来看，当在请求处理程序中加入阻塞操作时会发生什么?<br>修改下start请求处理程序，让它等待10秒以后再返回“Hello Start”。因为，JavaScript中没有类似sleep()这样的操作，所以这里只能够来点小Hack来模拟实现。<br>将requestHandlers.js修改成如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">milliSeconds</span>) </span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() &lt; startTime + milliSeconds);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  sleep(<span class="number">10000</span>);</div><div class="line">  <span class="keyword">return</span> <span class="string">"Hello Start"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure></p>
<p>上述代码中，当函数start()被调用的时候，Node.js会先等待10秒，之后才会返回“Hello Start”。当调用upload()的时候，会和此前一样立即返回。<br>(这里只是模拟休眠10秒，实际场景中，这样的阻塞操作有很多，比如耗时的计算操作等。）</p>
<p>我们重启下服务器。为了看到效果，我们要进行一些相对复杂的操作：<br>首先，打开两个浏览器窗口或者标签页。在第一个浏览器窗口的地址栏中输入<a href="http://localhost:8888/start，" target="_blank" rel="external">http://localhost:8888/start，</a> 但是先不要打开它！在第二个浏览器窗口的地址栏中输入<a href="http://localhost:8888/upload，" target="_blank" rel="external">http://localhost:8888/upload，</a> 同样的，先不要打开它！接下来，做如下操作：在第一个窗口中（“/start”）按下回车，然后快速切换到第二个窗口中（“/upload”）按下回车。</p>
<p>注意，发生了什么： /start URL加载花了10秒，但是，/upload URL居然也花了10秒，而它在对应的请求处理程序中并没有类似于sleep()这样的操作！</p>
<p>这到底是为什么呢？<br>原因就是start()包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。</p>
<p>这显然是个问题，因为Node一向是这样来标榜自己的：“在node中除了代码，所有一切都是并行执行的”。这句话的意思是说，Node.js可以在不新增额外线程的情况下，依然可以对任务进行并行处理 —— Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作，对此，应该尽可能的避免阻塞操作，取而代之，多使用非阻塞操作。然而，要用非阻塞操作，需要使用回调，通过将函数作为参数传递给其他需要花时间做处理的函数（比方说，休眠10秒，或者查询数据库，又或者是进行大量的计算）。对于Node.js来说，它是这样处理的：“嘿，probablyExpensiveFunction()（译者注：这里指的就是需要花时间处理的函数），你继续处理你的事情，我（Node.js线程）先不等你了，我继续去处理你后面的代码，请你提供一个callbackFunction()，等你处理完之后我会去调用该回调函数的，谢谢！”</p>
<h4 id="一种错误的使用非阻塞操作的方式"><a href="#一种错误的使用非阻塞操作的方式" class="headerlink" title="一种错误的使用非阻塞操作的方式"></a>一种错误的使用非阻塞操作的方式</h4><p>还是从start请求处理程序开始。将其修改成如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">"child_process"</span>).exec;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line">  <span class="keyword">var</span> content = <span class="string">"empty"</span>;</div><div class="line"></div><div class="line">  exec(<span class="string">"ls -lah"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</div><div class="line">    content = stdout;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> content;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure></p>
<p>上述代码中，引入了一个新的Node.js内建模块child_process。之所以用它，是为了实现一个既简单又实用的非阻塞操作：exec()。</p>
<p>exec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。</p>
<p>上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。</p>
<p>和往常一样，我们启动服务器，然后访问“<a href="http://localhost:8888/start”" target="_blank" rel="external">http://localhost:8888/start”</a> 。之后会载入一个漂亮的web页面，其内容为“empty”, 却不是”hello start”。怎么回事？<br>原因是exec()在非阻塞这块发挥了神奇的功效。它其实是个很好的东西，有了它，我们可以执行非常耗时的shell操作而无需迫使应用停下来等待该操作。然而，针对浏览器显示的结果来看，我们并不满意我们的非阻塞操作，对吧？好，接下来，我们来修正这个问题。在这过程中，让我们先来看看为什么当前的这种方式不起作用。<br>问题就在于:为了进行非阻塞工作，exec()使用了回调函数。<br>在我们的例子中，该回调函数就是作为第二个参数传递给exec()的匿名函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exec(<span class="string">"ls -lah"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</div><div class="line">   content = stdout;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure></p>
<p>现在就到了问题根源所在了：代码是同步执行的，这就意味着在调用exec()之后，Node.js会立即执行<code>return content;</code>, 而此时content仍然是“empty”，因为传递给exec()的回调函数还未执行到, 因为exec()的操作是异步的。这里“ls -lah”的操作其实是非常快的（除非当前目录下有上百万个文件）。这也是为什么回调函数也会很快的执行到, 不过，不管怎么说它还是异步的。为了让效果更加明显，我们使用一个更耗时的命令： “find /”，尽管在请求处理程序中，把“ls -lah”换成“find /”，当打开/start URL的时候，依然能够立即获得HTTP响应 —— 很明显，当exec()在后台执行的时候，Node.js自身会继续执行后面的代码。并且我们这里假设传递给exec()的回调函数，只会在“find /”命令执行完成之后才会被调用。</p>
<p>那究竟我们要如何才能实现将当前目录下的文件列表显示给用户呢？<br>了解了这种不好的实现方式之后，我们接下来来介绍如何以正确的方式让请求处理程序对浏览器请求作出响应。</p>
<h3 id="以非阻塞操作进行请求响应"><a href="#以非阻塞操作进行请求响应" class="headerlink" title="以非阻塞操作进行请求响应"></a>以非阻塞操作进行请求响应</h3><p>正确的方式是Node.js有这样一种实现方案:函数传递。<br>目前,我们的应用已经可以通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。</p>
<p>现在采用新的实现方式：相对采用将内容传递给服务器的方式，这次采用将服务器“传递”给内容的方式。 从实践角度来说，就是将response对象（从服务器的回调函数onRequest()获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。</p>
<p>原理就是如此，接下来一步步实现这种方案。<br>先从server.js开始：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span></div><div class="line"><span class="function">  </span>&#123;</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line">    <span class="comment">// 注意route函数的第三个参数</span></div><div class="line">    route(handle, pathname, response);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure></p>
<p>相对此前从route()函数获取返回值的做法，这次将response对象作为第三个参数传递给route()函数，并且，将onRequest()处理程序中所有有关response的函数调都移除，因为我们希望这部分工作让route()函数来完成。</p>
<p>下面就来看看我们的router.js:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname, response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) &#123;</div><div class="line">    handle[pathname](response);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"No request handler found for "</span> + pathname);</div><div class="line">    response.writeHead(<span class="number">404</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">    response.write(<span class="string">"404 Not found"</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure></p>
<p>同样的模式：相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递response对象。<br>如果没有对应的请求处理器处理，我们就直接返回“404”错误。<br>最后，我们将requestHandler.js修改为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">"child_process"</span>).exec;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line"></div><div class="line">  exec(<span class="string">"ls -lah"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">    response.write(stdout);</div><div class="line">    response.end();</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">  response.write(<span class="string">"Hello Upload"</span>);</div><div class="line">  response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure></p>
<p>我们的处理程序函数需要接收response参数，为了对请求作出直接的响应。</p>
<p>start处理程序在exec()的匿名回调函数中做请求响应的操作，而upload处理程序仍然是简单的回复“Hello World”，只是这次是使用response对象而已。</p>
<p>这时再次我们启动应用（node index.js），一切都会工作的很好。</p>
<p>如果想要证明/start处理程序中耗时的操作不会阻塞对/upload请求作出立即响应的话，可以将requestHandlers.js修改为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">"child_process"</span>).exec;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'start' was called."</span>);</div><div class="line"></div><div class="line">  exec(<span class="string">"find /"</span>,</div><div class="line">    &#123; <span class="attr">timeout</span>: <span class="number">10000</span>, <span class="attr">maxBuffer</span>: <span class="number">20000</span>*<span class="number">1024</span> &#125;,</div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>&#123;</div><div class="line">      response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">      response.write(stdout);</div><div class="line">      response.end();</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Request handler 'upload' was called."</span>);</div><div class="line">  response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">  response.write(<span class="string">"Hello Upload"</span>);</div><div class="line">  response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div><div class="line">exports.upload = upload;</div></pre></td></tr></table></figure></p>
<p>这样一来，当请求<a href="http://localhost:8888/start的时候，会花10秒钟的时间才载入，" target="_blank" rel="external">http://localhost:8888/start的时候，会花10秒钟的时间才载入，</a><br>而当请求<a href="http://localhost:8888/upload的时候，会立即响应，纵然这个时候/start响应还在处理中。" target="_blank" rel="external">http://localhost:8888/upload的时候，会立即响应，纵然这个时候/start响应还在处理中。</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.nodebeginner.org/index-zh-cn.html#execution-in-the-kongdom-of-verbs" target="_blank" rel="external">Node入门</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/06/01/node-notes-2017-06-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/01/node-notes-2017-06-01/" itemprop="url">Node笔记1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-01T15:45:03+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="创建一个http服务器"><a href="#创建一个http服务器" class="headerlink" title="创建一个http服务器"></a>创建一个http服务器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 第一行请求（require）Node.js自带的 http 模块，并且把它赋值给 http 变量。</span></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="comment">// 调用http模块提供的函数:createServer.该函数会返回一个对象</span></div><div class="line"><span class="comment">// 该对象有一个listen的方法,该方法有一个数值参数,指定这个HTTP服务器监听的端口号。</span></div><div class="line">http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>:<span class="string">"text/plain"</span>&#125;);</div><div class="line">    response.write(<span class="string">"Hello World"</span>);</div><div class="line">    response.end();</div><div class="line">&#125;).listen(<span class="number">8888</span>);</div></pre></td></tr></table></figure>
<p>在命令行输入:<code>node server.js</code>,打开浏览器访问<a href="http://localhost:8888/，你会看到一个写着“Hello" target="_blank" rel="external">http://localhost:8888/，你会看到一个写着“Hello</a> World”的网页。<br>注意:createServer 函数的参数是一个匿名函数。即<code>function(request, response){...}</code>.</p>
<h3 id="基于事件驱动的回调"><a href="#基于事件驱动的回调" class="headerlink" title="基于事件驱动的回调"></a>基于事件驱动的回调</h3><p>当使用 http.createServer 方法的时候，不只想要侦听某个端口，还想要它在服务器收到一个HTTP请求的时候做点什么。但问题是，这是异步的：请求任何时候都可能到达，但是服务器却跑在一个单进程中。那么Node.js程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢？<br>嗯，这就需要Node.js/JavaScript的事件驱动,现在看看这些概念是怎么应用在我们的服务器代码里的。<br>我们创建了服务器，并且向创建它的方法传递了一个函数。无论何时服务器收到一个请求，这个函数就会被调用。我们不知道这件事情什么时候会发生，但是我们现在有了一个处理请求的地方：它就是我们传递过去的那个匿名函数。至于它是被预先定义的函数还是匿名函数，就无关紧要了。这个就是传说中的 回调 。我们给某个方法传递了一个函数，这个方法在有相应事件发生时调用这个函数来进行回调 。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"></div><div class="line"><span class="comment">// http.createServer(function(request, response)</span></div><div class="line"><span class="comment">// &#123;</span></div><div class="line"><span class="comment">//     response.writeHead(200, &#123;"Content-Type":"text/plain"&#125;);</span></div><div class="line"><span class="comment">//     response.write("Hello World");</span></div><div class="line"><span class="comment">//     response.end();</span></div><div class="line"><span class="comment">// &#125;).listen(8888);</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>)</span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request receives."</span>);</div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>:<span class="string">"text/plain"</span>&#125;);</div><div class="line">    response.write(<span class="string">"Hello World"</span>);</div><div class="line">    response.end();</div><div class="line">&#125;</div><div class="line"></div><div class="line">http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div></pre></td></tr></table></figure>
<p>当运行<code>node server.js</code>时，它会马上在命令行上输出“Server has started.”。当我们向服务器发出请求（在浏览器访问<a href="http://localhost:8888/" target="_blank" rel="external">http://localhost:8888/</a> ）或者强制刷新页面时，“Request received.”这条消息就会在命令行中出现。这就是事件驱动的异步服务器端JavaScript和它的回调！<br><strong>注意:</strong>当我们在服务器访问网页时，服务器可能会输出两次“Request received.”。那是因为大部分浏览器都会在你访问 <a href="http://localhost:8888/" target="_blank" rel="external">http://localhost:8888/</a> 时尝试读取<a href="http://localhost:8888/favicon.ico" target="_blank" rel="external">http://localhost:8888/favicon.ico</a> )</p>
<h3 id="服务器是如何处理请求的"><a href="#服务器是如何处理请求的" class="headerlink" title="服务器是如何处理请求的"></a>服务器是如何处理请求的</h3><p>当回调启动，即onRequest()函数被触发的时候,有两个参数被传入:request 和 response.<br>它们是对象，你可以使用它们的方法来处理HTTP请求的细节，并且响应请求（比如向发出请求的浏览器发回一些东西）。所以当收到请求时，使用 response.writeHead() 函数发送一个HTTP状态200和HTTP头的内容类型（content-type），使用 response.write() 函数在HTTP相应主体中发送文本“Hello World”。最后，调用 response.end() 完成响应。目前来说，我们对请求的细节并不在意，所以我们没有使用 request 对象。</p>
<h3 id="关于变量命名"><a href="#关于变量命名" class="headerlink" title="关于变量命名"></a>关于变量命名</h3><p>Node.js中自带了一个叫做“http”的模块，在代码中请求它并把返回值赋给一个本地变量http。这样本地变量http就变成了一个拥有所有 http 模块所提供的公共方法的对象。给这种本地变量起一个和模块名称一样的名字是一种惯例，但你也可以按照自己的喜好来.</p>
<h3 id="创建自己的模块"><a href="#创建自己的模块" class="headerlink" title="创建自己的模块"></a>创建自己的模块</h3><p>我们把 server.js 变成一个真正的模块，你就能搞明白了。<br>事实上，我们不用做太多的修改。把某段代码变成模块意味着需要把我们希望提供其功能的部分 导出到请求这个模块的脚本。目前，HTTP服务器需要导出的功能非常简单，因为请求服务器模块的脚本仅仅是需要启动服务器而已。我们把服务器脚本放到一个叫做 start 的函数里，然后我们导出这个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// server.js</span></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request received."</span>);</div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">    response.write(<span class="string">"Hello World"</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 导出start函数</span></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure></p>
<p>这样，现在就可以创建我们的主文件 index.js 并在其中启动我们的HTTP了，虽然服务器的代码还在 server.js 中。创建 index.js 文件并写入以下内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</div><div class="line">server.start();</div></pre></td></tr></table></figure></p>
<p>正如上面所示代码，我们可以像使用任何其他的内置模块一样使用server模块：请求这个server.js文件并把它指向一个server变量，导出的start函数就可以被我们使用了。<br>好了。现在可以从我们的主要脚本启动我们的的应用了，在命令行输入：<code>node index.js</code></p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>处理不同的HTTP请求在代码中是一个不同的部分，叫做“路由选择”，接下来就创造一个叫做”路由”的模块。</p>
<p>我们要为路由提供请求的URL和其他需要的GET及POST参数，随后路由需要根据这些数据来执行相应的代码（这里“代码”对应整个应用的第三部分：一系列在接收到请求时真正工作的处理程序）。</p>
<p>因此，我们需要查看HTTP请求，从中提取出请求的URL以及GET/POST参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。</p>
<p>我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，需要额外的Node.JS模块，它们分别是url和querystring模块。当然我们也可以用querystring模块来解析POST请求体中的参数.现在我们来给onRequest()函数加上一些逻辑，用来找出浏览器请求的URL路径：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// server.js</span></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">    response.write(<span class="string">"Hello World"</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure>
<p>现在可以根据请求的URL路径来区别不同请求了,然后使用路由将请求以URL路径为基准映射到处理程序上。现在以来编写路由了，建立一个名为router.js的文件，添加以下内容：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">pathname</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"About to route a request for "</span> + pathname);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.route = route;</div></pre></td></tr></table></figure></p>
<p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑之前，我们需要先来看看如何把路由和服务器整合起来。使用硬编码的方式将这一依赖项绑定到服务器上是一件非常痛苦的事，因此我们采用依赖注入的方式来添加路由模块,这种方式较为松散.</p>
<p>首先，来扩展一下服务器的start()函数，以便将路由函数作为参数传递过去:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">"url"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 注意:start函数传进一个route参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route</span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> pathname = url.parse(request.url).pathname;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Request for "</span> + pathname + <span class="string">" received."</span>);</div><div class="line"></div><div class="line">    <span class="comment">// 这个route函数就是router模块里的route函数</span></div><div class="line">    route(pathname);</div><div class="line"></div><div class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>&#125;);</div><div class="line">    response.write(<span class="string">"Hello World"</span>);</div><div class="line">    response.end();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  http.createServer(onRequest).listen(<span class="number">8888</span>);</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Server has started."</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">exports.start = start;</div></pre></td></tr></table></figure></p>
<p>同时，相应扩展index.js，使得路由函数可以被注入到服务器中：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);</div><div class="line"><span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 这里将router模块的route函数传进start函数中去</span></div><div class="line">server.start(router.route);</div></pre></td></tr></table></figure></p>
<p>在这里，传递的route函数依旧什么也没做。如果现在启动应用随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由.输出结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">C:\Users\aron\AppData\Roaming\aronWorkSpace\arvinGithub\node&gt;node index.js</div><div class="line">Server has started.</div><div class="line">Request for / received.</div><div class="line">About to route a request for /</div><div class="line">Request for /favicon.ico received.</div><div class="line">About to route a request for /favicon.ico</div></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.nodebeginner.org/index-zh-cn.html#execution-in-the-kongdom-of-verbs" target="_blank" rel="external">Node入门</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://arvin-he.github.io/2017/06/01/python-advancefunc-2016-06-01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Arvin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Simple & Freedom">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/01/python-advancefunc-2016-06-01/" itemprop="url">Python之高阶函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-01T11:39:39+08:00">
                2017-06-01
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="高阶函数定义"><a href="#高阶函数定义" class="headerlink" title="高阶函数定义"></a>高阶函数定义</h3><p>高阶函数英文叫 Higher-order function, 一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>
<h3 id="变量可以指向函数"><a href="#变量可以指向函数" class="headerlink" title="变量可以指向函数"></a>变量可以指向函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">18</span>]: abs(<span class="number">-5</span>)         </div><div class="line">Out[<span class="number">18</span>]: <span class="number">5</span>               </div><div class="line">                         </div><div class="line">In [<span class="number">19</span>]: abs             </div><div class="line">Out[<span class="number">19</span>]: &lt;function abs&gt;  </div><div class="line">                         </div><div class="line">In [<span class="number">20</span>]: x = abs(<span class="number">-10</span>)    </div><div class="line">                         </div><div class="line">In [<span class="number">21</span>]: x               </div><div class="line">Out[<span class="number">21</span>]: <span class="number">10</span>              </div><div class="line">                         </div><div class="line">In [<span class="number">22</span>]: f = abs         </div><div class="line">                         </div><div class="line">In [<span class="number">23</span>]: f               </div><div class="line">Out[<span class="number">23</span>]: &lt;function abs&gt;  </div><div class="line"></div><div class="line">In [<span class="number">24</span>]: f(<span class="number">-6</span>)</div><div class="line">Out[<span class="number">24</span>]: <span class="number">6</span></div></pre></td></tr></table></figure>
<p>由上面的示例得出：函数本身也可以赋值给变量，即：变量可以指向函数。且该变量可以来调用这个函数.</p>
<h3 id="函数名也是变量"><a href="#函数名也是变量" class="headerlink" title="函数名也是变量"></a>函数名也是变量</h3><p>函数名其实就是指向函数的变量. 对于abs()这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数.<br>如果把abs指向其他对象，会有什么情况发生？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">25</span>]: abs = <span class="number">10</span>                                                          </div><div class="line">                                                                           </div><div class="line">In [<span class="number">26</span>]: abs(<span class="number">-10</span>)                                                          </div><div class="line">---------------------------------------------------------------------------</div><div class="line">TypeError                                 Traceback (most recent call last)</div><div class="line">&lt;ipython-input<span class="number">-26</span>-c432e3f1fd6c&gt; <span class="keyword">in</span> &lt;module&gt;()                              </div><div class="line">----&gt; 1 abs(-10)                                                           </div><div class="line">                                                                           </div><div class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</div></pre></td></tr></table></figure></p>
<p>把abs指向10后，就无法通过abs(-10)调用该函数了, 因为abs这个变量已经不指向求绝对值函数而是指向一个整数10！<br>当然实际代码绝对不能这么写，这里是为了说明函数名也是变量。要恢复abs函数，请重启Python交互环境。<br>注：由于abs函数实际上是定义在import builtins模块中的，所以要让修改abs变量的指向在其它模块也生效，要用import builtins; builtins.abs = 10。</p>
<h3 id="将函数作为参数传入"><a href="#将函数作为参数传入" class="headerlink" title="将函数作为参数传入"></a>将函数作为参数传入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">1</span>]: <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, f)</span>:</span></div><div class="line">   ...:     <span class="keyword">return</span> f(x) + f(y)</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [<span class="number">2</span>]: add(<span class="number">2</span>, <span class="number">-3</span>, abs)</div><div class="line">Out[<span class="number">2</span>]: <span class="number">5</span></div></pre></td></tr></table></figure>
<p>编写高阶函数，目的就是让函数的参数能够接收别的函数。</p>
<h3 id="常用的高阶函数"><a href="#常用的高阶函数" class="headerlink" title="常用的高阶函数"></a>常用的高阶函数</h3><ol>
<li>map()高阶函数<br>map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回.<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">3</span>]: <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></div><div class="line">   ...:     <span class="keyword">return</span> x*x</div><div class="line">   ...:</div><div class="line"></div><div class="line">In [<span class="number">4</span>]: r = map(f, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line"></div><div class="line">In [<span class="number">5</span>]: list(r)</div><div class="line">Out[<span class="number">5</span>]: [<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</div><div class="line"></div><div class="line">In [<span class="number">6</span>]: list(map(str, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))</div><div class="line">Out[<span class="number">6</span>]: [<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>]</div></pre></td></tr></table></figure>
</li>
</ol>
<p>map()传入的第一个参数是f，即函数对象本身。由于结果r是一个Iterator，Iterator是惰性序列，因此通过list()函数让它把整个序列都计算出来并返回一个list.</p>
<ol>
<li><p>reduce()高阶函数<br>reduce把一个函数作用在一个序列[x1, x2, x3, …]上，这个函数必须接收两个参数，一个是函数，一个是Iterable，reduce的作用就是把结果继续和序列的下一个元素做累积计算.即对于序列内所有元素进行累计操作.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">In [<span class="number">12</span>]: <span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"></div><div class="line">In [<span class="number">13</span>]: <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></div><div class="line">    ...:     <span class="keyword">return</span> x+y</div><div class="line">    ...:</div><div class="line"></div><div class="line">In [<span class="number">14</span>]: reduce(add, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</div><div class="line">Out[<span class="number">14</span>]: <span class="number">10</span></div><div class="line"></div><div class="line"><span class="comment"># 配合map()，我们就可以写出把str转换为int的函数：</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(x, y)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> x * <span class="number">10</span> + y</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">char2num</span><span class="params">(s)</span>:</span></div><div class="line"><span class="meta">... </span>    <span class="keyword">return</span> &#123;<span class="string">'0'</span>: <span class="number">0</span>, <span class="string">'1'</span>: <span class="number">1</span>, <span class="string">'2'</span>: <span class="number">2</span>, <span class="string">'3'</span>: <span class="number">3</span>, <span class="string">'4'</span>: <span class="number">4</span>, <span class="string">'5'</span>: <span class="number">5</span>, <span class="string">'6'</span>: <span class="number">6</span>, <span class="string">'7'</span>: <span class="number">7</span>, <span class="string">'8'</span>: <span class="number">8</span>, <span class="string">'9'</span>: <span class="number">9</span>&#125;[s]</div><div class="line">...</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(fn, map(char2num, <span class="string">'13579'</span>))</div><div class="line"><span class="number">13579</span></div><div class="line"><span class="comment"># 更简洁的写法,采用lambda函数</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">str2int</span><span class="params">(s)</span>:</span></div><div class="line">    <span class="keyword">return</span> reduce(<span class="keyword">lambda</span> x, y: x * <span class="number">10</span> + y, map(char2num, s))</div></pre></td></tr></table></figure>
</li>
<li><p>fiter()高阶函数<br>Python内建的filter()函数用于过滤序列。filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_odd</span><span class="params">(n)</span>:</span></div><div class="line">    <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">1</span></div><div class="line"></div><div class="line">list(filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>]))</div><div class="line"><span class="comment"># 结果: [1, 5, 9, 15]</span></div></pre></td></tr></table></figure>
</li>
<li><p>sorted()高阶函数<br>排序也是在程序中经常用到的算法。排序的核心是比较两个元素的大小。sorted()函数也是一个高阶函数，它接受3个参数, 其中接收一个key函数来实现自定义的排序，key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序, 例如按绝对值大小排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># sorted函数原型</span></div><div class="line">sorted(...)</div><div class="line">    sorted(iterable, key=None, reverse=False) --&gt; new sorted list</div><div class="line"></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="number">36</span>, <span class="number">5</span>, <span class="number">-12</span>, <span class="number">9</span>, <span class="number">-21</span>], key=abs)</div><div class="line">[<span class="number">5</span>, <span class="number">9</span>, <span class="number">-12</span>, <span class="number">-21</span>, <span class="number">36</span>]</div></pre></td></tr></table></figure>
</li>
</ol>
<p>对字符串排序，是按照ASCII的大小比较的,现在，我们提出排序应该忽略大小写，按照字母序排序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower)</div><div class="line">[<span class="string">'about'</span>, <span class="string">'bob'</span>, <span class="string">'Credit'</span>, <span class="string">'Zoo'</span>]</div></pre></td></tr></table></figure></p>
<p>要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>sorted([<span class="string">'bob'</span>, <span class="string">'about'</span>, <span class="string">'Zoo'</span>, <span class="string">'Credit'</span>], key=str.lower, reverse=<span class="keyword">True</span>)</div><div class="line">[<span class="string">'Zoo'</span>, <span class="string">'Credit'</span>, <span class="string">'bob'</span>, <span class="string">'about'</span>]</div></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014317849054170d563b13f0fa4ce6ba1cd86e18103f28000" target="_blank" rel="external">廖雪峰python教程</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/16/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><span class="page-number current">17</span><a class="page-number" href="/page/18/">18</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/18/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Arvin</p>
              <p class="site-description motion-element" itemprop="description">Learn and live.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">141</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Arvin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
