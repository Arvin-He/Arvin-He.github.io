---
title: 文件与 IO
tags:
---
1. 怎么读写各种不同编码的文本数据，比如 ASCII，UTF-8 或 UTF-16 编码等?
使用带有 rt 模式的 open() 函数读取文本文件
写入一个文本文件，使用带有 wt 模式的 open() 函数，如果之前文件内容存在则清除并覆盖掉。
如果是在已存在文件中添加内容，使用模式为 at 的 open() 函数。
文件的读写操作默认使用系统编码，可以通过调用 sys.getdefaultencoding() 来
得到。在大多数机器上面都是 utf-8 编码。如果你已经知道你要读写的文本是其他编码
方式，那么可以通过传递一个可选的 encoding 参数给 open() 函数

2. 关于换行符的识别问题，在 Unix 和 Windows 中是不一样的 (分别是 n 和 rn)。
默认情况下，Python 会以统一模式处理换行符。这种模式下，在读取文
本的时候，Python 可以识别所有的普通换行符并将其转换为单个 `\n` 字符。类似的，
在输出时会将换行符 \n 转换为系统默认的换行符。如果你不希望这种默认的处理方
式，可以给 open() 函数传入参数 `newline=''`.

3. 你读取或者写入一个文本文件时，你可能会遇到一个编码或者解码错误, 通常表示你读取文本时指定的编码不正确,如果编码错误还是存在的话，你可以给 open() 函数传递一个可选的 errors 参数来处理这些错误。
` g = open('sample.txt', 'rt', encoding='ascii', errors='ignore')`

4. 在 print() 函数中使用 sep 和 end 关键字参数，以你想要的方式输出
```python
print('ACME', 50, 91.5, sep=',', end='!!\n')
ACME,50,91.5!!
```

使用 end 参数也可以在输出中禁止换行
```python
>>>for i in range(5):
...     print(i, end=' ')

0 1 2 3 4 >>>
```

```python
>>> row = ('ACME', 50, 91.5)
>>> print(*row, sep=',')

ACME,50,91.5
```

5. 读写二进制文件，比如图片，声音文件
使用模式为 rb 或 wb 的 open() 函数来读取或写入二进制数据.
需要指明的是所有返回的数据都是字节字符串格式的，而不是文本字符串
在读取二进制数据的时候，特别需要注意的是，索引和迭代动作返回的是字节的值而不是字节字符串.如果你想从二进制模式的文件中读取或写入文本数据，必须确保要进行解码和编码操作。
```python
with open('somefile.bin', 'rb') as f:
    data = f.read(16)
    text = data.decode('utf-8')

with open('somefile.bin', 'wb') as f:
    text = 'Hello World'
    f.write(text.encode('utf-8'))
```

二进制 I/O 还有一个鲜为人知的特性就是数组和 C 结构体类型能直接被写入，而不需要中间转换为自己对象。

6. 文件不存在才能写入, 不允许覆盖已存在的文件内容
可以在 open() 函数中使用 x 模式来代替 w 模式的方法来解决这个问题,
如果文件是二进制的，使用 xb 来代替 xt.
要注意的是 x 模式是一个 Python3 对open() 函数特有的扩展。在 Python 的旧版本或者是 Python 实现的底层 C 函数库中都是没有这个模式的。

7. 字符串的 I/O 操作 
当你想模拟一个普通的文件的时候 StringIO 和 BytesIO 类是很有用的。比如，在
单元测试中，你可以使用 StringIO 来创建一个包含测试数据的类文件对象，这个对象
可以被传给某个参数为普通文件对象的函数。
需要注意的是， StringIO 和 BytesIO 实例并没有正确的整数类型的文件描述符。
因此，它们不能在那些需要使用真实的系统级文件如文件，管道或者是套接字的程序
中使用。

8. 读写压缩文件
读写一个 gzip 或 bz2 格式的压缩文件,gzip 和 bz2 模块可以很容易的处理这些文件。两个模块都为 open() 函数提供了另外的实现来解决这个问题.
大部分情况下读写压缩数据都是很简单的。但是要注意的是选择一个正确的文件模
式是非常重要的。如果你不指定模式，那么默认的就是二进制模式，如果这时候程序
想要接受的是文本数据，那么就会出错。
当写入压缩数据时，可以使用 compresslevel 这个可选的关键字参数来指定一个压缩级别。
```python
with gzip.open('somefile.gz', 'wt', compresslevel=5) as f:
    f.write(text)
```

默认的等级是 9，也是最高的压缩等级。等级越低性能越好，但是数据压缩程度也越低。
最后一点， gzip.open() 和 bz2.open() 还有一个很少被知道的特性，它们可以作
用在一个已存在并以二进制模式打开的文件上。
```python
import gzip
f = open('somefile.gz', 'rb')
with gzip.open(f, 'rt') as g:
    text = g.read()
```

这样就允许 gzip 和 bz2 模块可以工作在许多类文件对象上，比如套接字，管道和内存中文件等。

9. 什么是类文件对象?
类文件对象是任意一个带有read方法的对象，read方法有一个可选的size参数。
如果没有指定size，就会从输入源读入所有的数据作为单个字符串返回，否则，只读入size个数据返回。再次调用会从size处接着读。

10. 固定大小记录的文件迭代
你想在一个固定长度记录或者数据块的集合上迭代，而不是在一个文件中一行一行的迭代。
通过下面这个小技巧使用 iter 和 functools.partial() 函数：
```python
from functools import partial
RECORD_SIZE = 32
with open('somefile.data', 'rb') as f:
    records = iter(partial(f.read, RECORD_SIZE), b'')
    for r in records:
        ...
```

这个例子中的 records 对象是一个可迭代对象，它会不断的产生固定大小的数据
块，直到文件末尾。要注意的是如果总记录大小不是块大小的整数倍的话，最后一个
返回元素的字节数会比期望值少。

iter() 函数有一个鲜为人知的特性就是，如果你给它传递一个可调用对象和一个
标记值，它会创建一个迭代器。这个迭代器会一直调用传入的可调用对象直到它返回
标记值为止，这时候迭代终止。
在例子中， functools.partial 用来创建一个每次被调用时从文件中读取固定数
目字节的可调用对象。标记值 b'' 就是当到达文件结尾时的返回值。
最后再提一点，上面的例子中的文件时以二进制模式打开的。如果是读取固定大小
的记录，这通常是最普遍的情况。而对于文本文件，一行一行的读取 (默认的迭代行
为) 更普遍点。