---
title: cookbook8-类与对象
tags:
---
### 改变对象实例的打印或显示输出
要改变一个实例的字符串表示，可重新定义它的 str () 和 repr () 方法
`__repr__ ()` 方法返回一个实例的代码表示形式，通常用来重新构造这个实例。内置的`__repr__()`函数返回这个字符串，跟我们使用交互式解释器显示的值是一样的。`__str__()` 方法将实例转换为一个字符串，使用 str() 或 print() 函数会输出这个字符串. 
特别来讲，!r 格式化代码指明输出使用 repr () 来代替默认的 str () 。
自定义 `__repr__ ()` 和 `__str__ ()` 通常是很好的习惯，因为它能简化调试和实例输出。
`__repr__ ()` 生成的文本字符串标准做法是需要让 `eval(repr(x)) == x` 为真。如果实在不能这样子做，应该创建一个有用的文本表示，并使用 < 和 > 括起来.如果 `__str__ ()` 没有被定义，那么就会使用 `__repr__ ()` 来代替输出。

### 自定义字符串的格式化
通过 format() 函数和字符串方法使得一个对象能支持自定义的格式化.
为了自定义字符串的格式化，我们需要在类上面定义 format () 方法.
```python
_formats = {
'ymd' : '{d.year}-{d.month}-{d.day}',
'mdy' : '{d.month}/{d.day}/{d.year}',
'dmy' : '{d.day}/{d.month}/{d.year}'
}

class Date:
    def __init__(self, year, month, day):
        self.year = year
        self.month = month
        self.day = day

    def __format__(self, code):
        if code == '':
            code = 'ymd'
        fmt = _formats[code]
        return fmt.format(d=self)
```

现在 Date 类的实例可以支持格式化操作了，如同下面这样：
```python
>>> d = Date(2012, 12, 21)
>>> format(d)
'2012-12-21'
>>> format(d, 'mdy')
'12/21/2012'
>>> 'The date is {:ymd}'.format(d)
'The date is 2012-12-21'
>>> 'The date is {:mdy}'.format(d)
'The date is 12/21/2012'
``` 

### 让对象支持上下文管理协议
为了让一个对象兼容 with 语句，你需要实现 enter () 和 exit () 方法。

### 创建大量对象时节省内存方法
通过给类添加 `__slots__` 属性来极大的减少实例所占的内存,
当你定义 `__slots__` 后，Python 就会为实例使用一种更加紧凑的内部表示。实例通
过一个很小的固定大小的数组来构建，而不是为每个实例定义一个字典，这跟元组或
列表很类似。在 `__slots__` 中列出的属性名在内部被映射到这个数组的指定小标上。使
用 `__slots__` 一个不好的地方就是我们不能再给实例添加新的属性了，只能使用在 `__slots__`中定义的那些属性名。
关于 `__slots__` 的一个常见误区是它可以作为一个封装工具来防止用户给实例增加
新的属性。尽管使用 `__slots__` 可以达到这样的目的，但是这个并不是它的初衷。 `__slots__`更多的是用来作为一个内存优化工具。

### 在类中封装属性名
封装类的实例上面的“私有”数据，但是 Python 语言并没有访问控制,
Python 程序员不去依赖语言特性去封装数据，而是通过遵循一定的属性和方法命
名规约来达到这个效果。第一个约定是任何以单下划线 开头的名字都应该是内部实现。

同时还要注意到，使用下划线开头的约定同样适用于模块名和模块级别函数.
你还可能会遇到在类定义中使用两个下划线 ( ) 开头的命名, 使用双下划线开始会导致访问名称变成其他形式.比如，在前面的类 B 中，私有
属性会被分别重命名为 B private 和 B private method 。这时候你可能会问这样重命名的目的是什么，答案就是继承——这种属性通过继承是无法被覆盖的,这里，私有名称 private 和 private method 被重命名为 C private 和
C private method ，这个跟父类 B 中的名称是完全不同的。

上面提到有两种不同的编码约定 (单下划线和双下划线) 来命名私有属性，那么问题就来了：到底哪种方式好呢？
大多数而言，你应该让你的非公共名称以单下划线开头。但是，如果你清楚你的代码会涉及到子类，并且有些内部属性应该在子类中隐藏
起来，那么才考虑使用双下划线方案。

还有一点要注意的是，有时候你定义的一个变量和某个保留关键字冲突，这时候可以使用单下划线作为后缀.

### 创建可管理的属性
给某个实例 attribute 增加除访问与修改之外的其他处理逻辑，比如类型检查或合法性验证.
自定义某个属性的一种简单方法是将它定义为一个 property。
property 的一个关键特征是它看上去跟普通的 attribute 没什么两样，但是访问它的时候会自动触发 getter 、setter 和 deleter 方法。
只有当你确实需要对 attribute 执行其他额外的操作的时候才应该使用到 property。
不要写这种没有做任何其他额外操作的 property。首先，它会让你的代码变得很
臃肿，并且还会迷惑阅读者。其次，它还会让你的程序运行起来变慢很多。最后，这
样的设计并没有带来任何的好处。特别是当你以后想给普通 attribute 访问添加额外
的处理逻辑的时候，你可以将它变成一个 property 而无需改变原来的代码。因为访问
attribute 的代码还是保持原样。
Properties 还是一种定义动态计算 attribute 的方法。这种类型的 attributes 并不会
被实际的存储，而是在需要的时候计算出来。


重复代码会导致臃肿、易出错和丑陋的程序。好消息是，通过使用装饰器或闭包，有很多种更好的方法来完成同样的事情。

###  调用父类方法
在子类中调用父类的某个已经被覆盖的方法。可以使用 super() 函数，但是在多重继承的情况下需要注意super的用法.

### 子类中扩展 property
在子类中，你想要扩展定义在父类中的 property 的功能。
在子类中扩展一个 property 可能会引起很多不易察觉的问题，因为一个 property
其实是 getter、setter 和 deleter 方法的集合，而不是单个方法。因此，但你扩展
一个 property 的时候，你需要先确定你是否要重新定义所有的方法还是说只修改其中
某一个。如果你只想重定义其中一个方法，那只使用 @property 本身是不够的.

### 创建新的类或实例属性
创建一个新的拥有一些额外功能的实例属性类型，比如类型检查
想创建一个全新的实例属性，可以通过一个描述器类的形式来定义它的功能。
一个描述器就是一个实现了三个核心的属性访问操作 (get, set, delete) 的类，分别
为 `__get__ ()` 、`__set__ ()` 和 `__delete__ ()` 这三个特殊的方法。这些方法接受一个实例
作为输入，之后相应的操作实例底层的字典。


描述器可实现大部分 Python 类特性中的底层魔法，包括 @classmethod 、@staticmethod 、@property ，甚至是 `__slots__` 特性。
通过定义一个描述器，你可以在底层捕获核心的实例操作 (get, set, delete)，并且
可完全自定义它们的行为。这是一个强大的工具，有了它你可以实现很多高级功能，
并且它也是很多高级库和框架中的重要工具之一。

描述器的一个比较困惑的地方是它只能在类级别被定义，而不能为每个实例单独定义.
最后要指出的一点是，如果你只是想简单的自定义某个类的单个属性访问的话就不用去写描述器了。

### 使用延迟计算属性
将一个只读属性定义成一个 property，并且只在访问的时候才会计算结果。但
是一旦被访问后，你希望结果值被缓存起来，不用每次都去计算。
定义一个延迟属性的一种高效方法是通过使用一个描述器类

很多时候，构造一个延迟计算属性的主要目的是为了提升性能。

### 简化数据结构的初始化
很多仅仅用作数据结构的类，不想写太多烦人的 `__init__ ()` 函数
可以在一个基类中写一个公用的 `__init__ ()` 函数, 如果还想支持关键字参数，可以将关键字参数设置为实例属性：

### 定义接口或者抽象基类
定义一个接口或抽象类，并且通过执行类型检查来确保子类实现了某些特定的方法
使用 abc 模块可以很轻松的定义抽象基类.
抽象类的一个特点是它不能直接被实例化，抽象类的目的就是让别的类继承它并实现特定的抽象方法
抽象基类的一个主要用途是在代码中检查某些类是否为特定类型，实现了特定接口
尽管 ABCs 可以让我们很方便的做类型检查，但是我们在代码中最好不要过多的使
用它。因为 Python 的本质是一门动态编程语言，其目的就是给你更多灵活性，强制类
型检查或让你代码变得更复杂，这样做无异于舍本求末。

###  实现数据模型的类型约束
定义某些在属性赋值上面有限制的数据结构
在对某些实例属性赋值时进行检查, 要自定义属性赋值函数，这种情况下最好使用描述器。
还有一些技术可以简化上面的代码，其中一种是使用类装饰器,另外一种方式是使用元类.

### 实现自定义容器
实现一个自定义的类来模拟内置的容器类功能，比如列表和字典。但是你不确定到底要实现哪些方法.
collections 定义了很多抽象基类，当你想自定义容器类的时候它们会非常有用。
比如你想让你的类支持迭代，那就让你的类继承 collections.Iterable 即可.
你只要实现 `__iter__ ()` 方法就不会报错了.
collections 中很多抽象类会为一些常见容器操作提供默认的实现，这样一来你只需要实现那些你最感兴趣的方法即可

### 属性的代理访问
将某个实例的属性访问代理到内部另一个实例中去，目的可能是作为继承的一个替代方法或者实现代理模式。
简单来说，代理是一种编程模式，它将某个操作转移给另外一个对象来实现.
如果有大量的方法需要代理，那么使用 `__getattr__ ()` 方法或许或更好些.
当实现代理模式时，还有些细节需要注意。首先， `__getattr__ ()` 实际是一个后备
方法，只有在属性不存在时才会调用。因此，如果代理类实例本身有这个属性的话，
那么不会触发这个方法的。另外， `__setattr__ ()` 和 `__delattr__ ()` 需要额外的魔法来
区分代理实例和被代理实例 `_obj` 的属性。一个通常的约定是只代理那些不以下划线
开头的属性 (代理类只暴露被代理类的公共属性)。

还有一点需要注意的是， `__getattr__ ()` 对于大部分以双下划线 (`__`) 开始和结尾的
属性并不适用。如果是创建一个 ListLike 对象，会发现它支持普通的列表方法，如 append() 和
insert()，但是却不支持 len()、元素查找等。为了让它支持这些方法，你必须手动的实现这些方法代理.

### 在类中定义多个构造器
为了实现多个构造器，你需要使用到类方法
```python
import time

class Date:
""" 方法一：使用类方法 """
# Primary constructor
def __init__(self, year, month, day):
    self.year = year
    self.month = month
    self.day = day

# Alternate constructor
@classmethod
def today(cls):
    t = time.localtime()
    return cls(t.tm_year, t.tm_mon, t.tm_mday)
```

直接调用类方法即可，下面是使用示例：
```python
a = Date(2012, 12, 21) # Primary
b = Date.today() # Alternate
```

类方法的一个主要用途就是定义多个构造器。它接受一个 class 作为第一个参数
(cls)。你应该注意到了这个类被用来创建并返回最终的实例。在继承时也能工作的很好

### 创建不调用 init 方法的实例
创建一个实例，但是希望绕过执行 `__init__ ()` 方法。
可以通过 `__new__ ()` 方法创建一个未初始化的实例

当你通过这种非常规方式来创建实例的时候，最好不要直接去访问底层实例字
典，除非你真的清楚所有细节。否则的话，如果这个类使用了 `__slots__` 、properties 、
descriptors 或其他高级技术的时候代码就会失效。而这时候使用 setattr() 方法会让
你的代码变得更加通用。

### 利用 Mixins 扩展类功能
很多有用的方法，想使用它们来扩展其他类的功能。但是这些类并没有任何继
承的关系。因此你不能简单的将这些方法放入一个基类，然后被其他类继承。

通常当你想自定义类的时候会碰上这些问题。可能是某个库提供了一些基础类，你
可以利用它们来构造你自己的类。

