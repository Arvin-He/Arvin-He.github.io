<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Learn and live."><title>Python之subprocess模块 | Simple &amp; Freedom</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python之subprocess模块</h1><a id="logo" href="/.">Simple &amp; Freedom</a><p class="description">Learn and live.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/404.html"><i class="fa fa-heartbeat"> 公益404</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Python之subprocess模块</h1><div class="post-meta">Apr 22, 2017<span> | </span><span class="category"><a href="/categories/编程/">编程</a></span></div><div class="post-content"><h3 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h3><p>subprocess模块,即子进程模块,允许您生成新进程，并连接到输入/输出/错误管道，并获取其返回代码。<br>subprocess包主要功能是执行外部的命令和程序。</p>
<h3 id="subprocess模块使用"><a href="#subprocess模块使用" class="headerlink" title="subprocess模块使用"></a>subprocess模块使用</h3><p>subprocess包中定义有数个创建子进程的函数，这些函数分别以不同的方式创建子进程，可以根据需要来从中选取一个使用。另外subprocess还提供了一些管理标准流(standard stream)和管道(pipe)的工具，从而在进程间使用文本通信。</p>
<p>使用subprocess包中的函数创建子进程的时候，要注意:</p>
<ul>
<li>在创建子进程之后，父进程是否暂停，并等待子进程运行</li>
<li>函数返回什么</li>
<li>当returncode不为0时，父进程如何处理</li>
</ul>
<p>subprocess.call()<br>父进程等待子进程完成<br>返回退出信息(returncode，相当于exit code，见Linux进程基础)</p>
<p>subprocess.check_call()<br>父进程等待子进程完成<br>返回0<br>检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性，可用try…except…来检查(见Python错误处理)。</p>
<p>subprocess.check_output()<br>父进程等待子进程完成<br>返回子进程向标准输出的输出结果<br>检查退出信息，如果returncode不为0，则举出错误subprocess.CalledProcessError，该对象包含有returncode属性和output属性，output属性为标准输出的输出结果，可用try…except…来检查。</p>
<p>这三个函数的使用方法相类似，以subprocess.call()来说明:<br>我们将程序名(ls)和所带的参数(-l)一起放在一个表中传递给subprocess.call()<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line">rc = subprocess.call([<span class="string">"ls"</span>,<span class="string">"-l"</span>])</div><div class="line">subprocess.check_call(</div><div class="line">            [<span class="string">"svn"</span>, <span class="string">"export"</span>, <span class="string">"--force"</span>, <span class="string">"--revision"</span>, revision, src, dst],</div><div class="line">            stdout=subprocess.DEVNULL)</div><div class="line">output = subprocess.check_output(</div><div class="line">        [<span class="string">"svn"</span>, <span class="string">"log"</span>, svn_path, <span class="string">"-v"</span>, <span class="string">"--limit"</span>, <span class="string">"1"</span>]).decode(<span class="string">"gbk"</span>).strip()</div></pre></td></tr></table></figure></p>
<p>也可以通过一个shell来解释一整个字符串:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line">out = subprocess.call(<span class="string">"ls -l"</span>, shell=<span class="keyword">True</span>)</div><div class="line">out = subprocess.call(<span class="string">"cd .."</span>, shell=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p>
<p>上面使用了shell=True这个参数。这个时候，我们使用一整个字符串，而不是一个列表来运行子进程。<br>Python将先运行一个shell，再用这个shell来解释这整个字符串。</p>
<p>关于Popen()<br>实际上，上面的三个函数都是基于Popen()的封装(wrapper)。这些封装的目的在于让我们容易使用子进程。<br>当我们想要更个性化的需求的时候，就要转向Popen类，该类生成的对象用来代表子进程。<br>与上面的封装不同，Popen对象创建后，主程序不会自动等待子进程完成。我们必须调用对象的wait()方法，父进程才会等待 (也就是阻塞block)：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line">child = subprocess.Popen([<span class="string">"ping"</span>,<span class="string">"-c"</span>,<span class="string">"5"</span>,<span class="string">"www.google.com"</span>])</div><div class="line">print(<span class="string">"parent process"</span>)</div></pre></td></tr></table></figure></p>
<p>从运行结果中看到，父进程在开启子进程之后并没有等待child的完成，而是直接运行print。<br>对比等待的情况:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line">child = subprocess.Popen([<span class="string">"ping"</span>,<span class="string">"-c"</span>,<span class="string">"5"</span>,<span class="string">"www.google.com"</span>])</div><div class="line">child.wait()</div><div class="line">print(<span class="string">"parent process"</span>)</div></pre></td></tr></table></figure></p>
<p>此外，你还可以在父进程中对子进程进行其它操作，比如我们上面例子中的child对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">child.poll()           # 检查子进程状态</div><div class="line">child.kill()           # 终止子进程</div><div class="line">child.send_signal()    # 向子进程发送信号</div><div class="line">child.terminate()      # 终止子进程</div></pre></td></tr></table></figure></p>
<p>子进程的PID存储在child.pid</p>
<p>子进程的文本流控制<br>沿用child子进程) 子进程的标准输入，标准输出和标准错误也可以通过如下属性表示:</p>
<ul>
<li>child.stdin</li>
<li>child.stdout</li>
<li>child.stderr</li>
</ul>
<p>我们可以在Popen()建立子进程的时候改变标准输入、标准输出和标准错误，并可以利用subprocess.PIPE将多个子进程的输入和输出连接在一起，构成管道(pipe):<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line">child1 = subprocess.Popen([<span class="string">"ls"</span>,<span class="string">"-l"</span>], stdout=subprocess.PIPE)</div><div class="line">child2 = subprocess.Popen([<span class="string">"wc"</span>], stdin=child1.stdout,stdout=subprocess.PIPE)</div><div class="line">out = child2.communicate()</div><div class="line">print(out)</div></pre></td></tr></table></figure></p>
<p>subprocess.PIPE实际上为文本流提供一个缓存区。child1的stdout将文本输出到缓存区，随后child2的stdin从该PIPE中将文本读取走。child2的输出文本也被存放在PIPE中，直到communicate()方法从PIPE中读取出PIPE中的文本。<br>要注意的是，communicate()是Popen对象的一个方法，该方法会阻塞父进程，直到子进程完成。</p>
<p>我们还可以利用communicate()方法来使用PIPE给子进程输入:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> subprocess</div><div class="line">child = subprocess.Popen([<span class="string">"cat"</span>], stdin=subprocess.PIPE)</div><div class="line">child.communicate(<span class="string">"vamei"</span>.encode())</div></pre></td></tr></table></figure></p>
<p>我们启动子进程之后，cat会等待输入，直到我们用communicate()输入”vamei”。</p>
<p>调用subprocess模块的推荐方法是:推荐使用run()函数来处理几乎所有用例或情景。对于更高级的用例，可以直接使用基础的Popen接口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, shell=False, timeout=None, check=False, encoding=None, errors=None)</div></pre></td></tr></table></figure></p>
<p>运行由args描述的命令。等待命令完成，然后返回一个CompletedProcess实例。<br>完整的run函数签名与Popen构造函数大致相同(除了超时，输入和检查外)，该函数的所有参数都传递给该接口。<br>默认情况下，这不捕获stdout或stderr。要做到这一点，通过PIPE的stdout和/或stderr参数。<br>超时参数传递给Popen.communicate（）。如果超时过期，则子进程将被杀死并等待。在子进程终止后，将重新提出TimeoutExpired异常。<br>输入的参数传递给Popen.communicate（），从而传递给子进程的stdin。如果使用，它必须是一个字节序列，如果指定了编码或错误，或者是universal_newlines为真，则为字符串。使用时，内部Popen对象将自动使用stdin = PIPE创建，并且stdin参数也可能不被使用。<br>如果检查为真，并且进程以非零退出代码退出，则将引发CalledProcessError异常。该异常的属性保存参数，退出代码以及stdout和stderr（如果被捕获）。<br>如果指定了编码或错误，或者universal_newlines为true，则使用指定的编码和错误或io.TextIOWrapper默认文件在文本模式下打开stdin，stdout和stderr的文件对象。否则，文件对象将以二进制模式打开。</p>
<p>args是所有调用所必需的，应该是一个字符串或一系列程序参数。通常优选提供参数序列，因为它允许模块处理任何所需的转义和引用参数（例如，允许文件名中的空格）。如果传递单个字符串，则shell必须为True（见下文），否则字符串必须简单地命名要执行的程序，而不指定任何参数。</p>
<h3 id="Popen构造函数"><a href="#Popen构造函数" class="headerlink" title="Popen构造函数"></a>Popen构造函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None)</div></pre></td></tr></table></figure>
<p>在新进程中执行子程序。在POSIX上，该类使用os.execvp（）类似的行为来执行子程序。在Windows上，该类使用Windows CreateProcess（）函数.<br>args应该是程序参数的序列，或者是一个单个的字符串。默认情况下，如果args是序列，则要执行的程序是args中的第一个项目。如果args是字符串，则解释是平台依赖的，并在下面描述。请参阅shell和可执行参数，以获得与默认行为的更多差异。除非另有说明，否则建议将args作为序列。</p>
<p>在Windows上，如果args是一个序列，它将以转换参数序列到Windows上的字符串中所述的方式转换为字符串。这是因为底层的CreateProcess（）对字符串运行.<br>shell参数（默认为False）指定是否使用shell作为程序执行。如果shell为True，则建议将args作为字符串而不是序列传递。</p>
<h3 id="Popen-Objects-Popen对象"><a href="#Popen-Objects-Popen对象" class="headerlink" title="Popen Objects(Popen对象)"></a>Popen Objects(Popen对象)</h3><p>Popen类的实例有以下几种方法：<br>Popen.poll():检查子进程是否终止。设置并返回returncode属性。<br>Popen.wait(timeout=None):等待子进程终止。设置并返回returncode属性.如果进程在超时秒后没有终止，请引发超时突发异常。捕获这个异常是安全的，并重试等待。<br>当使用stdout = PIPE或stderr = PIPE时，这将会死锁，并且子进程向管道生成足够的输出，从而阻止等待OS管道缓冲区接受更多数据。使用Popen.communicate（）使用管道避免这种情况。<br>Popen.communicate(input=None, timeout=None):与进程交互：将数据发送到stdin。从stdout和stderr读取数据，直到文件到达。等待进程终止。可选的输入参数应该是要发送到子进程的数据，否则，如果没有数据发送给子进程，则为None。如果流以文本模式打开，则输入必须是字符串。否则，它必须是字节。<br>communication（）返回一个元组（stdout_data，stderr_data）。如果流以文本模式打开，数据将为字符串;否则，字节。<br>请注意，如果要将数据发送到进程的stdin，则需要使用stdin = PIPE创建Popen对象。类似地，要在结果元组中获得除None之外的任何内容，您还需要给出stdout = PIPE和/或stderr = PIPE.<br>如果进程在超时秒后没有终止，则会引发一个TimeoutExpired异常。捕捉此异常并重试通信不会丢失任何输出。<br>如果超时过期，子进程不会被终止，所以为了正确清理，运行良好的应用程序应该杀死子进程并完成通信：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">proc = subprocess.Popen(...)</div><div class="line">try:</div><div class="line">    outs, errs = proc.communicate(timeout=15)</div><div class="line">except TimeoutExpired:</div><div class="line">    proc.kill()</div><div class="line">    outs, errs = proc.communicate()</div></pre></td></tr></table></figure></p>
<p>读取的数据被缓冲在内存中，因此如果数据很大或无限制，则不要使用此方法。</p>
<p>Popen.terminate():</p>
<h3 id="旧的高级API"><a href="#旧的高级API" class="headerlink" title="旧的高级API"></a>旧的高级API</h3><p>在Python 3.5之前，这subprocess中函数中的check_output, check_call, call这三个函数包含了高级API到子进程。现在可以在很多情况下使用run（），但很多现有的代码调用这些函数。</p>
</div><div class="tags"><a href="/tags/Python/">Python</a></div><div class="post-nav"><a href="/2017/04/23/http-note6-2017-04-23/" class="pre">Http读书笔记第六章</a><a href="/2017/04/22/python-reviewcode1-2017-04-22/" class="next">Python之一些杂记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Web/">Web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/js/">js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/node-js/">node.js</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/python/">python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/web/">web</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/工具/">工具</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/思想/">思想</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据库/">数据库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/随笔/">随笔</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/node-js/" style="font-size: 15px;">node.js</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/计算机基础/" style="font-size: 15px;">计算机基础</a> <a href="/tags/C-C/" style="font-size: 15px;">C/C++</a> <a href="/tags/谷歌/" style="font-size: 15px;">谷歌</a> <a href="/tags/OOP/" style="font-size: 15px;">OOP</a> <a href="/tags/设计模式/" style="font-size: 15px;">设计模式</a> <a href="/tags/Flask/" style="font-size: 15px;">Flask</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/方法/" style="font-size: 15px;">方法</a> <a href="/tags/js/" style="font-size: 15px;">js</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 15px;">MongoDB</a> <a href="/tags/NodeJS/" style="font-size: 15px;">NodeJS</a> <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/NSIS/" style="font-size: 15px;">NSIS</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/web/" style="font-size: 15px;">web</a> <a href="/tags/PyQt5/" style="font-size: 15px;">PyQt5</a> <a href="/tags/Scrapy/" style="font-size: 15px;">Scrapy</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/RegExp/" style="font-size: 15px;">RegExp</a> <a href="/tags/Tools/" style="font-size: 15px;">Tools</a> <a href="/tags/SVN/" style="font-size: 15px;">SVN</a> <a href="/tags/tornado/" style="font-size: 15px;">tornado</a> <a href="/tags/Web/" style="font-size: 15px;">Web</a> <a href="/tags/redis/" style="font-size: 15px;">redis</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/12/08/jQuery-notes1-2017-12-08/">jQuery笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/08/js-dom-2017-12-08/">javascript之DOM操作</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/08/appium-notes1-2017-12-08/">Appium笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/08/js-object-2017-12-08/">javascript 标准对象</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/07/selenium-notes1-2017-12-07/">selenium笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/04/js-notes2-2017-12-04/">javascript笔记(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/28/proxy-2017-11-28/">proxy一些知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/25/redis-note1-2017-11-25/">redis笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/16/tornado-note2-2017-11-16/">tornado学习笔记(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/16/howtoreadsource-2017-11-16/">如何去阅读源码</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">Simple &amp; Freedom.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>